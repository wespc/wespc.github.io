<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ピーターのブログ</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-08T02:07:10.485Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Peng Cheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux系统进程文件procs</title>
    <link href="http://example.com/[object%20Object]/2023/04/08/proc/"/>
    <id>http://example.com/[object%20Object]/2023/04/08/proc/</id>
    <published>2023-04-08T02:00:37.000Z</published>
    <updated>2023-04-08T02:07:10.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="来源"><a href="#来源" class="headerlink" title="来源:"></a>来源:</h3><p><a class="link"   href="https://www.gnu.org/software/libc/manual/html_node/Process-Identification.html" >Process Identification (The GNU C Library) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>每个进程都由一个进程ID号命名,一个类型为<em>pid_t 的值.进程ID在在进程创建时分配给他.进程 ID 会随着时间的推移重复使用。一个进程的生命期结束,当这个进程的父进程在结束后等待进程ID时.请参阅流程完成。（父进程可以安排隐式发生此类等待。一个进程ID只在进程生命期内特指一个进程.根据经验，这意味着进程必须仍在运行。</em></p><p>进程 ID 还可以表示进程组和会话。请参阅作业控制。</p><p>在LINUX上,一个线程由 <em>pthread_create</em> 创建,也获得一个线程ID. 初始(主)线程ID与整个进程的进程ID相同.后续创建的线程的线程ID是不同的.他们和进程ID从相同的数字空间分配.进程ID和线程ID有时也统称为任务ID.与进程相反,线程永远不会显式等待,因此，线程 ID 在线程退出或取消后立即符合重用条件.即使对于可联接线程也是如此，而不仅仅是分离的线程。线程被分配到线程组.在运行在 Linux 上的 GNU C 库实现中，进程 ID 是进程中所有线程的线程组 ID。</p><p>你可以获得进程ID通过 调用<em>getpid. 函数getppid</em>返回当前进程的父线程.(也叫作 父进程id).你的程序需要包含头文件 <em>unisd.h</em> 和 <em>sys&#x2F;types.h</em> 去使用这些函数.</p><h3 id="数据类型-pid-t"><a href="#数据类型-pid-t" class="headerlink" title="数据类型: pid_t"></a>数据类型: pid_t</h3><p>&#x2F;    <em>pid_t</em> 类型是一个有符号整形,可以代表一个进程ID. 在 GNU C库中 ,这是一个<em>int</em></p><h3 id="函数-pid-t-getpid-void"><a href="#函数-pid-t-getpid-void" class="headerlink" title="函数: pid_t getpid(void)"></a>函数: pid_t getpid(void)</h3><p>&#x2F;    Preliminary: | MT-Safe | AS-Safe | AC-Safe | See <a class="link"   href="https://www.gnu.org/software/libc/manual/html_node/POSIX-Safety-Concepts.html" >POSIX Safety Concepts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>     <em>getpid</em> 函数返回当前进程的进程 id</p><h3 id="函数-pid-t-getppid-void"><a href="#函数-pid-t-getppid-void" class="headerlink" title="函数: pid_t getppid(void)"></a>函数: pid_t getppid(void)</h3><p>&#x2F;    getppid 函数返回当前函数的父进程id</p><h3 id="函数-pid-t-gettid-void"><a href="#函数-pid-t-gettid-void" class="headerlink" title="函数: pid_t gettid(void)"></a>函数: pid_t gettid(void)</h3><p>&#x2F;    gettid 函数返回当前线程的线程 ID.返回值是从 Linux 内核获取的，不受缓存限制。请参阅上面对线程 ID 的讨论，特别是关于重用已退出的线程的 ID。</p><pre><code> 此函数特定于 Linux。</code></pre><h2 id="1-2-2-1-POSIX-Safety-Concepts"><a href="#1-2-2-1-POSIX-Safety-Concepts" class="headerlink" title="1.2.2.1 POSIX Safety Concepts"></a><strong>1.2.2.1 POSIX Safety Concepts</strong></h2><p><a class="link"   href="https://www.gnu.org/software/libc/manual/html_node/POSIX-Safety-Concepts.html" >POSIX Safety Concepts (The GNU C Library) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>本手册记录了 GNU C 库函数的各种安全属性，这些属性遵循其原型，如下所示：<br>Preliminary: | MT-Safe | AS-Safe | AC-Safe |</p><p>posix: the protable operating system interface</p><p>根据POSIX标准中针对线程、异步信号和异步取消安全等安全环境规定的标准评估属性。</p><ul><li>MT-Safe 或者 线程韩圈函数, 在有其他线程存在时可以安全调用, MT,代表 MT-safe, 代表多线程.</li></ul><p>&#x2F;&#x2F;</p><ul><li>AS-Safe 或异步信号安全函数,可以从异步信号处理进程安全调用. AS 代表 异步信号.</li></ul><p>&#x2F;&#x2F;</p><ul><li>AC-Safe 或异步取消安全函数启用异步取消时可以安全调用。AC代表异步取消.</li></ul><p>&#x2F;&#x2F;</p><ul><li>MT-Unsafe, AS-Unsafe,AC-Unsafe 函数在上述安全上下文中调用函数是不安全的。在上述环境下调用会产生未定义内容.</li></ul><p>&#x2F;&#x2F;</p><ul><li>Preliminary 初步的安全属性被记录在案，表明这些属性可能不会在GNU C库的未来版本中被依赖。</li></ul><p>&#x2F;&#x2F;</p><h1 id="procfs-proc-filesystem-procfs"><a href="#procfs-proc-filesystem-procfs" class="headerlink" title="procfs: proc filesystem (procfs)"></a>procfs: proc filesystem (procfs)</h1><p>procs 是 类unix系统中一个特殊的文件系统,展示关于进程和其他系统相关信息,以类分层文件结构.他提供了更加方便和标准化的方式去动态获取内核中保存的进程信息,相比于传统的跟踪方法或直接访问内核内存。通常，它在引导时(boot)映射到名为 &#x2F;proc 的装入点。procs 就像内核中进程的内部数据结构的访问界面(interface).Linux中,他可以用来获得内核信息或在运行时改变特定内核参数.</p><p>很多类Unix操作系统支持proc filesystem,包括…UNIX,LINUX,…</p><p>Linux 内核将其扩展到与进程无关的数据。</p><p>proc filesystem 提供了内核空间和用户空间的交流方式.例如GNU版本的进程报告工具ps 使用proc file system去获取数据,而不适用任何系统调用.</p><p>截止2020年,Linux 实现包括每个运行进程的目录,包括内核进程.在目录 &#x2F;proc&#x2F;PID 中,PID是进程号.每个目录包含一个进程的信息,包括:</p><ul><li><p>&#x2F;proc&#x2F;PID&#x2F;cmdline, 最初启动进程的命令.</p></li><li><p>&#x2F;proc&#x2F;PID&#x2F;cwd, 指向进程当前目录的符号链接.</p></li><li><p>&#x2F;proc&#x2F;PID&#x2F;environ, 影响进程的环境变量的名字和值</p></li><li><p>&#x2F;proc&#x2F;PID&#x2F;exe, 指向源可执行文件的符号链,如果他还存在的话(进程可能还在运行在他源可执行文件被删除或替换的情况下.)</p></li><li><p>&#x2F;proc&#x2F;PID&#x2F;fd, 包含每个打开的文档描述符file descriptor的符号链接的目录。</p><p>  <a class="link"   href="https://en.wikipedia.org/wiki/File_descriptor" >文件描述符 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>:在 Unix 和类 Unix 的计算机操作系统中，文档描述符（FD，不太常见的 fildes）是文档或其他输入&#x2F;输出资源（如管道或网络套接字）的进程唯一标识符（句柄）。</p></li><li><p>&#x2F;proc&#x2F;PID&#x2F;fdinfo, 包含描述每个打开文档描述符的位置和标志的条目的目录。</p></li><li><p>&#x2F;proc&#x2F;PID&#x2F;maps, 包含有关映射文件和块的文本文件</p></li><li><p>&#x2F;proc&#x2F;PID&#x2F;mem, 代表进程虚拟内存的二进制映像.只能由 Ptrace’ing 进程访问。</p></li><li><p>&#x2F;proc&#x2F;PID&#x2F;root, 进程看到的指向根路径的符号链接.对于大多数进程，这将是指向 &#x2F; 的链接，除非进程在 chroot 监狱中运行。</p></li><li><p>&#x2F;proc&#x2F;PID&#x2F;status, 包含一个进程的基本信息,包括运行状态和内存使用.</p></li><li><p>&#x2F;proc&#x2F;PID&#x2F;task,包含任何由这个进程启动的任务的硬链接.</p></li></ul><hr><p>&#x2F;proc 也包含进程无关的系统信息,尽管在2.6内核中多数这样的信息被单独移动到单独的伪文档系统 sysfs,挂载在 &#x2F;sys :</p><ul><li><p>根据电源管理的模式（如果有的话），目录 &#x2F;proc&#x2F;acpi 或 &#x2F;proc&#x2F;apm，它们早于 sysfs 并包含有关电源管理状态的各种信息位。</p></li><li><p>&#x2F;proc&#x2F;buddyinfo, 有关处理内存碎片的伙伴算法的信息。</p></li><li><p>&#x2F;proc&#x2F;bus,包含代表计算机上各种总线的目录，比如PCI&#x2F;USB.这在很大程度上已被 &#x2F;sys&#x2F;bus 下的 sysfs 所取代，后者的信息量要大得多。</p></li><li><p>&#x2F;proc&#x2F;fb, 可用帧缓冲器的列表</p></li><li><p>&#x2F;proc&#x2F;cmdline,提供传递给内核的引导选项</p></li><li><p>&#x2F;proc&#x2F;cpuinfo,包含CPU的信息,例如其供应商（以及 CPU 系列、型号和型号名称，应允许用户识别 CPU）及其速度（CPU 时钟速度）、缓存大小、同级、内核和 CPU 标志的数量。&#x2F;proc&#x2F;cpuinfo 包含一个“bogomips”的值，经常被误解为 CPU 速度的度量，就像基准测试一样，但它实际上根本没有测量任何合理的（对于最终用户）值。它是内核计时器校准的副作用，并且根据 CPU 类型产生高度变化的值，即使在相同的时钟速度下也是如此。</p><p>  在多核CPU上，&#x2F;proc&#x2F;cpuinfo包含“同级”和“CPU核心”的字段，它们代表以下计算：[7]</p></li></ul><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;siblings&quot;</span> = (HT per CPU package) * (<span class="comment"># of cores per CPU package)</span></span><br><span class="line"><span class="string">&quot;cpu cores&quot;</span> = (<span class="comment"># of cores per CPU package)</span></span><br></pre></td></tr></table></figure></div><p>CPU 封装是指可以有多个内核的物理 CPU（单核为一个，双核为两个，四核为四个）。这允许区分超线程和双核，即每个 CPU 包的超线程数可以由兄弟姐妹&#x2F;CPU 内核计算。如果 CPU 包的两个值相同，则不支持超线程。[8] 例如，同级&#x3D;2和“CPU内核”&#x3D;2的CPU软件包是双核CPU，但不支持超线程。</p><ul><li><p>&#x2F;proc&#x2F;crypto, 可用加密模块列表</p></li><li><p>&#x2F;proc&#x2F;devices,按设备 ID 排序的字符和块设备列表，但也给出了 &#x2F;dev 名称的主要部分</p></li><li><p>&#x2F;proc&#x2F;diskstats,给出每个逻辑磁盘设备的一些信息(包括设备号)</p></li><li><p>&#x2F;proc&#x2F;filesystems,列出时内核支持的文件系统列表</p></li><li><p>&#x2F;proc&#x2F;interrupts,&#x2F;proc&#x2F;iomem,&#x2F;proc&#x2F;ioports 和目录&#x2F;proc&#x2F;irq, 提供有关使用各种系统资源的设备（物理或逻辑）的一些详细信息</p></li><li><p>&#x2F;proc&#x2F;kmsg,含有内核输出的信息</p></li><li><p>&#x2F;proc&#x2F;meminfo,包含内核如何管理其内存的摘要。</p></li><li><p>&#x2F;proc&#x2F;modules, &#x2F;proc 中最重要的文件之一,包含当前加载的内核模块的列表,它给出了一些依赖关系的指示（并不总是完全正确）。</p></li><li><p>&#x2F;proc&#x2F;mounts,指向 self&#x2F;mount 的符号链接，其中包含当前装载的设备及其挂载点的列表（以及正在使用的文档系统和正在使用的挂载选项）。</p></li><li><p>&#x2F;proc&#x2F;net&#x2F;,包含网络栈有用信息的目录,特别是 &#x2F;proc&#x2F;net&#x2F;nf_conntrack，它列出了现有的网络连接（当使用 iptables FORWARD 重定向网络连接时，对于跟踪路由特别有用）</p></li><li><p>&#x2F;proc&#x2F;partitions, 设备号列表,它们的大小和内核已标识为现有分区的 &#x2F;dev 名称</p></li><li><p>&#x2F;proc&#x2F;scsi,任何通过SCSI 和RAID控制器连接的设备的信息.</p></li><li><p>指向 &#x2F;proc&#x2F;self 处的当前（遍历）进程的符号链接（即 &#x2F;proc&#x2F;PID&#x2F;，其中 PID 是当前进程的 PID）。</p></li><li><p>&#x2F;proc&#x2F;slabinfo,列出 Linux 内核中常用对象的缓存统计信息</p></li><li><p>&#x2F;proc&#x2F;swaps,活动交换分区及其各种大小和优先级的列表</p></li><li><p>访问 &#x2F;proc&#x2F;sys 下的动态可配置内核选项。在 &#x2F;proc&#x2F;sys 下出现代表内核区域的目录，其中包含可读和可写的虚拟文档。</p><p>  例如，通常引用的虚拟文档是 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward，因为它是路由防火墙或隧道所必需的。该文档包含“1”或“0”：如果为 1，则 IPv4 堆栈转发不适用于本地主机的数据包，如果为 0，则不转发。</p></li><li><p>&#x2F;proc&#x2F;sysvipc,包含内存共享和进程间通信 （IPC） 信息。</p></li><li><p>&#x2F;proc&#x2F;tty,包含有关当前终端的信息,&#x2F;proc&#x2F;tty&#x2F;driver 看起来是[原始研究？] 可用不同类型的 TTY 的列表 - 每个类型都是每种类型的列表</p></li><li><p>&#x2F;proc&#x2F;uptime, 内核自引导以来运行和处于空闲模式的时间长度（均以秒为单位）</p></li><li><p>&#x2F;proc&#x2F;version, Linux 内核版本,发行版号、gcc 版本号（用于构建内核）以及与当前运行的内核版本相关的任何其他相关信息</p></li><li><p>其他文件取决于各种硬件、模块配置和对内核的更改。</p></li></ul><p>在 Linux 下使用 &#x2F;proc 的基本实用进程位于 procps（&#x2F;proc processes）包中，并且只能与挂载的 &#x2F;proc 结合使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;来源&quot;&gt;&lt;a href=&quot;#来源&quot; class=&quot;headerlink&quot; title=&quot;来源:&quot;&gt;&lt;/a&gt;来源:&lt;/h3&gt;&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://www.gnu.org/software/libc/manual/htm</summary>
      
    
    
    
    
    <category term="proc" scheme="http://example.com/tags/proc/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>shellscript 教程</title>
    <link href="http://example.com/[object%20Object]/2023/03/02/shellscript/"/>
    <id>http://example.com/[object%20Object]/2023/03/02/shellscript/</id>
    <published>2023-03-02T11:47:24.000Z</published>
    <updated>2023-04-08T01:58:53.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h1><p><a class="link"   href="https://www.shellscript.sh/index.html" >Shell Scripting Tutorial <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><h2 id="这个教程的目的"><a href="#这个教程的目的" class="headerlink" title="这个教程的目的"></a>这个教程的目的</h2><p>帮人们理解shell脚本编程的基本知识(aka shell scripting), 也可能会介绍一些在Bourne shell下简单但强大的编程技巧. 因此，它已被编写为一对一或小组教程和练习的基础，并作为后续使用的参考。</p><h2 id="面向读者"><a href="#面向读者" class="headerlink" title="面向读者:"></a>面向读者:</h2><p>本教程假定具有一些先前的经验;即：</p><ul><li>使用交互式 Unix&#x2F;Linux shell</li><li>最少的编程知识 - 变量、函数的使用是有用的背景知识</li><li>了解一些 Unix&#x2F;Linux 命令，并有能力使用一些更常用的命令。 （ls、cp、echo 等）</li><li>使用 ruby、perl、python、C、Pascal 或任何编程语言（甚至 BASIC）的进程员，他们可能会阅读 shell 脚本，但并不认为他们确切地理解它们是如何工作的。</li></ul><h2 id="本教程中使用的排版约束"><a href="#本教程中使用的排版约束" class="headerlink" title="本教程中使用的排版约束"></a>本教程中使用的排版约束</h2><p>重要的单词会在第一次出现时用<em>斜体</em>标出</p><p>代码段和脚本展示为等宽文本.</p><p>命令行条目前面将带有美元符号 （$）。如果您的提示不同,请输入命令:</p><p>然后，您的互动应与给出的示例匹配（例如下面的 .&#x2F;my-script.sh）。</p><p>脚本输出（例如下面的“Hello World”）显示在行首。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;#!/bin/sh&#x27;</span> &gt; my-script.sh</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;echo Hello World&#x27;</span> &gt;&gt; my-script.sh</span><br><span class="line">$ <span class="built_in">chmod</span> 755 my-script.sh</span><br><span class="line">$ ./my-script.sh</span><br><span class="line">Hello World</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div><p>整个脚本将以灰色背景显示，并包括对脚本纯文本的引用（如果可用）：</p><p><a class="link"   href="https://www.shellscript.sh/eg/my-script.sh.txt" >my-script.sh <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># This is a comment!</span></span><br><span class="line"><span class="built_in">echo</span> Hello World<span class="comment"># This is a comment, too!</span></span><br></pre></td></tr></table></figure></div><p>请注意，要使文档可执行，必须设置可执行位，对于 shell 脚本，还必须设置可读位：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> a+rx my-script.sh</span><br><span class="line">$ ./my-script.sh</span><br></pre></td></tr></table></figure></div><h1 id="2-哲学"><a href="#2-哲学" class="headerlink" title="2.哲学"></a>2.哲学</h1><p>Shell脚本编程在一些Unix系统管理员中有点不好。一般因为这两件事</p><ul><li>与 C 进程甚至解释型 Perl 进程相比，解释进程的运行速度。</li><li>由于编写简单的批处理作业类型的 shell 脚本很容易，因此周围有很多质量差的 shell 脚本。</li></ul><p>部分由于这一点，创建好的 shell 脚本存在一定的大男子主义。例如，可以用作CGI进程的脚本，而不会在速度上输给Perl太多（尽管在许多情况下，两者都会输给C，这是速度的唯一标准）。</p><p>有许多因素可以进入好的、干净的、快速的 shell 脚本。</p><ul><li>最重要的标准必须是 感情 可阅读的排版.</li><li>第二是避免没必要的命令.</li></ul><p>清晰的布局使得 shell 脚本看起来像“黑魔法”，是易于维护和理解的脚本</p><p>您可能会认为使用简单的脚本，这不是一个太重要的问题，但这里有两件事值得牢记。</p><ol><li>首先，一个简单的脚本会比预期的更频繁地成长为一个庞大而复杂的脚本。</li><li>其次，如果没有其他人能理解它是如何工作的，你将在余生中自己维护它！</li></ol><p>关于 shell 脚本的某些东西似乎使它们特别容易被严重缩进，并且由于主要的控制结构是 if&#x2F;then&#x2F;else 和循环，缩进对于理解脚本的作用至关重要。</p><p>许多 shell 脚本中的一个弱点是以下行：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /tmp/myfile | grep <span class="string">&quot;mystring&quot;</span></span><br></pre></td></tr></table></figure></div><p>这样会快的多</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;mystring&quot;</span> /tmp/myfile</span><br></pre></td></tr></table></figure></div><p>不多，你可能会考虑; 操作系统必须加载 &#x2F;bin&#x2F;grep可执行文档, 在我的系统上，这是一个相当小的 75600 字节， 在内存中开辟管道(pipe)用于传输, 加载运行 &#x2F;bin&#x2F;cat 可执行文件,他甚至更小在我的计算机上只有9528字节,将其连接到管道的输入，然后让它运行。</p><p>当然,OS存在就是做这种事的,通常这样做也很高效.但如果在一个循环中这个命令被运行很多次, 因为不用定位和加载 cat可执行文件,设置和释放管道而产生的不同就很不同,特别是CGI环境, 已经有很多其他因素拖慢进程, 而不会使脚本本身成为太大障碍.一些Unices在他们所谓的“创建和拆除流程”方面比其他Unices更有效率 - 即即加载它们，执行它们，然后再次清除它们。但是，无论您的Unix风格如何做到这一点，它都宁愿根本不需要这样做。</p><p>因此，您可能会听到提到没用的 cat 奖（UUoC），</p><p><a class="link"   href="http://catb.org/jargon/html/U/UUOC.html" >UUOC <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>在某些圈子中也被称为在严肃的shell脚本中无偿使用猫一词的奖项，该奖项不时在comp.unix.shell新闻组上流传。这纯粹是同行相互检查并确保事情正确完成的一种方式。</p><p>这让我很好地想到了别的东西：永远不要觉得自己与自己的 shell 脚本太近;就其性质而言，源头不能关闭。如果您向客户提供 shell 脚本，他&#x2F;她可以很容易地检查它。因此，您不妨接受它将由您传递给的任何人进行检查;通过 GPL 利用这一点 - 鼓励人们免费为您提供反馈和错误修复！</p><h1 id="3-第一个脚本"><a href="#3-第一个脚本" class="headerlink" title="3.第一个脚本"></a>3.第一个脚本</h1><p>作为我们第一个脚本,我们就写一个输出 “Hello World” 的脚本.然后，我们将尝试从Hello World进程中获得更多比您读过的任何其他教程更多的内容：-）</p><p>创建一个文件如下:</p><p>first.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># This is a comment!</span></span><br><span class="line"><span class="built_in">echo</span> Hello World        <span class="comment"># This is a comment, too!</span></span><br></pre></td></tr></table></figure></div><p>第一行告诉 Unix 这个文件要被 by&#x2F;bin&#x2F;sh 执行. 这是 Unix系统的Bourne shell 的标准位置. 如果你在用 GNU&#x2F;Linux, &#x2F;bin&#x2F;sh 通常是到bash的符号链.</p><p>第二行以特殊符号 <code>#</code> 开始. 这标志着这行是注释, 会完全被shell忽略.</p><p>唯一的例外是文件的第一行 以<code>#!</code> 开始,就像我们做的那样. 这是Unix 特别对待的特殊指令. 这意味着即使你用csh,ksh 或其他任何交互式shell,  接下来的东西应该被 Bourne shell 解释.</p><p>相似的, Perl 脚本会已 <code>#!/usr/bin/perl</code> 开始,会告诉你的交互式shell接下来的 进程应该被perl执行. 对于Bourne shell 我们会继续用 <code>#!/bin/sh.</code></p><p>第三行运行一个命令 :<code>echo</code>, 和两个参数 ,第一个 “Hello”, 第二个”World”.</p><p>注意<code>echo</code> 会自动放一个空格在他和参数之间. <code>#</code> 仍然标注一个注释. #和他之后的任何内容会被shell忽视.</p><p>现在运行 <code>chmod 755 first.sh</code> 让文本可执行, 运行 <code>./first.sh</code> 你的屏幕之后应该看起看起来像这样.</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> 755 first.sh</span><br><span class="line">$ ./first.sh</span><br><span class="line">Hello World</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div><p>你也许已经猜到了,你也可以这样运行:</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> Hello World</span><br><span class="line">Hello World</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div><p>现在让我们做点改变.</p><p>首先注意<code>echo</code> 在他的参数之间放了一个空格, 在”Hello” 和”World” 之间多放几个空格. 你预期会输出什么? 放TAB 在中间呢?</p><p>像往常一样,编写程序看看结果.</p><p>输出完全一样. 我们用两个参数调用<code>echo</code>, 他并不关心中间的空格.</p><p>现在修改代码重试:</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># This is a comment!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello      World&quot;</span>       <span class="comment"># This is a comment, too!</span></span><br></pre></td></tr></table></figure></div><p>这次他起作用了,你也许也猜到了.如果你有其他编程语言经验.</p><p>但理解更复杂的指令和shell脚本的关键是理解并能解释为什么?<code>echo</code> 现在只有一个参数,字符串”Hello       World”. 他完全打印出来.</p><p>这里要理解的一点是，shell 在将参数传递给被调用的进程<strong>之前</strong>解析参数。</p><p>在这种情况下，它去掉引号，但将字符串作为一个参数传递。</p><p>作为最后一个例子, 输入下列脚本.. 尝试运行前猜测结果.</p><p>first2.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># This is a comment!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello      World&quot;</span>       <span class="comment"># This is a comment, too!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello * World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> Hello * World</span><br><span class="line"><span class="built_in">echo</span> Hello      World</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span> World</span><br><span class="line"><span class="built_in">echo</span> Hello <span class="string">&quot;     &quot;</span> World</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello &quot;</span>*<span class="string">&quot; World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> `hello` world</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> world</span><br></pre></td></tr></table></figure></div><p>是不是所有的都猜到了,如果没有,不用担心,只是一些在后面的教程会提到的东西. … and yes, 我们会用到比echo更强大的指令.</p><h1 id="4-变量-Part-1"><a href="#4-变量-Part-1" class="headerlink" title="4. 变量 Part 1"></a>4. 变量 Part 1</h1><p>几乎每种现有的编程语言都有变量的概念-内存块的符号名称，我们可以为其赋值、读取和操作其内容。Bourne shell 也不例外，本节将介绍这个想法。环境为我们设置的变量在变量 - 第二部分中进一步介绍. 让我们回顾一下我们的第一个 Hello World 示例。这可以使用变量来完成（尽管这是一个如此简单的例子)，它并不真正保证它！请注意，“&#x3D;”符号周围不能有空格：<code>VAR=value</code>; <code>VAR = value</code>不起作用。第一个例子中,shell 会看到“&#x3D;”符号，并将命令视为变量赋值。在第二种情况下，shell 假定 VAR 是命令的名称并尝试执行它。</p><p>如果你思考下, 这说得通, 你还能怎幺告诉它运行命令 VAR，它的第一个参数是“&#x3D;”，它的第二个参数是“value”？</p><p>在 var.sh 中输入以下代码：</p><p>var.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">MY_MESSAGE=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$MY_MESSAGE</span></span><br></pre></td></tr></table></figure></div><p>这会将字符串“Hello World”分配给变量<code>MY_MESSAGE</code>然后<code>echo</code>出变量的值。</p><p>请注意，我们需要字符串 Hello World 周围的引号。虽然我们可以摆脱 <code>echo Hello World</code>，因为echo将接受任意数量的参数，但一个变量只能保存一个值，因此必须将带有空格的字符串括起来，以便shell知道将其视为一个。否则，shell 将在分配 <code>MY_MESSAGE=Hello</code> 后尝试执行命令 <code>World</code>。</p><p>shell 并不关心变量的类型. 他们也许会存储字符串,正数,实数 任何你喜欢的.</p><p>用Perl的人一定因此很开心. 如果你从C, Pascal 或更糟 Ada 开始, 这就很奇怪了.</p><p>事实上,他们都以字符串存储.但是期望数字的例程可以这样对待它们。<br>如果你给一个变量赋值字符串然后尝试 +1, 你不会侥幸逃脱的：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ x=<span class="string">&quot;hello&quot;</span></span><br><span class="line">$ <span class="built_in">expr</span> <span class="variable">$x</span> + 1</span><br><span class="line"><span class="built_in">expr</span>: non-numeric argument</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div><p>这是因为外部进程 expr 只期望数字。但是两者之间没有语法差异：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MY_MESSAGE=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line">MY_SHORT_MESSAGE=hi</span><br><span class="line">MY_NUMBER=1</span><br><span class="line">MY_PI=3.142</span><br><span class="line">MY_OTHER_PI=<span class="string">&quot;3.142&quot;</span></span><br><span class="line">MY_MIXED=123abc</span><br></pre></td></tr></table></figure></div><p>但请注意，必须正确转义特殊字符以避免 shell 解释。</p><p>这在第六章会解释 转义字符.Escape Characters</p><p>我们可以使用 read 命令交互式设置变量名称;以下脚本会询问您的名字，然后亲自向您打招呼：</p><p>VAR2.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> What is your name?</span><br><span class="line"><span class="built_in">read</span> MY_NAME</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$MY_NAME</span> - hope you&#x27;re well.&quot;</span></span><br></pre></td></tr></table></figure></div><p>Mario Bacinsky善意地向我指出，我最初错过了最后一行的双引号，这意味着单词“you’re”中的单引号不匹配，导致错误。正是这种事情会让 shell 程序员发疯，所以要小心他们！</p><p>这是用shell内置命令<code>read</code> 从标准输入读入一行到 提供的变量中.</p><p>注意 即使你给出你的全名而不用双引号括起来,他仍然可以正确输出. 这是怎么工作的? 对于前面的MY_MESSAGE变量，我们必须在它周围加上双引号来设置它。</p><p>是这样的,read指令自动在输入放置引号,所以空格不会出错.(当然，您需要引用输出 - 例如 <code>echo“$MY_MESSAGE”</code>）</p><h2 id="变量的范围"><a href="#变量的范围" class="headerlink" title="变量的范围"></a>变量的范围</h2><p>Bourne shell 中的变量可以不声明,像c中那样.但如果你尝试阅读 为声明变量, 结果是空串.没有warnings 或errors. 这可能造成隐含bugs. 如果你赋值<code>MY_OBFUSCATED_VARIABLE=Hello</code>  然后你什么也得不到(因为第二个OBFUSCATED 拼错了).</p><p>有一个名为 <code>export</code> 的命令，它对变量的范围有根本的影响。为了真正理解你的变量怎么了,你需要知道这是怎么工作的.</p><p>创建一个小shell 脚本, <code>myvar2.sh</code> :</p><p>myvar2.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;MYVAR is: <span class="variable">$MYVAR</span>&quot;</span></span><br><span class="line">MYVAR=<span class="string">&quot;hi there&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;MYVAR is: <span class="variable">$MYVAR</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p>现在运行脚本:</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./myvar2.sh</span><br><span class="line">MYVAR is:</span><br><span class="line">MYVAR is: hi there</span><br></pre></td></tr></table></figure></div><p>MYVAR 还没被设置为任何值,所以是空的.然后我们给他一个值, 然后他有了预期结果.</p><p>现在运行:</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ MYVAR=hello</span><br><span class="line">$ ./myvar2.sh</span><br><span class="line">MYVAR is:</span><br><span class="line">MYVAR is: hi there</span><br></pre></td></tr></table></figure></div><p>他还是没有被设置,怎么回事?</p><p>当你从交互shell调用 myvar2.sh, 将生成一个新的 shell 来运行脚本。 这部分是因为 脚本开始行的 #!&#x2F;bin&#x2F;sh .我们之前提到的.</p><p>我们需要导出变量以便它被另一个进程继承 - 包括一个 shell 脚本。类型：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> MYVAR</span><br><span class="line">$ ./myvar2.sh</span><br><span class="line">MYVAR is: hello</span><br><span class="line">MYVAR is: hi there</span><br></pre></td></tr></table></figure></div><p>现在 看看脚本第三行,MYVAR的值变了, 但没有办法将值再传回你的交互shell. 尝试读MYVAR的值:</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYVAR</span></span><br><span class="line">hello</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div><p>一旦shell 脚本退出,他的环境就摧毁了. 但MYVAR 保持在你的交互shell的值.</p><p>为了获得脚本中环境变化,我们必须获取脚本 - 这有效地在我们自己的交互式 shell 中运行脚本，而不是生成另一个 shell 来运行它。</p><p>我们可以通过“.”（点）命令：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ MYVAR=hello</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYVAR</span></span><br><span class="line">hello</span><br><span class="line">$ . ./myvar2.sh          <span class="comment"># 注意两点之间有空格,否则出错.</span></span><br><span class="line">MYVAR is: hello</span><br><span class="line">MYVAR is: hi there</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYVAR</span></span><br><span class="line">hi there</span><br></pre></td></tr></table></figure></div><p>现在，这个变化又进入了我们的shell！例如，这就是您的 .profile 或 .bash_profile 文档的工作方式。</p><p>注意在这个例子中,我们不需要 <code>export MYVAR</code>.感谢 sway 指出我最初说的是echo MYVAR ，而不是应该echo$MYVAR。另一个使用 shell 脚本容易犯错误的例子。关于变量，在这一点上值得一提的另一件事是考虑以下 shell 脚本：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;What is your name?&quot;</span></span><br><span class="line"><span class="built_in">read</span> USER_NAME</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$USER_NAME</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I will create you a file called <span class="variable">$USER_NAME_file</span>&quot;</span></span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$USER_NAME_file</span></span><br></pre></td></tr></table></figure></div><p>想想你会得到什么答案.例如,如果你输入steve作为USER_NAME, 脚本会创建 <code>steve_file</code> 吗?</p><p>事实上,不会.这会出错,除非有个变量叫做<code>USER_NME_file</code>. shell不知道变量在哪结束,剩下的从哪开始.我们该怎么定义?</p><p>答案是，我们将变量本身括在大括号中：</p><p>user.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;What is your name?&quot;</span></span><br><span class="line"><span class="built_in">read</span> USER_NAME</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$USER_NAME</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I will create you a file called <span class="variable">$&#123;USER_NAME&#125;</span>_file&quot;</span></span><br><span class="line"><span class="built_in">touch</span> <span class="string">&quot;<span class="variable">$&#123;USER_NAME&#125;</span>_file&quot;</span></span><br></pre></td></tr></table></figure></div><p>脚本现在知道我们引用变量 <code>USER_NAME</code> 并且我们希望它以“_file”为后缀。这可能是许多新的 shell 脚本进程员的垮台，因为问题的根源可能很难追踪。</p><p>还要注意“${USER_NAME}_file”周围的引号 - 如果用户输入“Steve Parker”（注意空格），那幺如果没有引号，传递给 touch 的参数将是 Steve 和 Parker_file - 也就是说，我们实际上是在创建 steve 和Parker_file，这是要创建的两个文档，而不是一个。引号避免了这一点。感谢克里斯强调这一点。</p><h1 id="5-通配符-Wildcards"><a href="#5-通配符-Wildcards" class="headerlink" title="5 通配符 Wildcards"></a>5 通配符 Wildcards</h1><p>通配符实在不算什么新的内容如果你之前用Unix.</p><p>不过，它们在 shell 脚本中的用处并不一定很明显。本节实际上只是让旧的灰色单元格思考当您在 shell 脚本中时的外观 - 预测使用不同语法的效果是什幺。之后将使用，特别是在循环部分中。</p><p>首先考虑如何将所有文档从 &#x2F;tmp&#x2F;a 复制到 &#x2F;tmp&#x2F;b 中。所有.txt文档？所有.html文档？</p><p>希望你能想出：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> /tmp/a/* /tmp/b/</span><br><span class="line">$ <span class="built_in">cp</span> /tmp/a/*.txt /tmp/b/</span><br><span class="line">$ <span class="built_in">cp</span> /tmp/a/*.html /tmp/b/</span><br></pre></td></tr></table></figure></div><p>现在，如何在不使用ls &#x2F;tmp&#x2F;a&#x2F;的情况下列出&#x2F;tmp&#x2F;a&#x2F;中的文档？echo &#x2F;tmp&#x2F;a&#x2F;* 怎幺样？这和ls输出之间的两个主要区别是什幺？怎么利用它？还是障碍？</p><p>如何将所有.txt文档重命名为 .bak？注意到，</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> *.txt *.bak</span><br></pre></td></tr></table></figure></div><p>不会有预期的效果;考虑一下在传递给 MV 之前，shell 如何对其进行扩展。 如果有帮助，请尝试使用 echo 而不是 mv 执行此操作。我们稍后会进一步研究这个问题，因为它使用了一些尚未涵盖的概念。</p><h1 id="6-转义字符"><a href="#6-转义字符" class="headerlink" title="6. 转义字符"></a>6. 转义字符</h1><p>某些字符对shell很重要;例如，我们已经看到，使用双引号 （“） 字符会影响空格和 TAB 字符的处理方式，例如：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> Hello       World</span><br><span class="line">Hello World</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello       World&quot;</span></span><br><span class="line">Hello     World</span><br></pre></td></tr></table></figure></div><p>那我们怎么显示: Hello                 “World” ?</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello   \&quot;World\&quot;&quot;</span></span><br></pre></td></tr></table></figure></div><p>第一个和最后一个 “ 字符将整个批次包装到一个传递给 echo 的参数中，以便两个单词之间的间距保持原样。但是代码：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello   &quot;</span> World <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></div><p>将解释为三个参数：</p><ol><li>“Hello       “</li><li>World</li><li>“”</li></ol><p>所以输出是</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello    World</span><br></pre></td></tr></table></figure></div><p>请注意，我们完全丢失了引号。这是因为第一个和第二个引号标记了 Hello 和后面的空格;第二个参数是未引用的“世界”，第三个参数是空字符串;””.</p><p>感谢帕特里克指出这一点：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello   &quot;</span>World<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></div><p>实际上只有一个参数（引号参数之间没有空格），您可以通过将 echo 命令替换为（例如）ls 来测试这一点。</p><p>大多数字符（<em>，’等）不是通过将它们放在双引号（“”）中来解释的（即，它们是字面意思）。它们按原样获取并传递给被调用的命令。使用星号 （</em>） 的示例是：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> *</span><br><span class="line">case.shtml escape.shtml first.shtml </span><br><span class="line">functions.shtml hints.shtml index.shtml </span><br><span class="line">ip-primer.txt raid1+0.txt</span><br><span class="line">$ <span class="built_in">echo</span> *txt</span><br><span class="line">ip-primer.txt raid1+0.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">*</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;*txt&quot;</span></span><br><span class="line">*txt</span><br></pre></td></tr></table></figure></div><p>在第一个示例中，* 扩展为表示当前目录中的所有文档。</p><p>在第二个示例中，*txt 表示以 txt 结尾的所有文档。</p><p>在第三个中，我们将 * 放在双引号中，它是按字面解释的。</p><p>在第四个示例中，同样适用，但我们已将 txt 附加到字符串中。</p><p>但是，“、$、’ 和 \ 仍然由 shell 解释，即使它们在双引号中也是如此。</p><p>反斜杠 （\） 字符用于标记这些特殊字符，以便它们不由 shell 解释，而是传递给正在运行的命令（例如，echo）。</p><p>所以输出字符串：（假设$X的值是 5）：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A quote is <span class="string">&quot;, backslash is \, backtick is `.</span></span><br><span class="line"><span class="string">A few spaces are    and dollar is $. <span class="variable">$X</span> is 5.</span></span><br></pre></td></tr></table></figure></div><p>我们必须写：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;A quote is \&quot;, backslash is \\, backtick is \`.&quot;</span></span><br><span class="line">A quote is <span class="string">&quot;, backslash is \, backtick is `.</span></span><br><span class="line"><span class="string">$ echo &quot;</span>A few spaces are    and dollar is \$. \<span class="variable">$X</span> is <span class="variable">$&#123;X&#125;</span>.<span class="string">&quot;</span></span><br><span class="line"><span class="string">A few spaces are    and dollar is $. <span class="variable">$X</span> is 5.</span></span><br></pre></td></tr></table></figure></div><p>我们已经知道 ” 对保存空格的作用, 美元符号 ($)特殊因为他标记变量, 那样 $X 会被shell替换为 变量x的内容. 反斜线()特殊因为他自身用来标记其他特殊字符.  我们需要以下选项来构建完整的 shell：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;This is \\ a backslash&quot;</span></span><br><span class="line">This is \ a backslash</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;This is \&quot; a quote and this is \\ a backslash&quot;</span></span><br><span class="line">This is <span class="string">&quot; a quote and this is \ a backslash</span></span><br></pre></td></tr></table></figure></div><p>因此，必须对反斜杠本身进行转义，以表明它是从字面上理解的。另一个特殊字符，反引号，将在后面的第 12 章 “外部进程”中讨论。</p><h1 id="7-循环-Loops"><a href="#7-循环-Loops" class="headerlink" title="7 循环 Loops"></a>7 循环 Loops</h1><p>大多数语言都有循环的概念：如果我们想重复一个任务二十次，我们不希望输入代码二十次，每次可能都有轻微的变化。</p><p>因此，我们在 Bourne shell 中有 for 和 while 循环。这比其他语言的功能要少一些，但没有人声称 shell 编程具有 C 的强大功能。</p><h2 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h2><p>for 循环循环遍历一组值，直到列表用尽：</p><p>for.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Looping ... number <span class="variable">$i</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div><p>尝试这段代码并观察行为,请注意，这些值可以是任何值：</p><p>for2.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> hello 1 * 2 goodbye </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Looping ... i is set to <span class="variable">$i</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div><p>这是非常值得尝试的。确保您了解这里发生的事情。尝试一下没有*并掌握这个想法.然后重新阅读通配符部分，并在 * 就位的情况下重试。在不同的目录中也尝试一下，用双引号括起来的 *，并尝试在前面 加上反斜杠 （*）</p><p>如果您目前无法访问 shell（在阅读本教程时手头有一个 shell 非常有用）,上面的脚本结果如下:</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Looping .... number 1</span><br><span class="line">Looping .... number 2</span><br><span class="line">Looping .... number 3</span><br><span class="line">Looping .... number 4</span><br><span class="line">Looping .... number 5</span><br></pre></td></tr></table></figure></div><p>第二个例子:</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Looping ... i is <span class="built_in">set</span> to hello</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to 1</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to (name of first file <span class="keyword">in</span> current directory)</span><br><span class="line">    ... etc ...</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to (name of last file <span class="keyword">in</span> current directory)</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to 2</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to goodbye</span><br></pre></td></tr></table></figure></div><p>因此，正如您所看到的，只需循环访问给定的任何输入，直到输入用完为止。</p><h2 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环."></a>While 循环.</h2><p>虽然循环可以更有趣！（取决于你对乐趣的看法，以及你多久走出家门一次……</p><p>while.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">INPUT_STRING=hello</span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$INPUT_STRING</span>&quot;</span> != <span class="string">&quot;bye&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Please type something in (bye to quit)&quot;</span></span><br><span class="line">  <span class="built_in">read</span> INPUT_STRING</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You typed: <span class="variable">$INPU</span></span></span><br><span class="line"><span class="string">_STRING&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div><p>这里发生的情况是，echo 和 read 语句将无限期运行，直到您在出现提示时键入“bye”。</p><p>查看变量 - 第一部分，了解为什幺我们在测试之前设置 INPUT_STRING&#x3D;hello。这使它成为一个重复循环，而不是传统的while循环。</p><p>冒号 （:)始终计算为 true;虽然有时可能需要使用它，但通常最好使用真正的退出条件。将退出上述循环与以下循环进行比较;看看哪个更优雅。还要考虑一些每种情况都比另一种更有用：</p><p>while2.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Please type something in (^C to quit)&quot;</span></span><br><span class="line">  <span class="built_in">read</span> INPUT_STRING</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You typed: <span class="variable">$INPUT_STRING</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div><p>另一个有用的技巧是<code>while read</code>循环。此示例使用 <code>case</code> 语句，我们将在后面介绍该语句。它从文档 myfile.txt 中读取，对于每一行，告诉你它认为正在使用什幺语言。</p><p>（注意：每行必须以 LF（换行符）结尾 - 如果 cat myfile.txt 不以空行结尾，则不会处理最后一行。</p><p>这会将文档“myfile.txt”读取，一次一行，读入变量“$input_text”。然后，case 语句检查 $input_text 的值。如果从myfile中读到的单词是“hello”.txt那幺它输出“English”。如果它是“gday”，那幺它将echo Australian。如果从myfile 独到的行内单词或多个单词没有与提供的任何模版匹配,那么 捕获全部 “*”默认选项会展示信息”Unknown Language: $input_text” - 当然,”$input-text” 是 他从myfile.txt 读到的行内值</p><p>while3.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> input_text</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$input_text</span> <span class="keyword">in</span></span><br><span class="line">        hello)          <span class="built_in">echo</span> English    ;;</span><br><span class="line">        howdy)          <span class="built_in">echo</span> American   ;;</span><br><span class="line">        gday)           <span class="built_in">echo</span> Australian ;;</span><br><span class="line">        bonjour)        <span class="built_in">echo</span> French     ;;</span><br><span class="line">        <span class="string">&quot;guten tag&quot;</span>)    <span class="built_in">echo</span> German     ;;</span><br><span class="line">        *)              <span class="built_in">echo</span> Unknown Language: <span class="variable">$input_text</span></span><br><span class="line">                ;;</span><br><span class="line">   <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span> &lt; myfile.txt</span><br></pre></td></tr></table></figure></div><p>比如我们的 mufile.txt 文件有以下五行:</p><p>这个文件叫 myfile.txt 我们们会把他作为样例输入.</p><p>hello</p><p>gday</p><p>bonjour</p><p>hola</p><p>这个脚本的运行如下:</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./while3.sh</span><br><span class="line">Unknown Language: this file is called myfile.txt and we are using it as an example input.</span><br><span class="line">English</span><br><span class="line">Australian</span><br><span class="line">French</span><br><span class="line">Unknown Language: hola</span><br></pre></td></tr></table></figure></div><p>我最近从Linux From Scratch项目中学到的一个方便的Bash（但不是Bourne Shell）技巧是：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> rc&#123;0,1,2,3,4,5,6,S&#125;.d</span><br></pre></td></tr></table></figure></div><p>而不是更麻烦的：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> runlevel <span class="keyword">in</span> 0 1 2 3 4 5 6 S</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">mkdir</span> rc<span class="variable">$&#123;runlevel&#125;</span>.d</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div><p>这也可以被迭代完成,:</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /</span><br><span class="line">$ <span class="built_in">ls</span> -ld &#123;,usr,usr/local&#125;/&#123;bin,sbin,lib&#125;</span><br><span class="line">drwxr-xr-x    2 root     root         4096 Oct 26 01:00 /bin</span><br><span class="line">drwxr-xr-x    6 root     root         4096 Jan 16 17:09 /lib</span><br><span class="line">drwxr-xr-x    2 root     root         4096 Oct 27 00:02 /sbin</span><br><span class="line">drwxr-xr-x    2 root     root        40960 Jan 16 19:35 usr/bin</span><br><span class="line">drwxr-xr-x   83 root     root        49152 Jan 16 17:23 usr/lib</span><br><span class="line">drwxr-xr-x    2 root     root         4096 Jan 16 22:22 usr/local/bin</span><br><span class="line">drwxr-xr-x    3 root     root         4096 Jan 16 19:17 usr/local/lib</span><br><span class="line">drwxr-xr-x    2 root     root         4096 Dec 28 00:44 usr/local/sbin</span><br><span class="line">drwxr-xr-x    2 root     root         8192 Dec 27 02:10 usr/sbin</span><br></pre></td></tr></table></figure></div><h1 id="8-测试-Test"><a href="#8-测试-Test" class="headerlink" title="8 测试 Test"></a>8 测试 Test</h1><p>几乎所有脚本都会写测试. 看起来可能不是这样，因为测试通常不直接调用。测试更常称为 [.   [ 是要测试的符号链接，只是为了让 shell 进程更具可读性。它通常也是一个内置的shell（这意味着shell本身解释 [ 为 Test，即使你的Unix环境设置不同）：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> [</span><br><span class="line">[ is a shell <span class="built_in">builtin</span></span><br><span class="line">$ <span class="built_in">which</span> [</span><br><span class="line">/usr/bin/[</span><br><span class="line">$ <span class="built_in">ls</span> -l /usr/bin/[</span><br><span class="line">lrwxrwxrwx 1 root root 4 Mar 27 2000 /usr/bin/[ -&gt; <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">ls</span> -l /usr/bin/test</span><br><span class="line">-rwxr-xr-x 1 root root 35368 Mar 27  2000 /usr/bin/test</span><br></pre></td></tr></table></figure></div><p>这意味着 ‘[‘ 实际上是一个进程，就像 ls 和其他进程一样，所以它必须被空格包围：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [<span class="variable">$foo</span> = <span class="string">&quot;bar&quot;</span> ]</span><br></pre></td></tr></table></figure></div><p>不会运行.他会被解释为 <code>if text&amp;foo = “bar” ]</code>, 也就是没有’[’ 的’]’.  确保在所有操作符周围都留有空格.</p><p>我用“SPACE”一词突出显示了强制性空格 - 将“SPACE”替换为实际空格;如果那里没有空间，它将不起作用：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> SPACE [ SPACE <span class="string">&quot;<span class="variable">$foo</span>&quot;</span> SPACE = SPACE <span class="string">&quot;bar&quot;</span> SPACE ]</span><br></pre></td></tr></table></figure></div><p>注意一些 shell 也接受 “&#x3D;&#x3D;” 进行字符串比较;这不是可移植的，字符串应使用单个“&#x3D;”，整数应使用“-eq”。</p><p>测试是一个简单但功能强大的比较实用进程。有关完整的详细信息，请在您的系统上运行 man test，但这里有一些用法和典型示例。</p><p>测试最常通过 if 和 while 语句间接调用。这也是如果您创建一个名为 test 的进程并尝试运行它，您会遇到困难的原因，因为将调用此内置 shell 而不是您的进程！</p><p><code>if…then…else…</code> 的语法是:</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ... ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="comment"># if-code</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># else-code</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div><p>请注意，fi 是 if 倒过来！稍后在 case 和 esac 中再次使用。另外，请注意语法 - “<code>if [ ... ]</code>”和“<code>then</code>”命令必须位于不同的行上。或者，分号 “;” 可以分隔它们：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ... ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div><p>你也可以用<code>elif</code> ,像这样</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  [ something ]; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Something&quot;</span></span><br><span class="line"> <span class="keyword">elif</span> [ something_else ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Something else&quot;</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;None of the above&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div><p>如果 <code>[ something]</code> 成功的话, 会用echo 输出”Something”  否则他会测试 <code>[ something_else]</code>, .如果这个成功,  <code>echo “Something else ”</code> .如果其他都失败, 会 <code>echo “None of the ablove”</code> .</p><p>尝试以下代码片段，在运行之前，将变量 X 设置为各种值（try -1、0、1、hello、bye, etc）。您可以按如下方式执行此操作（感谢 Dave 指出需要导出变量(export)，如变量 - 第 I 部分中所述）：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ X=5</span><br><span class="line">$ <span class="built_in">export</span> X</span><br><span class="line">$ ./test.sh</span><br><span class="line">  ... output of test.sh ...</span><br><span class="line">$ X=hello</span><br><span class="line">$ ./test.sh</span><br><span class="line">  ... output of test.sh ...</span><br><span class="line">$ X=test.sh</span><br><span class="line">$ ./test.sh</span><br><span class="line">  ... output of test.sh ...</span><br></pre></td></tr></table></figure></div><p>然后重试，使用 $X 作为现有文档的名称，例如 &#x2F;etc&#x2F;hosts。</p><p>text.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -lt <span class="string">&quot;0&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;X is less than zero&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -gt <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;X is more than zero&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -le <span class="string">&quot;0&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is less than or equal to  zero&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -ge <span class="string">&quot;0&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is more than or equal to zero&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> = <span class="string">&quot;0&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is the string or number \&quot;0\&quot;&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> = <span class="string">&quot;hello&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X matches the string \&quot;hello\&quot;&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> != <span class="string">&quot;hello&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is not the string \&quot;hello\&quot;&quot;</span></span><br><span class="line">[ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is of nonzero length&quot;</span></span><br><span class="line">[ -f <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is the path of a real file&quot;</span> || \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;No such file: <span class="variable">$X</span>&quot;</span></span><br><span class="line">[ -x <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is the path of an executable file&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -nt <span class="string">&quot;/etc/passwd&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is a file which is newer than /etc/passwd&quot;</span></span><br></pre></td></tr></table></figure></div><p>请注意，我们可以使用分号 （<code>;</code>) 将两行连接在一起。这样做通常是为了在简单的 <code>if</code> 语句中节省一点空间。</p><p>反斜杠 （<code>\</code>） 有一个类似但相反的目的：它告诉 shell 这不是行的末尾，但应将下一行视为当前行的一部分。这对于可读性很有用。通常将下一行缩进到反斜杠 （<code>\</code>） 或分号 （<code>;</code>) 之后。</p><p>例如，分号 （;)经常像这样用来连接 if 和 then 关键字：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -nt <span class="string">&quot;/etc/passwd&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is a file which is newer than /etc/passwd&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div><p>虽然反斜杠 （\） 用于在 shell 脚本文档中将单行命令拆分为两行，但出于可读性目的：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -nt <span class="string">&quot;/etc/passwd&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is a file which is newer than /etc/passwd&quot;</span></span><br></pre></td></tr></table></figure></div><p>正如我们从这些示例中看到的，<code>test</code> 可以对数字、字符串和文档名执行许多测试。</p><p><code>a，-e</code>（都表示“文档存在”），<code>-S</code>（文档是套接字），<code>-nt</code>（文档更新于），<code>-ot</code>（文档早于），<code>-ef</code>（路径引用同一文档）和<code>-O</code>（文档归运行测试的用户所有）</p><p>有一种更简单的 <code>if</code> 语句编写方法：<code>&amp;&amp;</code> 和 <code>||</code>命令分别提供在结果为 true 或 false 时运行的代码。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">[ <span class="variable">$X</span> -ne 0 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;X isn&#x27;t zero&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;X is zero&quot;</span></span><br><span class="line">[ -f <span class="variable">$X</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;X is a file&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;X is not a file&quot;</span></span><br><span class="line">[ -n <span class="variable">$X</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;X is of non-zero length&quot;</span> || \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is of zero length&quot;</span></span><br></pre></td></tr></table></figure></div><p>这种语法是可行，是因为有一个名为 <code>[</code> 的文档（或 shell 内置）链接到<code>test</code>。</p><p>但是，请谨慎使用此构造，因为过度使用可能会导致代码非常难以阅读。</p><p>if…then…else… 结构更可读. 建议使用 <code>[...]</code> 结构用于 while 循环和您不想过度分散读者的注意力的琐碎的健全性检查</p><p>请注意，当您将 X 设置为非数值时，前几次比较会产生以下消息：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test.sh: [: <span class="built_in">integer</span> expression expected before -lt</span><br><span class="line">test.sh: [: <span class="built_in">integer</span> expression expected before -gt</span><br><span class="line">test.sh: [: <span class="built_in">integer</span> expression expected before -le</span><br><span class="line">test.sh: [: <span class="built_in">integer</span> expression expected before -ge</span><br></pre></td></tr></table></figure></div><p>这是因为 -lt、-gt、-le 和 -ge 比较仅适用于整数，不适用于字符串。字符串比较，例如 ！&#x3D; 会很乐意将 “5” 视为字符串，但没有明智的方法将 “Hello” 视为整数，因此整数比较会抱怨。</p><p>如果您希望 shell 脚本的行为更优雅，则必须在测试变量之前检查变量的内容 - 可能是这样的：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;Please guess the magic number: &quot;</span></span><br><span class="line"><span class="built_in">read</span> X</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$X</span> | grep <span class="string">&quot;[^0-9]&quot;</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># If the grep found something other than 0-9</span></span><br><span class="line">  <span class="comment"># then it&#x27;s not an integer.</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Sorry, wanted a number&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># The grep found only 0-9, so it&#x27;s an integer. </span></span><br><span class="line">  <span class="comment"># We can safely do a test on it.</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -eq <span class="string">&quot;7&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;You entered the magic number!&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div><p>通过这种方式，您可以向用户回显更有意义的消息，并优雅地退出。</p><p><code>$？</code>变量在变量 - 第二部分中进行了解释，而grep是一头复杂的野兽，所以这里是：<code>grep [0-9]</code> 查找包含数字 （0-9） 和可能的其他字符的文本行，因此 <code>grep [^0-9]</code> 中的插入符号 （<code>^</code>） 仅查找那些不仅由数字组成的行。然后我们可以采取相反的做法（通过失败而不是成功采取行动）。好吗？<code>&gt;/dev/null 2&gt;&amp;1</code> 将任何输出或错误定向到特殊的“null”设备，而不是转到用户的屏幕。非常感谢 Paul Schermerhorn 纠正我 - 这个页面曾经声称 <code>grep -v [0-9]</code> 会起作用，但这显然太简单了。</p><p>我们可以在 while 循环中使用测试，如下所示：</p><p>stes2.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">X=0</span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Enter some text (RETURN to quit)&quot;</span></span><br><span class="line">  <span class="built_in">read</span> X</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You said: <span class="variable">$X</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div><p>此代码将继续要求输入，直到您点击 RETURN（X 为零长度）。感谢贾斯汀·希思指出script不起作用 - 我漏了$X周围的引号<code>while[ -n “$X” ]</code>。没有这些引号，当$X为空时，没有什幺可以测试的。</p><p>亚历山大·韦伯指出，运行这个脚本会以凌乱的方式结束：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./test2.sh</span><br><span class="line">Enter some text (RETURN to quit)</span><br><span class="line">fred</span><br><span class="line">You said: fred</span><br><span class="line">Enter some text (RETURN to quit)</span><br><span class="line">wilma</span><br><span class="line">You said: wilma</span><br><span class="line">Enter some text (RETURN to quit)</span><br><span class="line"></span><br><span class="line">You said:</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div><p>这可以通过循环中的另一个测试来整理：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">X=0</span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Enter some text (RETURN to quit)&quot;</span></span><br><span class="line">  <span class="built_in">read</span> X</span><br><span class="line">  <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;You said: <span class="variable">$X</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div><p>另请注意，我在此页面上对 if 语句使用了两种不同的语法。这些是：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -lt <span class="string">&quot;0&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;X is less than zero&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">..........  and  ........</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You said: <span class="variable">$X</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div><p>必须在 if 语句和 then 构造之间有一个中断。这可以是分号或换行符，哪个都没关系，但是 if 和 then 之间必须有一个或另一个。最好只说：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You said: <span class="variable">$X</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p>但是<code>then</code>和<code>fi</code>是绝对需要的。</p><h1 id="9-Case"><a href="#9-Case" class="headerlink" title="9. Case"></a>9. Case</h1><p><code>case</code> 语句省去了通过一整套 <code>if…then…else</code>声明。它的语法非常简单：</p><p>talk.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Please talk to me ...&quot;</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">read</span> INPUT_STRING</span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$INPUT_STRING</span> <span class="keyword">in</span></span><br><span class="line">hello)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello yourself!&quot;</span></span><br><span class="line">;;</span><br><span class="line"><span class="built_in">bye</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;See you again!&quot;</span></span><br><span class="line"><span class="built_in">break</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Sorry, I don&#x27;t understand&quot;</span></span><br><span class="line">;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;That&#x27;s all folks!&quot;</span></span><br></pre></td></tr></table></figure></div><p>好吧，所以它不是世界上最好的健谈者;这只是一个例子！</p><p>尝试运行它并检查它是如何工作的…</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./talk.sh</span><br><span class="line">Please talk to me ...</span><br><span class="line">hello</span><br><span class="line">Hello yourself!</span><br><span class="line">What <span class="keyword">do</span> you think of politics?</span><br><span class="line">Sorry, I don<span class="string">&#x27;t understand</span></span><br><span class="line"><span class="string">bye</span></span><br><span class="line"><span class="string">See you again!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">That&#x27;</span>s all folks!</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div><p>语法非常简单, <code>case</code> 行本身格式不变, 他的意思是我们在测试变量 <code>INPUT_STRING</code>的值.</p><p>然后列出我们理解的选项，后跟右括号，如<code>hello）</code>和<code>bye）</code>。</p><p>这意味着，如果<code>INPUT_STRING</code>匹配 <code>hello</code>，则执行该段代码，直到双分号。</p><p>如果<code>INPUT_STRING</code>匹配<code>bye</code>，则打印再见消息并退出循环。请注意，如果我们想完全退出脚本，那幺我们将使用命令 <code>exit</code> 而不是 <code>break</code>。</p><p>这里的第三个选项，<code>*）</code>，是默认的捕获全部条件;它不是必需的，但通常对于调试目的很有用，即使我们认为我们知道测试变量将具有什幺值。</p><p>整个 <code>case</code> 语句以 <code>esac</code> 结尾（大小写倒置！），然后我们以 <code>done</code> 结束 <code>while</code> 循环。</p><p>这和<code>case</code> 条件一样复杂，但它们可能是一个非常有用和强大的工具。</p><p>它们通常用于解析传递给 shell 脚本的参数以及其他用途。</p><h1 id="10-变量-Part-ii"><a href="#10-变量-Part-ii" class="headerlink" title="10.变量 -Part ii"></a>10.变量 -Part ii</h1><p>已经为您设置了一组变量，其中大多数变量不能为其赋值。</p><p>这些可以包含有用的信息，脚本可以使用这些信息来了解它正在运行的环境。</p><p>我们将要看的第一组变量是 <code>$0 ..$9</code> 和 <code>$#</code>。</p><p>变量 <code>$0</code> 是进程的基本名称。(basename).<code>$1 ..$9</code> 是调用脚本时使用的前 9 个附加参数。变量 <code>$@</code> 是所有参数 <code>$1 ..whatever</code>。变量 <code>$*</code> 类似，但不保留任何空格和引号，因此“File with spaces”变为“File”与“”spaces”。 这和我们在 第一个脚本 中看到的<code>echo</code>很像. 作为一般规则，请使用 <code>$@</code> 并避免使用 <code>$*</code>。<code>$#</code> 是调用脚本时使用的参数数。</p><p>让我们举一个示例脚本：</p><p>var3.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I was called with <span class="variable">$#</span> parameters&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My name is <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My first parameter is <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My second parameter is <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All parameters are <span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p>让我们看看运行此代码并查看输出：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ /home/steve/var3.sh</span><br><span class="line">I was called with 0 parameters</span><br><span class="line">My name is /home/steve/var3.sh</span><br><span class="line">My first parameter is</span><br><span class="line">My second parameter is    </span><br><span class="line">All parameters are </span><br><span class="line">$</span><br><span class="line">$ ./var3.sh hello world earth</span><br><span class="line">I was called with 3 parameters</span><br><span class="line">My name is ./var3.sh</span><br><span class="line">My first parameter is hello</span><br><span class="line">My second parameter is world</span><br><span class="line">All parameters are hello world earth</span><br></pre></td></tr></table></figure></div><p>请注意，<code>$0</code> 的值会根据脚本的调用方式而变化。外部实用进程<code>basename</code>可以帮助整理此问题：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My name is `basename <span class="variable">$0</span>`&quot;</span></span><br></pre></td></tr></table></figure></div><p><code>$#</code> 和 <code>$1 ..$9</code> 由shell自动设置。我们可以使用 <code>shift</code> 命令获取 9 个以上的参数;请看下面的脚本：</p><p>var4.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -gt <span class="string">&quot;0&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$1 is <span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div><p>此脚本一直使用 <code>shift</code>，直到 <code>$#</code> 降至零，直到列表为空。</p><p>另一个特殊变量是 <code>$？</code>。这包含上次运行命令的退出值。所以代码：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/usr/local/bin/my-command</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -ne <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Sorry, we had a problem there!&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div><p>将尝试运行 <code>/usr/local/bin/my-command</code>，如果一切顺利，该命令应以零值退出，或在失败时以非零值退出。调用命令后,我们可以通过检查 <code>$？</code>的值来处理返回.这有助于使脚本健壮且更智能。</p><p>运行良好的应用进程在成功时应返回零。因此引用：</p><blockquote><p>罗马帝国灭亡的主要原因之一是，由于缺乏零，他们无法表明他们的C计划成功终止。（罗伯特·弗斯）</p></blockquote><p>环境为您设置的另外两个主要变量是 <code>$$</code> 和 <code>$！</code>。这两个都是进程编号。</p><p><code>$$</code> 变量是当前运行的 shell 的 PID（进程标识符）。这对于创建临时文档很有用，例如 <code>/tmp/my-script.$$</code>，如果脚本的许多实例可以同时运行，并且它们都需要自己的临时文档，这将非常有用。</p><p><code>$！</code>变量是上次运行后台进程的 PID。这对于跟踪流程进行工作非常有用。</p><p>另一个有趣的变量是<code>IFS</code>。这是内部字段分隔符。默认值为空格制表符换行符 <code>SPACE TAB NEWLINE</code>，但如果要更改它，则更容易复制，如下所示：</p><p>var5.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">old_IFS=<span class="string">&quot;<span class="variable">$IFS</span>&quot;</span></span><br><span class="line">IFS=:</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Please input some data separated by colons ...&quot;</span></span><br><span class="line"><span class="built_in">read</span> x y z</span><br><span class="line">IFS=<span class="variable">$old_IFS</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x is <span class="variable">$x</span> y is <span class="variable">$y</span> z is <span class="variable">$z</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p>此脚本运行如下：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./ifs.sh</span><br><span class="line">Please input some data separated by colons ...</span><br><span class="line">hello:how are you:today</span><br><span class="line">x is hello y is how are you z is today</span><br></pre></td></tr></table></figure></div><p>在处理 IFS（但任何不完全由您控制的变量）时，重要的是要意识到它可能包含空格、换行符和其他“不可控”字符。因此，最好在它周围使用双引号，即：<code>old_IFS=“$IFS”</code>而不是<code>old_IFS=$IFS</code>。</p><h1 id="11-变量-Part-III"><a href="#11-变量-Part-III" class="headerlink" title="11.变量 - Part III"></a>11.变量 - Part III</h1><p>正如我们在变量 - 第一部分中提到的，变量周围的大括号可避免混淆：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo=sun</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$fooshine</span>     <span class="comment"># $fooshine is undefined</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo&#125;</span>shine   <span class="comment"># displays the word &quot;sunshine&quot;</span></span><br></pre></td></tr></table></figure></div><p>不过，这还不是全部 - 这些花括号还有另一个更强大的用途。我们可以处理变量未定义或为空的问题（在外壳中，未定义和 null 之间没有太大区别）。</p><p>使用默认值</p><p>请考虑以下代码片段，该代码片段提示用户输入，但接受默认值：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;What is your name [ `whoami` ] &quot;</span></span><br><span class="line"><span class="built_in">read</span> myname</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$myname</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  myname=`<span class="built_in">whoami</span>`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is : <span class="variable">$myname</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p>将“<code>-en</code>”传递给 <code>echo</code> 告诉它不要添加换行符（对于 bash 和 csh）。对于 Dash、Bourne 和其他兼容的 shell，您可以在行尾使用“\c”。Ksh理解这两种形式。（注意：参见 &#x2F;echo.html 了解不同实现的说明 - 特别是 Dash&#x2F;Bourne vs Bash）</p><p>如果您通过按“RETURN”接受默认值，此脚本将像这样运行：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">steve$ ./name.sh</span><br><span class="line">What is your name [ steve ]</span><br><span class="line">Your name is : steve</span><br></pre></td></tr></table></figure></div><p>…或者，使用用户输入：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">steve$ ./name.sh</span><br><span class="line">What is your name [ steve ] foo</span><br><span class="line">Your name is : foo</span><br></pre></td></tr></table></figure></div><p>使用 shell 变量功能可以更好地完成此操作。通过使用大括号和特殊的“：-”用法，您可以指定在变量未设置时使用的默认值：</p><aside>💡 `注意这是反引号  `   不是单引号 ‘`</aside><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;What is your name [ `whoami` ] &quot;</span></span><br><span class="line"><span class="built_in">read</span> myname</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is : <span class="variable">$&#123;myname:-`whoami`&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p>这可以被视为一种特殊情况 - 我们使用 whoami 命令的输出，该命令打印您的登录名 （UID）。更规范的示例是使用固定文本，如下所示：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is : <span class="variable">$&#123;myname:-John Doe&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p>与反引号的其他用法一样，“<code>whoami</code>”在子 shell 中运行，因此在反引号内的任何 cd 命令或设置任何其他变量都不会影响当前运行的 shell。</p><p>使用和设置默认值</p><p>还有另一种语法“：&#x3D;”，如果未定义，它将变量设置为默认值：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is : <span class="variable">$&#123;myname:=John Doe&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p>这种技术意味着任何后续对<code>$myname</code>变量的访问将始终获得一个值，要幺由用户输入，要幺由“John Doe”输入。</p><h1 id="12-外部程序"><a href="#12-外部程序" class="headerlink" title="12. 外部程序"></a>12. 外部程序</h1><p>外部进程通常在 shell 脚本中使用;有一些内置命令（<code>echo</code>，其中和<code>test</code>通常是内置的），但许多有用的命令实际上是Unix实用进程，如<code>tr</code>，<code>grep</code>，<code>expr</code>和<code>cut</code>。</p><p>反引号 （<code>&#39;</code>） 也经常与外部命令相关联。因此，我们将首先讨论反引号。</p><p>反引号用于指示将随附的文本作为命令执行。这很容易理解。首先，使用交互式 shell 从 <code>/etc/passwd</code> 读取您的全名：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep <span class="string">&quot;^<span class="variable">$&#123;USER&#125;</span>:&quot;</span> /etc/passwd | <span class="built_in">cut</span> -d: -f5</span><br><span class="line">Steve Parker</span><br></pre></td></tr></table></figure></div><p>现在我们将这个输出抓取到一个变量中，我们可以更轻松地操作该变量：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ MYNAME=`grep <span class="string">&quot;^<span class="variable">$&#123;USER&#125;</span>:&quot;</span> /etc/passwd | <span class="built_in">cut</span> -d: -f5`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYNAME</span></span><br><span class="line">Steve Parker</span><br></pre></td></tr></table></figure></div><aside>❓ ^ caret 符号什么作用?</aside><p><a class="link"   href="https://stackoverflow.com/questions/20342828/what-does-symbol-mean-in-batch-script" >What does symbol ^ mean in Batch script? <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b7822b97-9aaa-4532-aa09-aaa3f31f88d5/Untitled.png"                      alt="Untitled"                ></p><p>因此，我们看到反引号只是从我们选择运行的任何命令或一组命令中捕获标准输出。如果要运行慢速命令或命令集并解析其输出的各个位，它还可以提高性能：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">find / -name <span class="string">&quot;*.html&quot;</span> -<span class="built_in">print</span> | grep <span class="string">&quot;/index.html$&quot;</span></span><br><span class="line">find / -name <span class="string">&quot;*.html&quot;</span> -<span class="built_in">print</span> | grep <span class="string">&quot;/contents.html$&quot;</span></span><br></pre></td></tr></table></figure></div><p>这段代码可能需要很长时间才能运行，我们正在执行两次！ 更好的解决方案是：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">HTML_FILES=`find / -name <span class="string">&quot;*.html&quot;</span> -<span class="built_in">print</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$HTML_FILES</span>&quot;</span> | grep <span class="string">&quot;/index.html$&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$HTML_FILES</span>&quot;</span> | grep <span class="string">&quot;/contents.html$&quot;</span></span><br></pre></td></tr></table></figure></div><p>注意：<code>$HTML_FILES</code> 两边的引号对于保留列出的每个文档之间的换行符至关重要。否则，<code>grep</code> 将看到一大行长文本，而不是每个文档一行。</p><p>这样，我们只运行一次慢速查找，大约将脚本的执行时间减半。</p><p>我们将在本教程的提示和技巧部分中进一步讨论具体示例。</p><h1 id="13-函数"><a href="#13-函数" class="headerlink" title="13. 函数"></a>13. 函数</h1><p>Bourne shell 脚本编程的一个经常被忽视的特性是，您可以轻松地编写函数以在脚本中使用。这通常通过以下两种方式之一完成;使用简单的脚本，该函数只是在调用它的同一文档中声明。</p><p>但是，在编写一套脚本时，编写有用函数的“库”通常更容易，并在使用这些函数的其他脚本的开头获取该文档。这个一会讲.</p><p>方法是一样的，但是它完成了;我们将在这里主要使用第一种方法。第二种（库）方法基本相同，只是命令</p><p><code>. ./library.sh</code></p><p>在脚本的开头。</p><p>对于是调用 shell 函数过程还是函数(<em>functions procedures or functions</em>)，可能会有一些混淆;传统上，函数的定义是它返回单个值，并且不输出任何内容。另一方面，过程不返回值，但可能会产生输出。shell 函数可以不执行任何操作，也可以执行其中之一或两者兼而有之。人们普遍认为，在 shell 脚本中，它们被称为函数。</p><p>函数可以通过以下四种不同方式之一返回值：</p><ul><li>更改一个或多个变量的状态</li><li>使用 exit 命令结束 shell 脚本</li><li>使用 return 命令结束函数，并将提供的值返回到 shell 脚本的调用部分</li><li>echo 输出到 stdout，输出会被捕获就像 <code>c=&#39;expr $a + $b&#39;</code></li></ul><p>这很像 C，因为<code>exit</code>停止进程，<code>return</code>将控制权返回给调用方。</p><p>不同之处在于 shell 函数不能更改其参数，尽管它可以更改全局参数。</p><p>使用函数的简单脚本如下所示：</p><p>function.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># A simple script with a function...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">add_a_user</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  USER=<span class="variable">$1</span></span><br><span class="line">  PASSWORD=<span class="variable">$2</span></span><br><span class="line">  <span class="built_in">shift</span>; <span class="built_in">shift</span>;</span><br><span class="line">  <span class="comment"># Having shifted twice, the rest is now comments ...</span></span><br><span class="line">  COMMENTS=<span class="variable">$@</span>      <span class="comment"># $@是所有变量</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Adding user <span class="variable">$USER</span> ...&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> useradd -c <span class="string">&quot;<span class="variable">$COMMENTS</span>&quot;</span> <span class="variable">$USER</span></span><br><span class="line">  <span class="built_in">echo</span> passwd <span class="variable">$USER</span> <span class="variable">$PASSWORD</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Added user <span class="variable">$USER</span> (<span class="variable">$COMMENTS</span>) with pass <span class="variable">$PASSWORD</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># Main body of script starts here</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Start of script...&quot;</span></span><br><span class="line">add_a_user bob letmein Bob Holness the presenter</span><br><span class="line">add_a_user fred badpassword Fred Durst the singer</span><br><span class="line">add_a_user bilko worsepassword Sgt. Bilko the role model</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;End of script...&quot;</span></span><br></pre></td></tr></table></figure></div><p>shift作用:</p><p><a href="https://www.notion.so/shift-12b68ed49b624ef6a59a25a25b011f97">此脚本一直使用 <code>shift</code>，直到 <code>$#</code> 降至零，直到列表为空。</a> </p><p>第 4 行以 （） 结尾将自身标识为函数声明。这后面跟着 {，匹配 } 后面的所有内容都被视为该函数的代码。</p><p>在调用函数之前，不会执行此代码。函数被读入，但在实际调用它们之前基本上被忽略。</p><p>请注意，对于此示例，useradd 和 passwd 命令以 echo 为前缀 - 这是一种有用的调试技术，用于检查是否会执行正确的命令。这也意味着您可以运行脚本，而无需成为 root 用户或向系统添加狡猾的用户帐户！</p><p>我们已经习惯了 shell 脚本按顺序执行的想法。函数并非如此。</p><p>在这种情况下，函数<code>add_a_user</code>被读入并检查语法，但在显式调用之前不会执行。这就是 2014 年 Shellshock 错误发挥作用的地方。</p><p>函数定义后的其他命令被执行，即使它们不是函数本身的一部分。有关此内容的更多信息，请参阅 <a class="link"   href="http://steve-parker.org/articles/shellshock/%E3%80%82" >http://steve-parker.org/articles/shellshock/。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>执行从 <code>echo</code> 语句“脚本开始…”开始。下一行，<code>add_a_user bob letmein Bob Holness</code> 被识别为函数调用，因此进入 <code>add_a_user</code> 函数并开始执行，并向环境添加某些内容：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$1</span>=bob</span><br><span class="line"><span class="variable">$2</span>=letmein</span><br><span class="line"><span class="variable">$3</span>=Bob</span><br><span class="line"><span class="variable">$4</span>=Holness</span><br><span class="line"><span class="variable">$5</span>=the</span><br><span class="line"><span class="variable">$6</span>=presenter</span><br></pre></td></tr></table></figure></div><p>因此，在该函数中，<code>$1</code> 设置为 <code>bob</code>，而不管函数外部的 <code>$1</code> 可能设置为什幺。</p><p>因此，如果我们想在函数中引用“original”$1，我们必须为它分配一个名称 - 例如：<code>A=$1</code> 在我们调用函数之前。然后，在函数中，我们可以引用<code>$A</code>。</p><p>我们再次使用 <code>shift</code> 命令将 <code>$3</code> 及以后的参数转换为 <code>$@</code>。</p><p>然后，该函数添加用户并设置其密码。它<code>echo</code>es该效果的注释，并将控制权返回到主代码的下一行。</p><h2 id="变量的范围-1"><a href="#变量的范围-1" class="headerlink" title="变量的范围"></a>变量的范围</h2><p>习惯于其他语言的进程员可能会对 shell 函数的作用域规则感到惊讶。基本上，除了参数（<code>$ 1</code>、<code>$2</code>、<code>$@</code>等）之外，没有范围。</p><p>采用以下简单代码段：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">myfunc</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;I was called as : <span class="variable">$@</span>&quot;</span></span><br><span class="line">  x=2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### Main script starts here </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Script was called with <span class="variable">$@</span>&quot;</span></span><br><span class="line">x=1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x is <span class="variable">$x</span>&quot;</span></span><br><span class="line">myfunc 1 2 3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x is <span class="variable">$x</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p>当调用脚本时，当 用[<code>scope.sh](http://scope.sh/) a b c</code> 调用时，会给出以下输出：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Script was called with a b c</span><br><span class="line">x is 1</span><br><span class="line">I was called as : 1 2 3</span><br><span class="line">x is 2</span><br></pre></td></tr></table></figure></div><p><code>$@</code> 参数在函数中更改，以反映函数的调用方式。然而，变量 <code>x</code> 实际上是一个全局变量 - <code>myfunc</code> 更改了它，当控制返回到主脚本时，该更改仍然有效。</p><p>如果函数的输出通过管道传输到其他地方，则会在子 shell 中调用该函数 - 即“<code>myfunc 1 2 3 |tee out.log</code>“第二次仍然会说”x is 1”。</p><p>这是因为调用了一个新的 shell 进程来从管道运行 <code>myfunc（）</code>。这会使调试非常令人沮丧;阿斯特丽德有一个脚本突然失败了，</p><p>当“<code>| tee</code>“被添加，并且为什幺必须这样做并不明显。<code>tee</code>必须在管道左侧的功能之前启动;用简单的例子 “<code>ls | grep foo</code>”, <code>grep</code> 必须先启动, 一旦 <code>LS</code> 启动，其标准输入就会绑定到 <code>LS</code> 的标准输出。在 shell 脚本中，在我们知道要通过管道传输 <code>tee</code> 之前，shell 已经启动了，所以操作系统必须启动 <code>tee</code>，然后启动一个新的 shell 来调用 <code>myfunc（）</code>。这令人沮丧，但非常值得注意。</p><p>函数也不能更改调用它们的值 - 这必须通过更改变量本身来完成，而不是通过传递给脚本的参数来完成。</p><p>一个例子更清楚地说明了这一点：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">myfunc</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$1 is <span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$2 is <span class="variable">$2</span>&quot;</span></span><br><span class="line">  <span class="comment"># cannot change $1 - we&#x27;d have to say:</span></span><br><span class="line">  <span class="comment"># 1=&quot;Goodbye Cruel&quot;</span></span><br><span class="line">  <span class="comment"># which is not a valid syntax. However, we can</span></span><br><span class="line">  <span class="comment"># change $a:</span></span><br><span class="line">  a=<span class="string">&quot;Goodbye Cruel&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### Main script starts here </span></span><br><span class="line"></span><br><span class="line">a=Hello</span><br><span class="line">b=World</span><br><span class="line">myfunc <span class="variable">$a</span> <span class="variable">$b</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;a is <span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;b is <span class="variable">$b</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p>这个相当愤世嫉俗的功能改变了$a，所以消息“你好世界”变成了“再见残酷的世界”。</p><h2 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归 Recursion"></a>递归 Recursion</h2><p>函数可以是递归的 - 下面是阶乘函数的简单示例：</p><p>factorial.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">factorial</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> -gt <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    i=`<span class="built_in">expr</span> <span class="variable">$1</span> - 1`</span><br><span class="line">    j=`factorial <span class="variable">$i</span>`</span><br><span class="line">    k=`<span class="built_in">expr</span> <span class="variable">$1</span> \* <span class="variable">$j</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$k</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Enter a number:&quot;</span></span><br><span class="line">  <span class="built_in">read</span> x</span><br><span class="line">  factorial <span class="variable">$x</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div><p>正如所承诺的，我们现在将简要讨论在 shell 脚本之间使用库。这些也可以用来定义公共变量，正如我们将看到的。</p><p>common.lib</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.lib</span></span><br><span class="line"><span class="comment"># Note no #!/bin/sh as this should not spawn </span></span><br><span class="line"><span class="comment"># an extra shell. It&#x27;s not the end of the world </span></span><br><span class="line"><span class="comment"># to have one, but clearer not to.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">STD_MSG=<span class="string">&quot;About to rename some files...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rename</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment"># expects to be called as: rename .txt .bak </span></span><br><span class="line">  FROM=<span class="variable">$1</span></span><br><span class="line">  TO=<span class="variable">$2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> *<span class="variable">$FROM</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    j=`<span class="built_in">basename</span> <span class="variable">$i</span> <span class="variable">$FROM</span>`</span><br><span class="line">    <span class="built_in">mv</span> <span class="variable">$i</span> <span class="variable">$&#123;j&#125;</span><span class="variable">$TO</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>function2.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># function2.sh</span></span><br><span class="line">. ./common.lib</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$STD_MSG</span></span><br><span class="line">rename .txt .bak</span><br></pre></td></tr></table></figure></div><p>function3.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># function3.sh</span></span><br><span class="line">. ./common.lib</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$STD_MSG</span></span><br><span class="line">rename .html .html-bak</span><br></pre></td></tr></table></figure></div><p>在这里，我们看到两个用户 shell 脚本，<a href="http://function2.sh/"><code>function2.sh</code></a> 和 <a href="http://function3.sh/"><code>function3.sh</code></a>，每个脚本都源自公共库文档 <code>common.lib</code>，并使用该文档中声明的变量和函数。</p><p>这没什幺惊天动地的，只是如何在 shell 编程中完成代码重用的一个例子。</p><h2 id="返回代码-Return-Codes"><a href="#返回代码-Return-Codes" class="headerlink" title="返回代码 Return Codes"></a>返回代码 Return Codes</h2><p>有关退出代码的详细信息，请参阅教程的Hints and Tips部分的退出代码部分。现d在，尽管我们将简要地看一下<code>return</code> 调用。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">adduser</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  USER=<span class="variable">$1</span></span><br><span class="line">  PASSWORD=<span class="variable">$2</span></span><br><span class="line">  <span class="built_in">shift</span> ; <span class="built_in">shift</span></span><br><span class="line">  COMMENTS=<span class="variable">$@</span></span><br><span class="line">  useradd -c <span class="string">&quot;<span class="variable">$&#123;COMMENTS&#125;</span>&quot;</span> <span class="variable">$USER</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -ne <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span>   <span class="comment"># $? 是上次运行命令的退出值</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Useradd failed&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  passwd <span class="variable">$USER</span> <span class="variable">$PASSWORD</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -ne <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Setting password failed&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 2</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Added user <span class="variable">$USER</span> (<span class="variable">$COMMENTS</span>) with pass <span class="variable">$PASSWORD</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Main script starts here</span></span><br><span class="line"></span><br><span class="line">adduser bob letmein Bob Holness from Blockbusters</span><br><span class="line">ADDUSER_RETURN_CODE=$?</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ADDUSER_RETURN_CODE</span>&quot;</span> -eq <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Something went wrong with useradd&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$ADDUSER_RETURN_CODE</span>&quot;</span> -eq <span class="string">&quot;2&quot;</span> ]; <span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Something went wrong with passwd&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Bob Holness added to the system.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div><p>此脚本检查它发出的两个外部调用（<code>useradd</code> 和 <code>passwd</code>），并让用户知道它们是否失败。然后，该函数定义一个返回代码 1 以指示 useradd 的任何问题，并定义 2 以指示 passwd 的任何问题。这样，调用脚本就知道问题出在哪里。</p><p>很长一段时间，本教程都检查两次“<code>$？</code>”，而不是设置 <code>ADDUSER_RETURN_CODE=$？</code>，然后每次都查看 <code>ADDUSER_RETURN_CODE</code> 的值。这是一个错误（感谢Elyza指出它）。您必须保存 <code>$？</code>，因为一旦运行另一个命令（例如 if），其值就会被替换。这就是为什幺我们将 <code>adduser</code> 返回值保存在 <code>$ADDUSER_RETURN_CODE</code> 变量中，然后再对其内容进行操作。<code>$ADDUSER_RETURN_CODE</code>肯定会保持不变;<code>$?</code>将随执行的每个命令而更改。</p><h1 id="14-Hints-and-Tips"><a href="#14-Hints-and-Tips" class="headerlink" title="14. Hints and Tips"></a>14. Hints and Tips</h1><p>查看 <a class="link"   href="http://www.shellscript.sh/tips/" >www.shellscript.sh/tips/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 以获取更多最新的提示和建议</p><p>老实说，下面的内容已经过时了。下面网站的 &#x2F;tips 部分有更多、更有用的提示。</p><p><a class="link"   href="https://www.shellscript.sh/tips/" > <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>Unix 充满了文本操作实用进程，其中一些更强大的实用进程我们现在将在本教程的这一部分中讨论。这样做的意义在于，Unix下几乎所有的东西都是文本。实际上，您能想到的任何内容都由文本文档或命令行界面 （CLI） 控制。唯一无法使用 shell 脚本自动执行的是仅限 GUI 的实用进程或功能。而在Unix下，它们并不多！</p><p>你可能听说过有人说，用 *nix，“一切都是一个文档”——这是真的。</p><p>我们这里有几个小节…以下是一般建议、提示和技巧。</p><p>省略一些网址</p><p>我们已经在上面展示了简单但有效的 <code>cut</code>命令的使用。我们将在这里讨论一些更常见的外部进程的例子。</p><p><code>grep</code> 对于 shell 脚本进程员来说是一个非常有用的实用进程。 grep 的一个例子是：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">steves=`grep -i steve /etc/passwd | <span class="built_in">cut</span> -d: -f1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All users with the word \&quot;steve\&quot; in their passwd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Entries are: <span class="variable">$steves</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p>如果只有一个匹配项，则此脚本看起来不错。但是，如果 &#x2F;etc&#x2F;passwd 中有两行带有词“steve”，则交互式 shell 将显示：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&gt; grep -i steve /etc/passwd </span><br><span class="line">steve:x:5062:509:Steve Parker:/home/steve:/bin/bash</span><br><span class="line">fred:x:5068:512:Fred Stevens:/home/fred:/bin/bash</span><br><span class="line">$&gt; grep -i steve /etc/passwd |<span class="built_in">cut</span> -d: -f1</span><br><span class="line">steve</span><br><span class="line">fred</span><br></pre></td></tr></table></figure></div><p>但脚本将显示：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entries are: steve fred</span><br></pre></td></tr></table></figure></div><p>通过将结果放入变量中，我们将换行符更改为空格; <code>SH</code> 手册页告诉我们，<code>$IFS</code>中的第一个字符将用于此目的。</p><p>默认情况下，IFS 为 <space><tab><cr>。也许虽然我们想保留换行符：如果我们把空格变成换行符，看起来会更好……这是 <code>tr</code> 的工作：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">steves=`grep -i steve /etc/passwd | <span class="built_in">cut</span> -d: -f1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All users with the word \&quot;steve\&quot; in their passwd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Entries are: &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$steves</span>&quot;</span> | <span class="built_in">tr</span> <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\012&#x27;</span></span><br></pre></td></tr></table></figure></div><p>请注意，tr 将空格转换为八进制字符 012（换行符）。 tr的另一个常见用途是它使用范围…它可以将文本转换为大写或小写，例如：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">steves=`grep -i steve /etc/passwd | <span class="built_in">cut</span> -d: -f1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All users with the word &quot;</span>steve<span class="string">&quot; in their passwd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Entries are: &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$steves</span>&quot;</span> | <span class="built_in">tr</span> <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\012&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[a-z]&#x27;</span> <span class="string">&#x27;[A-Z]&#x27;</span></span><br></pre></td></tr></table></figure></div><p>在这里，我们添加了 [a-z] 到 [A-Z] 的翻译。请注意，a-z 范围内的值数量与 A-Z 完全相同。然后，这可以将属于 ASCII 范围 a-z 的任何字符转换为 A-Z …换句话说，将小写字母转换为大写字母。<code>TR</code> 实际上比这更聪明：<code>TR [：lower：] [：upper：]</code> 也可以完成这项工作，而且可能更具可读性。它也不是那幺可移植;并非每个 TR 都能做到这一点。</p><h2 id="欺骗-Cheating"><a href="#欺骗-Cheating" class="headerlink" title="欺骗 Cheating"></a>欺骗 Cheating</h2><p>那些不能…欺骗的人</p><p>作弊没有错！有些事情shell不是很擅长。两个有用的工具是<code>sed</code>和<code>awk</code>。虽然这是两个非常强大的实用进程，它们本身可以用作迷你编程语言，但由于非常简单的特定原因，它们经常在 shell 脚本中使用。</p><p>虽然这意味着系统必须加载一个大型可执行文档（sed 为 52k，awk 为 110k），这是一件令人讨厌的事情，但一个好工人不会责怪他的工具的原因是，一个好工人首先使用正确的工具。</p><p>因此，让我介绍一下这两个，用途非常简单。</p><p>用awk作弊</p><p>考虑 wc，它计算文本文档中的字符、行数和单词数。其输出为：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">wc</span> hex2env.c</span><br><span class="line">1021892306hex2env.c</span><br></pre></td></tr></table></figure></div><p>如果我们想将行数放入一个变量中，只需使用：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NO_LINES=`<span class="built_in">wc</span> -l file`</span><br></pre></td></tr></table></figure></div><p>这将在整行中阅读。</p><p>由于输出是空格填充的，因此我们无法可靠地将数字 102 放入字符串中。相反，我们使用<code>awk</code>与C中的<code>scanf</code>类似的性质 - 它去除了不需要的空格.它将它们放入变量 <code>$1 $2 $3</code> 等。所以我们使用这个结构：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NO_LINES=`<span class="built_in">wc</span> -l file | awk <span class="string">&#x27;&#123; print $1 &#125;&#x27;</span>`</span><br></pre></td></tr></table></figure></div><p>变量NO_LINES现在为 102。</p><h3 id="用sed作弊"><a href="#用sed作弊" class="headerlink" title="用sed作弊"></a>用sed作弊</h3><p>另一个方便的实用进程是 sed - 流编辑器。Perl 非常擅长处理正则表达式，而 shell 则不然。因此，我们可以通过调用 sed 来快速使用 <code>s/from/to/g</code> 结构。例如：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed s/eth0/eth1/g file1 &gt;  file2</span><br></pre></td></tr></table></figure></div><p>将文档 1 中 <code>eth0</code> 的每个实例更改为文档 2 中的 <code>eth1</code>。</p><p>如果我们只更改单个字符，tr 将是要使用的工具，更小，因此加载速度更快。</p><p>tr 不能做的另一件事是从文档中删除字符：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;SOMETHING&#125;</span> | sed s/<span class="string">&quot;bad word&quot;</span>//g</span><br></pre></td></tr></table></figure></div><p>这会从变量 <code>$&#123;SOMETHING&#125;</code> 中删除短语“bad word”。人们可能会说，“但是 grep 可以做到这一点！”——grep 只处理整行。考虑以下文档：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This line is okay.</span><br><span class="line">This line contains a bad word. Treat with care.</span><br><span class="line">This line is fine, too.</span><br></pre></td></tr></table></figure></div><p>Grep 将删除整个第二行，只留下一个两行文档;sed 会将文档更改为读取：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This line is okay.</span><br><span class="line">This line contains a . Treat with care.</span><br><span class="line">This line is fine, too.</span><br></pre></td></tr></table></figure></div><h2 id="Telnet-提示"><a href="#Telnet-提示" class="headerlink" title="Telnet 提示"></a>Telnet 提示</h2><p>这是我从 Sun 的资源管理器实用进程中学到的一个有用的技术。虽然 telnet 不再用于服务器，但它仍然被某些网络设备使用，例如终端集中器等。通过创建如下脚本、您自己的脚本或从命令行创建，您可以运行：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./telnet1.sh | telnet</span><br></pre></td></tr></table></figure></div><p>我有几个人问过我这个问题，并倾向于将他们指向预期的代码套件，它非常复杂和笨重;</p><p>这段代码应该在系统之间非常可移植（只要它们有 egrep）。如果它不能在你的系统上工作，请尝试使用带有 -q 开关的 GNU grep，或者使用专有的 grep 并直接使用 &#x2F;dev&#x2F;null。不过，仍然比安装预期的要容易得多。</p><p>telnet.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">host=127.0.0.1</span><br><span class="line">port=23</span><br><span class="line">login=steve</span><br><span class="line">passwd=hellothere</span><br><span class="line">cmd=<span class="string">&quot;ls /tmp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> open <span class="variable">$&#123;host&#125;</span> <span class="variable">$&#123;port&#125;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;login&#125;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;passwd&#125;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;cmd&#125;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">exit</span></span><br></pre></td></tr></table></figure></div><p>但是，Sun 添加了一些巧妙的错误检查代码（请注意，您可以从当前的 shell 或 shell 脚本中设置和导出变量，以避免将密码存储在可读文档中）：</p><p><code>$ ./telnet2.sh | telnet &gt; file1</code>  </p><p>telnet2.sh</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># telnet2.sh | telnet &gt; FILE1 </span></span><br><span class="line">host=127.0.0.1</span><br><span class="line">port=23</span><br><span class="line">login=steve</span><br><span class="line">passwd=hellothere</span><br><span class="line">cmd=<span class="string">&quot;ls /tmp&quot;</span></span><br><span class="line"><span class="built_in">timeout</span>=3</span><br><span class="line">file=file1</span><br><span class="line">prompt=<span class="string">&quot;$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> open <span class="variable">$&#123;host&#125;</span> <span class="variable">$&#123;port&#125;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line">tout=<span class="variable">$&#123;timeout&#125;</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;tout&#125;</span>&quot;</span> -ge 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tail</span> -1 <span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span> 2&gt;/dev/null | egrep -e <span class="string">&quot;login:&quot;</span> &gt; /dev/null</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;login&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 1</span><br><span class="line">        tout=-5</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">sleep</span> 1</span><br><span class="line">        tout=`<span class="built_in">expr</span> <span class="variable">$&#123;tout&#125;</span> - 1`</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;tout&#125;</span>&quot;</span> -ne <span class="string">&quot;-5&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">tout=<span class="variable">$&#123;timeout&#125;</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;tout&#125;</span>&quot;</span> -ge 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tail</span> -1 <span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span> 2&gt;/dev/null | egrep -e <span class="string">&quot;Password:&quot;</span> &gt; /dev/null</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;passwd&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 1</span><br><span class="line">        tout=-5</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">tail</span> -1 <span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span> 2&gt;/dev/null | egrep -e <span class="string">&quot;<span class="variable">$&#123;prompt&#125;</span>&quot;</span> &gt; /dev/null</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">        tout=-5</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">sleep</span> 1</span><br><span class="line">        tout=`<span class="built_in">expr</span> <span class="variable">$&#123;tout&#125;</span> - 1`</span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;tout&#125;</span>&quot;</span> -ne <span class="string">&quot;-5&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="variable">$&#123;file&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;cmd&#125;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">exit</span></span><br></pre></td></tr></table></figure></div><p>请注意，在此版本中，输出被抓取到 <code>file1</code>，并且脚本实际上使用此文档来检查其进度。我添加了“<code>&gt; $&#123;file&#125;</code>”，以便接收到文档中的输出只是命令的输出，而不是登录过程。</p><h1 id="15-快速参考"><a href="#15-快速参考" class="headerlink" title="15. 快速参考"></a>15. 快速参考</h1><p>这是一个快速参考指南，介绍了一些不太容易猜到的命令和 shell 脚本代码的含义。就其性质而言，使用搜索引擎也很难找到它们。这些示例包括进程管理、shell 脚本参数和 shell 脚本测试条件。</p><table><thead><tr><th>Command</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>&amp;</td><td>Run the previous command in the background</td><td>ls &amp;</td></tr><tr><td>&amp;&amp;</td><td>Logical AND</td><td>if [ “$foo” -ge “0” ] &amp;&amp; [ “$foo” -le “9”]</td></tr><tr><td></td><td></td><td></td></tr><tr><td>^</td><td>Start of line</td><td>grep “^foo”</td></tr><tr><td>$</td><td>End of line</td><td>grep “foo$”</td></tr><tr><td>&#x3D;</td><td>String equality (cf. -eq)</td><td>if [ “$foo” &#x3D; “bar” ]</td></tr><tr><td>!</td><td>Logical NOT</td><td>if [ “$foo” !&#x3D; “bar” ]</td></tr><tr><td>$$</td><td>PID of current shell</td><td>echo “my PID &#x3D; $$”</td></tr><tr><td>$!</td><td>PID of last background command</td><td>ls &amp; echo “PID of ls &#x3D; $!”</td></tr><tr><td>$?</td><td>exit status of last command</td><td>ls ; echo “ls returned code $?”</td></tr><tr><td>$0</td><td>Name of current command (as called)</td><td>echo “I am $0”</td></tr><tr><td>$1</td><td>Name of current command’s first parameter</td><td>echo “My first argument is $1”</td></tr><tr><td>$9</td><td>Name of current command’s ninth parameter</td><td>echo “My ninth argument is $9”</td></tr><tr><td>$@</td><td>All of current command’s parameters (preserving whitespace and quoting)</td><td>echo “My arguments are $@”</td></tr><tr><td>$*</td><td>All of current command’s parameters (not preserving whitespace and quoting)</td><td>echo “My arguments are $*”</td></tr><tr><td>-eq</td><td>Numeric Equality</td><td>if [ “$foo” -eq “9” ]</td></tr><tr><td>-ne</td><td>Numeric Inquality</td><td>if [ “$foo” -ne “9” ]</td></tr><tr><td>-lt</td><td>Less Than</td><td>if [ “$foo” -lt “9” ]</td></tr><tr><td>-le</td><td>Less Than or Equal</td><td>if [ “$foo” -le “9” ]</td></tr><tr><td>-gt</td><td>Greater Than</td><td>if [ “$foo” -gt “9” ]</td></tr><tr><td>-ge</td><td>Greater Than or Equal</td><td>if [ “$foo” -ge “9” ]</td></tr><tr><td>-z</td><td>String is zero length</td><td>if [ -z “$foo” ]</td></tr><tr><td>-n</td><td>String is not zero length</td><td>if [ -n “$foo” ]</td></tr><tr><td>-nt</td><td>Newer Than</td><td>if [ “$file1” -nt “$file2” ]</td></tr><tr><td>-d</td><td>Is a Directory</td><td>if [ -d &#x2F;bin ]</td></tr><tr><td>-f</td><td>Is a File</td><td>if [ -f &#x2F;bin&#x2F;ls ]</td></tr><tr><td>-r</td><td>Is a readable file</td><td>if [ -r &#x2F;bin&#x2F;ls ]</td></tr><tr><td>-w</td><td>Is a writable file</td><td>if [ -w &#x2F;bin&#x2F;ls ]</td></tr><tr><td>-x</td><td>Is an executable file</td><td>if [ -x &#x2F;bin&#x2F;ls ]</td></tr><tr><td>( … )</td><td>Function definition</td><td>function myfunc() { echo hello }</td></tr></tbody></table><h1 id="16-interactive-Shell"><a href="#16-interactive-Shell" class="headerlink" title="16. interactive Shell"></a>16. interactive Shell</h1><p>以下是一些以交互方式使用 UNIX 或 Linux shell 的快速提示。就个人而言，我建议将 bash shell 用于大多数交互式用途;它几乎可用于每种 *nix 口味，并且用作登录Shell非常愉快。</p><h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>bash有一些非常方便的历史搜索jl工具;向上和向下箭头键将滚动浏览先前命令的历史记录。更有用的是，Ctrl+r 将执行反向搜索，匹配命令行的任何部分。点击 ESC，所选命令将粘贴到当前 shell 中，供您根据需要进行编辑。</p><p>如果要重复之前运行的命令，并且知道它以哪些字符开头，则可以执行以下操作：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash$ <span class="built_in">ls</span> /tmp</span><br><span class="line">(list of files <span class="keyword">in</span> /tmp)</span><br><span class="line">bash$ <span class="built_in">touch</span> /tmp/foo</span><br><span class="line">bash$ !l</span><br><span class="line"><span class="built_in">ls</span> /tmp</span><br><span class="line">(list of files <span class="keyword">in</span> /tmp, now including /tmp/foo)</span><br></pre></td></tr></table></figure></div><p>除了箭头键，您还可以使用 PageUp 和 PageDn 导航到命令行的开头和结尾。</p><h2 id="Ksh"><a href="#Ksh" class="headerlink" title="Ksh"></a>Ksh</h2><p>您可以通过添加历史记录命令使 ksh 更可用，不管是 <code>vi</code>模式或 <code>emacs</code>模式. 有多种方法可以做到这一点，具体取决于具体情况。</p><p><code>set -o vi、ksh -o vi</code> 或 <code>exec ksh -o vi</code>（如果您更喜欢 emacs 模式，可以将 “vi” 替换为 “emacs”）。</p><p>如果你想从另一个交互式 shell 启动一个 ksh 会话，你可以像这样调用 ksh：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">csh% <span class="comment"># oh no, it&#x27;s csh!</span></span><br><span class="line">csh% ksh</span><br><span class="line">ksh$ <span class="comment"># phew, that&#x27;s better</span></span><br><span class="line">ksh$ <span class="comment"># do some stuff under ksh</span></span><br><span class="line">ksh$ <span class="comment"># then leave it back at the csh prompt:</span></span><br><span class="line">ksh$ <span class="built_in">exit</span></span><br><span class="line">csh%</span><br></pre></td></tr></table></figure></div><p>这将启动一个新的 ksh 会话，您可以从该会话退出并返回到上一个 shell。或者，您可以使用 <code>exec</code> 命令将 csh（或任何 shell）替换为 ksh shell：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">csh% <span class="comment"># oh no, it&#x27;s csh!</span></span><br><span class="line">csh% <span class="built_in">exec</span> ksh</span><br><span class="line">ksh$ <span class="comment"># do some stuff under ksh</span></span><br><span class="line">ksh$ <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">login:</span><br></pre></td></tr></table></figure></div><p>这里的区别在于您不会恢复 csh 会话。 好东西是历史记录：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">csh% ksh</span><br><span class="line">ksh$ <span class="built_in">set</span> -o vi</span><br><span class="line">ksh$ <span class="comment"># You can now edit the history with vi-like commands, </span></span><br><span class="line">  <span class="comment"># and use ESC-k to access the history.</span></span><br></pre></td></tr></table></figure></div><p>如果您按 ESC 然后按 k，则通过反复按 k，您可以向后滚动命令历史记录。您可以使用 vi 命令模式和进入模式命令来编辑命令，如下所示：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ksh$ <span class="built_in">touch</span> foo</span><br><span class="line">  ESC-k (enter vi mode, brings up the previous <span class="built_in">command</span>)</span><br><span class="line">  w (skip to the next word, to go from <span class="string">&quot;touch&quot;</span> to <span class="string">&quot;foo&quot;</span></span><br><span class="line">  cw (change word) bar (change <span class="string">&quot;foo&quot;</span> to <span class="string">&quot;bar&quot;</span>)</span><br><span class="line">ksh$ <span class="built_in">touch</span> bar</span><br></pre></td></tr></table></figure></div><h1 id="17-练习"><a href="#17-练习" class="headerlink" title="17 练习"></a>17 练习</h1><p>我认为一个快速练习可能有助于确定您在 shell 脚本方面的表现……</p><ul><li>地址簿</li><li>目录遍历</li></ul><h2 id="地址簿"><a href="#地址簿" class="headerlink" title="地址簿"></a>地址簿</h2><p>好吧，这很无聊，但这是你今天的练习：使用 bourne 或 bourne-again shell 创建一个地址簿进程。</p><p>它应该使用函数来执行所需的任务。它应该是menu-based，允许您的选项：</p><ul><li>搜索地址簿</li><li>添加条目</li><li>删除&#x2F;编辑条目</li></ul><p>您还需要一个“显示display”函数，以便在选择时显示一个或多个记录。</p><h3 id="搜索search"><a href="#搜索search" class="headerlink" title="搜索search"></a>搜索search</h3><p><a class="link"   href="https://www.notion.so/Smith-b279bfbe77fe447cb745c08faeb4bf17" >当用户搜索“Smith”时，脚本应标识并显示所有“史密斯”记录。此搜索是仅在姓氏中还是在整个记录中由您决定。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="添加-add"><a href="#添加-add" class="headerlink" title="添加 add"></a>添加 add</h3><p>输入数据（姓名、姓氏、电子邮件、电话等）。 如果它看起来是重复的，提供编辑现有记录提供额外奖励。 当用户确认时，将记录保存到数据文档中。</p><h3 id="移除remove"><a href="#移除remove" class="headerlink" title="移除remove"></a>移除remove</h3><p>输入搜索条件，将其缩小到一个，确认，然后删除该记录。</p><h3 id="编辑edit"><a href="#编辑edit" class="headerlink" title="编辑edit"></a>编辑edit</h3><p>作为删除，但对默认条目使用现有记录。 例如，如果您更改电话号码，则会话可能如下所示，如果您只想更改 John Smith 的电话号码：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name [ John Smith ]</span><br><span class="line">Phone [ 12345 ] 54321</span><br><span class="line">Email [ joe@smith.org.uk ]</span><br></pre></td></tr></table></figure></div><p>删除旧记录，然后添加新记录。或者，编辑现有记录，尽管这可能更困难。</p><h3 id="奖励积分-Bonus-Points"><a href="#奖励积分-Bonus-Points" class="headerlink" title="奖励积分 Bonus Points"></a>奖励积分 Bonus Points</h3><ul><li>允许取消选项（使用“特殊”条目（^d，CR，^c等））</li><li>添加“确认”选项。</li><li>提供交互&#x2F;非交互模式。（即，基于菜单的版本和基于命令行 （CLI） 的选项。</li><li>使用命令行界面CLI版本的getopt玩。</li></ul><h3 id="提示-x2F-需要考虑的问题"><a href="#提示-x2F-需要考虑的问题" class="headerlink" title="提示 &#x2F; 需要考虑的问题"></a>提示 &#x2F; 需要考虑的问题</h3><ul><li><p>建议的记录格式：使用冒号分隔字段。</p><p>  John Smith: 54321:<a class="link"   href="mailto:&#106;&#x6f;&#104;&#110;&#64;&#115;&#109;&#x69;&#116;&#104;&#46;&#101;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;" >&#106;&#x6f;&#104;&#110;&#64;&#115;&#109;&#x69;&#116;&#104;&#46;&#101;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>这样您就可以使用“cut -d：”来读取字段。</p></li><li><p>考虑使用 IFS 作为此方法的替代方法。</p></li><li><p>考虑使用空格 （“ ”） 分隔字段，并将输入中的任何空格转换为下划线 （“_”），然后再次将它们转换回来以显示。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网站&quot;&gt;&lt;a href=&quot;#网站&quot; class=&quot;headerlink&quot; title=&quot;网站&quot;&gt;&lt;/a&gt;网站&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://www.shellscript.sh/index.html&quot; &gt;Shell </summary>
      
    
    
    
    
    <category term="shellscript" scheme="http://example.com/tags/shellscript/"/>
    
  </entry>
  
  <entry>
    <title>2.Part C Mean Value Theorem, Antiderivatives and Differential Equations</title>
    <link href="http://example.com/[object%20Object]/2023/02/19/calculus18d01-1/"/>
    <id>http://example.com/[object%20Object]/2023/02/19/calculus18d01-1/</id>
    <published>2023-02-19T14:59:44.000Z</published>
    <updated>2023-04-09T16:11:41.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="session-34"><a href="#session-34" class="headerlink" title="session 34"></a>session 34</h1><h2 id="均值定理"><a href="#均值定理" class="headerlink" title="均值定理"></a>均值定理</h2><p>均值定理有点理论化,并将使我们能够在几堂课中介绍积分的概念,积分是本课程后半部分内容.我们会用缩写”MVT”当提到他的时候. (Mean Value Theorem)</p><p>通俗的说, 均值定理告诉我们,如果你在6小时内飞了3000km, 那么在飞行的某个时间点,你的速度为500km&#x2F;h. (因为你的平均速度是500km&#x2F;h).</p><p>均值定理内容就像他的名字包含平均的意思.</p><p>数学语言写为</p><p>$$<br>\frac{f(b) - f(a)}{b-a} &#x3D; f’(c) \quad \text{(for some c, a&lt;c&lt;b)} \ \text{假设 f 在 &lt; x &lt; b 上可微分，并且在 ≤ x ≤ b 上连续}<br>$$</p><p>均值定理的几何证明: 考虑f(x)的图像, $\frac{f(b) - f(a)}{b-a}$ 是连接点 (a,f(a)) 和点(b,f(b))的割线的斜率. f’(c)是切线的斜率.我们要说明在a和b之间,有一点(c,f(c))他的切线的斜率和割线的斜率相同.</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f86fda4a-cce9-461b-a3cf-8f5212963449/Untitled.png"                      alt="Untitled"                ></p><p>取虚线平行于割线,并将他向上移,直到碰到a和b之间的部分的线,如果它没有接触，从图表上方的虚线开始，然后向下移动，直到它接触。</p><p>当阅读一个证明的时候,你总要想为什么假设是必要的, 如果函数非连续或者不可导,证明还有用吗?</p><p>我们需要假设f是连续的是因为,如果你在那坐了6个小时,然后瞬间传送3000公里以外,那你永远也不会经历速度为500km&#x2F;h. 均值定理对非连续函数没有任何作用.</p><p>如果函数是不可导的呢? 假设  $&#x3D; |x|$, 那虚线总是在x &#x3D; 0先碰到线,不管这点的斜率是什么.尽管f在除了0点之外的地方都可到,但均值定律不起作用. 我们需要f’(x)在a,b之间任何一点可导</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c4f40229-78e5-41f3-870b-cc150b5af708/Untitled.png"                      alt="Untitled"                ></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><p>如果平行于割线的线与图像有多个交点呢</p><h3 id="回答"><a href="#回答" class="headerlink" title="回答:"></a>回答:</h3><p>越多越好,!图形可以摆动很多次，线可以接触十个地方，或者f可以是常数，线可以一次接触图上的每个点。在数学中，当我们声称某件事对某一点是正确的时，我们并不一定意味着它对其他点不是正确的。</p><p>这一点存在的事实是一个敏感点;我们可以看到为什幺它应该存在，但我们并没有真正证明它确实存在。严格的证明涉及切线的存在性和更多的分析.</p><h2 id="均值定理-后果"><a href="#均值定理-后果" class="headerlink" title="均值定理:后果"></a>均值定理:后果</h2><p>我们将 MVT 应用于的第一件事是绘图，但我们稍后会看到这在所有其他微积分中都很重要。</p><ul><li>如果 f’ &gt; 0 那么 f 是上升的</li><li>如果 f’ &lt; 0 那么 f 是下降的</li><li>如果 f’ &#x3D; 0 那么 f 是常量</li></ul><p>我们告诉你前两条是正确的,但我们没有证明, 我们现在可以用中值定理证明.</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明:"></a>证明:</h3><p>均值定理告诉我们</p><p>$$<br>\frac{f(b) - f(a)}{b-a} &#x3D; f’(c)<br>$$</p><p> c 在 a和b之间. 为了证明的目的,我们假设b &gt; a.我们倒退来写 均值定理方程 ,因为我们想要使用f’的信息获得f的信息.</p><p>我们操纵方程得到:</p><p>$$<br>\begin{align}f(b) - f(a) &amp; &#x3D; f’(c)(b-a)\<br>f(b)&amp; &#x3D; f(a)+f’(c)(b-a)\end{align}<br>$$</p><p>均值定理的新形势让我们可以检查上面三个事实.</p><p>因为$a&lt;b,b-a&gt;0$ , 那么$f’(c)(b-a)$的符号完全由$f’(c)$的符号决定.</p><ul><li>如果f’(c) &gt;0 那么 $f(b) &gt; f(a)$.</li><li>如果f’(c) &lt;0 那么 $f(b) &lt; f(a)$.</li><li>如果f’(c) &#x3D;0 那么 $f(b) &#x3D; f(a)$.</li></ul><p>这些事实似乎很明显，但事实并非如此.导数的定义是用无穷小写的。不能确定这些无穷小是否与函数的大规模行为有任何关系。以前，我们说差商近似等于导数。现在我们说它完全等于导数。（虽然我们不知道应该在什幺时候取导数。</p><h2 id="问题-推广均值定理——泰勒定理"><a href="#问题-推广均值定理——泰勒定理" class="headerlink" title="问题:推广均值定理——泰勒定理"></a>问题:推广均值定理——泰勒定理</h2><p>我们探讨均值定理的推广,这引向了泰勒多项式的误差估计.然后我们在多项式函数上测试这种推广.</p><p>回想一下,均值定理说给定一个函数,在[a,b]连续, 在(a,b)可导.然后再(a,b)之间有一点c,满足</p><p>$$<br>f’(c) &#x3D; \frac{f(b) - f(a)}{b-a}<br>$$</p><p>整理公式,我们可以让他看起来非常想f(b)的近似使用在x&#x3D;a处的切线.</p><p>$$<br>f(b) &#x3D; f(a) + f’(c)(b-a)<br>$$</p><p>除了f’(a)被换成了 f’(c), 为了使等式完全相等.请记住，均值定理只给出了这样一个点c的存在，而不是如何找到c的方法。</p><p><strong>我们将这个方程理解为，f（b） 和 f（a） 之间的差值由类似于泰勒多项式中下一项的表达式给出。这里 f（a） 是一个“0 度”泰勒多项式。</strong></p><p>对一阶近似重复此操作,我们可能得到</p><p>$$<br>f(b) &#x3D; [f(a)+f’(a)(b-a)] + \frac{f’’(c)}{2}(b-a)^2<br>$$</p><p>c在 (a,b)内.方括号中完全是线性近似计算.</p><h3 id="提问"><a href="#提问" class="headerlink" title="提问:"></a>提问:</h3><p>猜测f(b) 和他n阶泰勒多项式在x&#x3D;a处的差.用三阶多项式做测试$f(x) &#x3D; x^3 +2x +1$.对f(3)在x&#x3D;1 做二阶近似.</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h3><p>f(b) 和他在点a的n阶泰勒多项式遵循同样的规则,回忆一下,f(x)在x &#x3D; a的n阶泰勒多项式p(x) 是:</p><p>$$<br>P(x)&#x3D; f(a) + f’(a)(x-a) + \frac{f’’(a)}{2}(x-a)^2 + \cdot \cdot\cdot + \frac{f^{(n)}(a)}{n!}(x-a)^{n}<br>$$</p><p>我们猜测差为:</p><p>$$<br>f(b) - P(b) &#x3D; \frac{f^{(n+1)}(c)}{(n+1)!}(b-a)^{n+1}<br>$$</p><p>c在(a,b)之间. 这个事实的证明可以在很多高级微积分中看到. 我们在这里不做证明.而是满足于在上述单一特殊情况下验证它。</p><p>多项式f(x)的二阶近似p(x)在x&#x3D;1处为:</p><p>$$<br>P(x) &#x3D; f(1) + f’(1)(x-1) + \frac{f’’(1)}{2}(x-1)^2 &#x3D; 4+5(x-1) + 3(x-1)^2<br>$$</p><p>将x&#x3D;3带入,我们得到 f(3) &#x3D; 34, P(3) &#x3D; 26, 所以我们要找一个在(1,3)之间的c使得</p><p>$$<br>\frac{f^{(3)}}{3!}(3-1)^3 &#x3D; f(3) - P(3) &#x3D; 8<br>$$</p><p>因为f是3阶函数,他的三阶导是常数,求得为6, 和3!约除 所以等式成立.</p><p>在实践中，泰勒定理非常有用。如果我们可以将 f（n+1）（x） 的大小绑定在区间 （a， b） 上，那幺我们可以应用该定理来获得将 f（x） 逼近为 n 次泰勒多项式的具体误差估计。</p><h1 id="session-35"><a href="#session-35" class="headerlink" title="session 35"></a>session 35</h1><h2 id="均值定理和线性近似"><a href="#均值定理和线性近似" class="headerlink" title="均值定理和线性近似"></a>均值定理和线性近似</h2><p>均值定理和线性近似的区别是什么?</p><p>f(x) 在a的线性近似有公式:</p><p>$$<br>f(x) \approx f(a) + f’(a)(x-a) \text{\quad x near a.}<br>$$</p><p>如果我们让$\triangle x &#x3D; x-a,$我们有:</p><p>$$<br>\begin{align}<br>f(x) &amp;\approx f(a) + f’(a)(x-a) \<br>f(x) - f(a) &amp; \approx f’(a)\triangle x \<br>\frac{\triangle f}{\triangle x} &amp;\approx f’(a)<br>\end{align}<br>$$</p><p>同样的, 均值定理说:</p><p>$$<br>f(b) &#x3D; f(a) + f’(c)(b-a) \quad \text{for some c, a&lt;c&lt;b}<br>$$</p><p>如果b和a很近,我们可以写$b-a&#x3D; \triangle x$,然后重写上式为</p><p>$$<br>\frac{\triangle f}{\triangle x} \approx f’(c)\quad\text{for some c, a&lt;c&lt;b}<br>$$</p><p>均值定理告诉我们$\frac{\triangle f}{\triangle x}$  完全等于 $f’(c)$ ,c介于a和b之间,我们不能确切知道c是多少,这取决于f,a和b的值.</p><p>就像教授jerison 在视频中说的,在区间的平均变化在 $f’(x)$在区间达到的最大值和最小值之间.(因为导数是连续的.)</p><p>$$<br>min f’(x) \le \frac{f(b) - f(a)}{b-a} &#x3D; f’(c) \le maxf’(x) \quad a \le x \le b<br>$$</p><p>换句话说,你旅行的平均速度在你最快速度和最慢速度之间.</p><p>线性近似, 在假设的基础上:平均速度大约等于最初(也可能最终)速度 图一展示了$1+x \approx e^x$的近似</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fbd17320-e553-4799-bdea-b278253f6a94/Untitled.png"                      alt="Untitled"                ></p><p>如果区间 [a,b]很短,f’(x)在a到b之间不会变化太大.最大和最小应该很接近.均值定理告诉我们从点(a,f(a))到点(x,f(x))的割线的斜率不会小于此区间上$f’$的最小值,不会大于$f’$最大值.这向我们保证,线性近似给了我们一个合理的近似.</p><h2 id="均值定理和不等式"><a href="#均值定理和不等式" class="headerlink" title="均值定理和不等式"></a>均值定理和不等式</h2><p>均值定理告诉我们,如果f和f’在[a,b]连续,那么有:</p><p>$$<br>\frac{f(b)-f(a)}{b-a} &#x3D; f’(c) \quad c介于 a,b之间<br>$$</p><p>因为f’是连续的,f’(c) 一定介于f’(x)最小值和最大值之间.换句话说:</p><p>$$<br>min f’(x) \le \frac{f(b) - f(a)}{b-a} &#x3D; f’(c) \le maxf’(x) \quad a \le x \le b<br>$$</p><p><strong>这是在利用均值定理解决问题时的形式(与数学证明相反)</strong>, 这也是你在做题时需要知道的形式.</p><p>在实践中,你也许会忘记均值定理,只记得下面三个不等式:</p><ul><li>如果 $f’(c) &gt; 0 那么f(b) &gt; f(a)$</li><li>如果 $f’(c) &lt; 0 那么f(b) &lt; f(a)$</li><li>如果 $f’(c) &#x3D; 0 那么f(b) &#x3D; f(a)$</li></ul><p>这些可以用来证明数学不等式.下面的例子将函数$e^x$和他的线性近似,二阶近似比较.这是对更深度函数了解的第一步.</p><h3 id="例子-说明-e-x-gt-1-x-当x-gt-0"><a href="#例子-说明-e-x-gt-1-x-当x-gt-0" class="headerlink" title="例子:说明$e^x &gt;1+x 当x&gt;0$"></a>例子:说明$e^x &gt;1+x 当x&gt;0$</h3><p>为了证明上式,我们利用 $f(x) &#x3D; e^x - (1+x)$ 说明f总是正的.</p><p>我们知道$f(0) &#x3D; e^0 - (1-0)$ ,$f’(x) &#x3D; e^x -1$ .当x是正的,$f’(x)$ 是正的,因为$e^x &gt;1$.</p><p>我们知道如果$f’(x) &gt;0$在一个区间上,$f(x)$咱那个区间上增加.所以我们可以得出结论$f(x) &gt;f(0) 当x&gt;0$</p><p>.换句话说</p><p>$$<br>e^x - (1+x) &gt;0 \iff e^x &gt; 1+x<br>$$</p><h3 id="例子-说明-e-x-gt-1-x-frac-x-2-2-当x-gt-0"><a href="#例子-说明-e-x-gt-1-x-frac-x-2-2-当x-gt-0" class="headerlink" title="例子:说明$e^x &gt;1+x + \frac{x^2}{2} 当x&gt;0$"></a>例子:说明$e^x &gt;1+x + \frac{x^2}{2} 当x&gt;0$</h3><p>$1+x + \frac{x^2}{2}$的值要比1+x的值略大,但结果表明他还是小于$e^x$的值. 我们设$g(x) &#x3D;e^x -(1+x + \frac{x^2}{2})$ 然后重复上面得步骤.</p><p>$$<br>g(0) &#x3D; 1-(1)&#x3D;0 \<br>g’(x) &#x3D; e^x -(1+x)<br>$$</p><p>我们知道$g’(x) &gt;0$因为我们在上面的例子中证明了$f(x) &gt;0$.因为$g’(x)$是正的, g在x&gt;0是递增的.所以$g(x) &gt; g(0)$当x&gt;0 所以$e^x-(1+x+\frac{x^2}{2})并且e^x &gt;1+x+\frac{x^2}{2}$</p><p>我们可以继续下去$e^x &#x3D;1+x+\frac{x^2}{2} +\frac{x^3}{3!}$当x&gt;0.最终我们得到</p><p>$$<br>e^x &#x3D;1+x+\frac{x^2}{2} +\frac{x^3}{3!} + \cdot \cdot \cdot \quad \text{(an infinite sum)}<br>$$</p><p>我们会在这节课额最后讲泰勒公式时讲到.</p><h2 id="问题-sin-b-sin-a-vs-b-a"><a href="#问题-sin-b-sin-a-vs-b-a" class="headerlink" title="问题: $|sin(b) - sin(a)| vs.|b-a|$"></a>问题: $|sin(b) - sin(a)| vs.|b-a|$</h2><p>使用我们学到的均值定理比较上式.</p><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案:"></a>答案:</h3><p>我们可以从均值定理开始解题,或我们回忆上节课的内容:</p><p>$$<br>min f’(x) \le \frac{f(b) - f(a)}{b-a} &#x3D; f’(c) \le maxf’(x) \quad a \le x \le b<br>$$</p><p>如果$f(x) &#x3D; sinx,$$f’(x) &#x3D; cosx$不等式变为:</p><p>$$<br>min\quad cos(x) \le \frac{sin(b) - sin(a)}{b-a} \le max\quad cos(x) \quad a \le x \le b<br>$$</p><p>我们不知道a和b的值,但我们知道cosine 函数范围从-1到1. 去掉未知的上下棉结,我们得到</p><p>$$<br>-1\le \frac{sin(b) - sin(a)}{b-a} \le 1<br>$$</p><p>或者</p><p>$$<br>-(b-a) \le sin(b) - sin(a) \le b-a<br>$$</p><p>我们得到结论$|sin(b) - sin(a)|\le |b-a|$ .这是一个令人惊讶的有用结果，仅因为正弦曲线的斜率永远不会大于 1 或小于 -1。</p><h3 id="习题课视频"><a href="#习题课视频" class="headerlink" title="习题课视频"></a>习题课视频</h3><ol><li>说明 $tanx &gt;x \quad 0 &lt;x&lt;\frac{\pi}{2}$</li><li></li></ol><h1 id="session-36"><a href="#session-36" class="headerlink" title="session 36"></a>session 36</h1><h2 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h2><p>今天我们从微分转移到积分.为此，我们需要一个新的量符号，称为微分。</p><p>给一个函数$y &#x3D; f(x)$, y的微分是:</p><p>$$<br>dy &#x3D; f’(x)dx<br>$$</p><p>因为$y &#x3D; f(x)$,我们有时称之为f的微分. $dy和f’(x)dx$都成为微分.你可以将</p><p>$$<br>\frac{dy}{dx} &#x3D; f’(x)<br>$$</p><p>视为微分的商.包括这节课和多元微积分都涉及.这源于莱布尼茨将导数解释为“无穷小”量的比率.微分是一类无穷小量.</p><p>使用微分要比牛顿发明的符号高效的多.好的符号让你想的更快.莱布尼茨的符号在欧洲大陆被采用，牛顿在英国占主导地位;结果，英国人在微积分的发展上落后了一两百年。</p><h3 id="微分和线性近似"><a href="#微分和线性近似" class="headerlink" title="微分和线性近似"></a>微分和线性近似</h3><p>线性近似允许我们根据f(x)和f’(x)的值估计f(x+△x)的值.我们用微分dx替换水平变化量△x.同样的,我们用dy替换高度变化△y</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d925bda2-9dd6-464f-9873-ed724426c809/Untitled.png"                      alt="Untitled"                ></p><h3 id="方法1-使用微分"><a href="#方法1-使用微分" class="headerlink" title="方法1(使用微分)"></a>方法1(使用微分)</h3><p>我们将使用函数$y &#x3D; f(x) &#x3D; x^{\frac{1}{3}}$的线性近似.我们基点$x_0 &#x3D; 64$ 因为好计算$y_0 &#x3D; 64^{\frac{1}{3}} &#x3D; 4$.通过定义.$dy  &#x3D; f’(x)dx &#x3D; \frac{1}{3}x^{-\frac{2}{3}}dx.$</p><p>$$<br>\begin{align}<br>dy  &amp;&#x3D; \frac{1}{3}(64)^{-\frac{2}{3}}dx. \<br>&amp;&#x3D;\frac{1}{48}dx<br>\end{align}<br>$$</p><p>我们想要近似$(64,1)\frac{1}{3}$,所以 x+dx &#x3D; 64.1,dx &#x3D; 0.1 &#x3D; 1&#x2F;10.在$64.1 &#x3D; x_0 +dx$,f(x)刚好等于$y_0 +\triangle y$(因为这是△y定义的方法.)并且大约等于$y_0 +dy$. 其中 dy 在 dx 中是线性的，如上所示。</p><p>本质上,点$(x_0+dx ,y_0 +dy)$是远离点$(x_0,y_0)$无限小步.当然 1&#x2F;10不是无限小,所以我们求处的是近似而不是准确值.</p><p>$$<br>\begin{align}<br>(64.1)^{\frac{1}{3}} &amp;\approx y+dy \<br>&amp;\approx 4+\frac{1}{48}dx \<br>&amp;\approx 4 +\frac{1}{48}\frac{1}{10} \<br>&amp;\approx 4.002</p><p>\end{align}<br>$$</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>当我们将这个和之前的符号比较,我们发现计算是一样的,只有符号变了.</p><p>线性近似的基本公式是:</p><p>$$<br>f(x) &#x3D; f(a) +f’(a)(x-a)<br>$$</p><p>这里 a &#x3D; 64 $f(x) &#x3D; x^{\frac{1}{3}}$,所以f(a) &#x3D; f(64) &#x3D; 4 .$f’(a) &#x3D; 1&#x2F;48$</p><p>近似公式变为:</p><p>$$<br>\begin{align}<br>f(x) &amp;\approx f(a) +f’(a)(x-a)<br>\<br>x^{\frac{1}{3}} &amp;\approx 4+\frac{1}{48}(x-64) \<br>(64.1)^{\frac{1}{3}} &amp;\approx 4+\frac{1}{48}\frac{1}{10} \approx 4.002</p><p>\end{align}<br>$$</p><p>通过进行几乎相同的计算，我们得到了与以前相同的答案。</p><h2 id="使用微分研究人口动态"><a href="#使用微分研究人口动态" class="headerlink" title="使用微分研究人口动态"></a>使用微分研究人口动态</h2><p>我们看到微分给我们一个方便的办法表示线性近似.在这个例子中,我们用微分语言探索人口动态.</p><p>人口动态的一个简单的世代模型表明，初始种群x将产生由函数P（x）给出的下一代种群。之后的下一代是通过“迭代”函数 P 给出的,也就是$p(P(x))$.我们可以,我们可以继续将 P 应用于结果以找到连续几代的人口。特别指出,任何初始人口x会在几代后稳定下来,当满足$P(x) &#x3D; x.$ 这样的x被称为 固定点.</p><p>我们说，如果给定初始总体值 x0 + Δx，并且 Δx 足够小，则不动点 x0 的大小越来越接近 x0，则不动点 x0 是“吸引”的。更正式的说,值的序列:</p><p>$$<br>x_0 +\triangle ,P(x_0 +\triangle x),P(P(x_0 +\triangle x)),P(P(P(x_0 +\triangle x))), \cdot \cdot\cdot<br>$$</p><p>越来越接近$x_0$.</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题:"></a>问题:</h3><ul><li>如果 $x_0 是 P(x)$ 的固定点, 并且 $|P’(x_0)| &lt;1$, 那么 $<code>x_0</code>$ 是吸引的.</li><li>给固定的正常量a,b 并且 $ab&gt;1$, 找到$P(x) &#x3D; ax(b-x)$的固定点.并判断是否是吸引的.</li></ul><h1 id="session-37"><a href="#session-37" class="headerlink" title="session 37"></a>session 37</h1><h2 id="不定积分介绍"><a href="#不定积分介绍" class="headerlink" title="不定积分介绍"></a>不定积分介绍</h2><p>这是一个新的符号,也是一个新的概念.$G(x) &#x3D; \int g(x)dx$ 是 g的不定积分. 另一种说法是</p><p>$$<br>G’(x) &#x3D; g(x)  \quad or, \quad dG &#x3D; g(x)dx<br>$$</p><p>关于这个定义有几件事要注意. 它包括 微分 dx.也包括符号$\int$. 也叫积分号. 表达式$\int g(x)dx$  是一个积分. 不定积分的另一个名字是反导数.(我们很快就会了解不确定在这里的含义).</p><p>如果 $G(x)$ 是g(x)的反导数,那么$G’(x) &#x3D; g(x)$. 为了找到g的反导数(不定积分),我们需要找到一个导数为g的函数.在实践中,找到反导数并不像找到导数那么容易.但我们想积分尽可能多的式子.我们从一些例子开始.</p><h3 id="例子-sinx"><a href="#例子-sinx" class="headerlink" title="例子: sinx"></a>例子: sinx</h3><p>我们从 $g(x) &#x3D; sinx$ 的积分开始.这个函数的的导数是 sinx. 什么函数的导数是 sinx呢?</p><h3 id="学生-cosx"><a href="#学生-cosx" class="headerlink" title="学生: -cosx"></a>学生: -cosx</h3><p>因为 -cosx的导数是sinx. 这是sinx 的一个反导数. 如果 </p><p>$$<br>G(x) &#x3D; -cosx, \quad then \<br>G’(x) &#x3D; sinx<br>$$</p><p>另一方面,如果我们有的是$G(x) &#x3D; -cosx +7$ 我们仍然会有 $G’(x) &#x3D; sinx$ 因为一个常数的导数 是0. 我们可以给G(x) 添加任意常数,仍能获得 sinx的反导数.我们写:</p><p>$$<br>\int sinx dx &#x3D; -cosx +c<br>$$</p><p>并叫它为 sinx 的不定积分因为 $c$  可以为任意常数, 他是一个未定义的值.每当我们取某物的反导数时,我们的答案因为一个常数是模棱两可的.</p><h2 id="x-a-的不定积分"><a href="#x-a-的不定积分" class="headerlink" title="$x^a$的不定积分"></a>$x^a$的不定积分</h2><p>什么函数的导数是$x^a$ ?  我们知道当我们对它函数求导, 他的指数减一,所以我们才$x^{a+1}$. 他不完全对:</p><p>$$<br>d(x^{a+1}) &#x3D; (a+1)x^adx<br>$$</p><p>我们必须两边都除以常数 (a+1) 取得正确的答案</p><p>$$<br>d(\frac{x^{a+1}}{a+1}) &#x3D; x^adx \<br>\frac{x^{a+1}}{a+1} +c &#x3D; \int x^adx<br>$$</p><p>带等一下,尽管 $d(x{a+1}) &#x3D; (a+1)x^adx$是对的,但$\int x^adx &#x3D; \frac{x^{a+1}}{a+1} +c$ 并不总是对的. 当 $a &#x3D; -1$,分母为0,但我们仍然可以说 $\int x^a dx &#x3D; \frac{x^{a+1}}{a+a} +c$  , $a \ne -1$</p><p>如果 a&#x3D;-1 呢? 如果是$\int \frac{1}{x}dx 呢?$ </p><p>到目前为止,我们已经用了函数$\frac{d}{dx} cosx &#x3D; -sinx$ 和 $\frac{d}{dx}x^{n+1} &#x3D; (n+1)x^n$. 积分重要的一点就是 记住导数的公式,然后 “倒着读”. 在这个例子中, 我们需要的公式是$\frac{d}{dx}lnx &#x3D; \frac{1}{x}$.使用这个,我们得到 $\int \frac{1}{x}dx &#x3D; lnx +c$.</p><p>这个式子在x&gt;0时没有问题,但 如果x &lt;0,lnx 是未定义的.更标准的形式是:</p><p>$$<br>\int \frac{1}{x}dx &#x3D; ln|x| +c<br>$$</p><p>当x≥0 绝对值不做任何不改变, 我们只要在x &lt;0时检查式子. 为了这么做,我们必须定义 ln|x|.</p><p>$$<br>\begin{align}</p><p>\frac{d}{dx}ln|x| &amp;&#x3D; \frac{d}{dx}ln(-x) \quad (|x| &#x3D; -x 当 x&lt;0) \<br>&amp;&#x3D;\frac{1}{-x}\frac{d}{dx}(-x) \quad(chain \quad rule)<br>\ &amp;&#x3D;-\frac{1}{-x} \ &amp;&#x3D; \frac{1}{x}</p><p>\end{align}<br>$$</p><p>如果我们画出ln|x|的图像,我们可以看到函数的斜率确实为 1&#x2F;x.</p><h2 id="sec-2x-的不定积分和-frac-1-sqrt-1-x-2"><a href="#sec-2x-的不定积分和-frac-1-sqrt-1-x-2" class="headerlink" title="$sec^2x$ 的不定积分和$\frac{1}{\sqrt{1-x^2}}$"></a>$sec^2x$ 的不定积分和$\frac{1}{\sqrt{1-x^2}}$</h2><h3 id="例子-int-sex-2xdx"><a href="#例子-int-sex-2xdx" class="headerlink" title="例子: $\int sex^2xdx$"></a>例子: $\int sex^2xdx$</h3><p>找不定积分可以帮你记住导数的特殊公式.在这个例子中,你需要记住$\frac{d}{dx}tanx &#x3D; sec^x.$</p><p>$$<br>\int sec^xdx &#x3D; tanx +c<br>$$</p><h3 id="例子-int-frac-1-sqrt-1-x-2-dx"><a href="#例子-int-frac-1-sqrt-1-x-2-dx" class="headerlink" title="例子:$\int \frac{1}{\sqrt{1-x^2}dx}$"></a>例子:$\int \frac{1}{\sqrt{1-x^2}dx}$</h3><p>另一种写法是 $\int \frac{dx}{\sqrt{1-x^2}}$. 这与 dx 是一个无穷小量的想法是一致的,可以像其他书2一样对待.</p><p>我们记得$\frac{d}{dx}sin^{-1}x &#x3D; \frac{1}{\sqrt{1-x^2}}$并得出结论:</p><p>$$<br>\int \frac{dx}{\sqrt{1-x^2}} &#x3D; sin^{-1}x +c<br>$$</p><p>当要求反导数,不定积分,你会花很多时间考虑导数,一段时间你会把两者混起来,对u按本应该微分的积分,或者相反,随着联系,这个额问题逐渐就会消失.这是一些这节课展示的不定积分:</p><ol><li>$\int sinxdx &#x3D; -cosx +c \quad c是常量.$</li><li>$\int x^ndx &#x3D; \frac{x^{n+1}}{n+1}+c \quad n \ne -1$</li><li>$\int \frac{dx}{x} &#x3D; ln|x| +c \quad 针对2中 n&#x3D;-1的情况.$</li><li>$\int sec^2xdx &#x3D; tanx+c \quad$ </li><li>$\int \frac{dx}{\sqrt{1-x^2}}dx &#x3D; sin^{-1}x+c \quad (sin^{-1}表示 sine的反函数或者arcsin)$</li><li>$\int \frac{dx}{1+x^2} &#x3D; tan^{-1}(x)+c \quad$</li></ol><h3 id="不定积分因一个常数而不同"><a href="#不定积分因一个常数而不同" class="headerlink" title="不定积分因一个常数而不同"></a>不定积分因一个常数而不同</h3><h3 id="定理-if-F’-x-x3D-f-x-and-G’-x-x3D-f-x-then-F-x-x3D-G-x-c"><a href="#定理-if-F’-x-x3D-f-x-and-G’-x-x3D-f-x-then-F-x-x3D-G-x-c" class="headerlink" title="定理:$if F’(x) &#x3D; f(x) and G’(x) &#x3D; f(x),then F(x) &#x3D; G(x) +c$"></a>定理:$if F’(x) &#x3D; f(x) and G’(x) &#x3D; f(x),then F(x) &#x3D; G(x) +c$</h3><p>换句话说,一旦我们发现函数的一个反导数,我们知道其他不定积分与这个只会差一个常数.</p><h3 id="证明-if-F’-x3D-G’-then-F-G-’-x3D-F’-G’-x3D-f-f-x3D-0"><a href="#证明-if-F’-x3D-G’-then-F-G-’-x3D-F’-G’-x3D-f-f-x3D-0" class="headerlink" title="证明: if F’ &#x3D; G’ then (F-G)’ &#x3D; F’ -G’ &#x3D; f-f &#x3D; 0"></a>证明: if F’ &#x3D; G’ then (F-G)’ &#x3D; F’ -G’ &#x3D; f-f &#x3D; 0</h3><p>回想一下,我们证明了作为均值定理的推论,如果一个函数的导数是0,那他是一个常数. 因此G(x - F(x)) &#x3D; c 也就是说 G(x) &#x3D; F(x) +c.</p><h1 id="Session-38"><a href="#Session-38" class="headerlink" title="Session 38"></a>Session 38</h1><h2 id="Substitution-带入-int-x-3-x-4-2-5dx"><a href="#Substitution-带入-int-x-3-x-4-2-5dx" class="headerlink" title="Substitution 带入 $\int x^3(x^4+2)^5dx$"></a>Substitution 带入 $\int x^3(x^4+2)^5dx$</h2><p>我们想计算 $\int x^3(x+x^2)^5dx$.</p><p>我们已经有一个公式$\int x^ndx$,所以我们展开$(x^4 +2)^5$  融合 多项式.那样会很乱,相反,我们会使用替换方法.</p><p>找到函数的精确积分要比找到他的导数困难的多.有时候,那时不可能的.这一单元,我们只用一种方法,也就是说无论何时你看到一个积分,你要么可以立刻解出来,要么用替代法.代换法是为微分符号量身定制的.</p><p>为了使用代换法,找到积分中最混乱的函数,在这个例子中,就是 $x^4+2$, u的微分就是 $du &#x3D; u’dx &#x3D; 4x^3dx$. 幸运的是,我们可以将这两个表达式带入原始积分中并大大简化他.</p><p>最初的问题是找到 $\int x^3(x^4 +2)^5 dx$. 我们可以替换$(x^4+2)^5$ 为$u^5$ 然后$x^3dx &#x3D; \frac{1}{4}du$:</p><p>$$<br>\begin{align}</p><p>\int x^3(x^4+2)^5dx &amp;&#x3D; \int(x^4+2)^5x^3dx<br>\&amp;&#x3D;\int \frac{u^5du}{4} \&amp;&#x3D;\frac{1}{4} \cdot \frac{1}{6}u^6 &#x3D; \frac{u^6}{24}<br>\end{align}<br>$$</p><p>这不是问题的答案,因为这个结果用u表示,问题是用x表示的,我们将变量变回x通过u的定义.</p><p>$$<br>\frac{u^6}{24} &#x3D; \frac{(x^4 +2)^6}{24}<br>$$</p><p>我们得出结论:</p><p>$$<br>\int x^3(x^4+2)^5dx&#x3D;\frac{(x^4+2)^6}{24}<br>$$</p><h2 id="通过”高级猜测”积分"><a href="#通过”高级猜测”积分" class="headerlink" title="通过”高级猜测”积分"></a>通过”高级猜测”积分</h2><h3 id="例子-int-frac-xdx-sqrt-1-x-2"><a href="#例子-int-frac-xdx-sqrt-1-x-2" class="headerlink" title="例子: $\int \frac{xdx}{\sqrt{1+x^2}}$"></a>例子: $\int \frac{xdx}{\sqrt{1+x^2}}$</h3><p>如果使用替代方法,我们就用u把最难看的式子带换掉.</p><p>$$<br>u &#x3D; 1+x^2 \quad du &#x3D; 2xdx<br>$$</p><p>计算如下:</p><p>$$<br>\begin{align}<br>\int\frac{xdx}{\sqrt{1+x^2}} &amp;&#x3D; \int\frac{\frac{1}{2}du}{\sqrt{u}}<br>\&amp;&#x3D;\int \frac{u^{-\frac{1}{2}}du}{2}<br>\ &amp;&#x3D; u^{\frac{1}{2}}+c<br>\ &amp;&#x3D;\sqrt{1+x^2}+c<br>\end{align}<br>$$</p><p>一个更好的计算方法是”高级猜想”.一旦你做了足够多的问题,你就会知道会发生什么.你可以看着分母上的$\sqrt{1+x^2}$并猜测答案包括 $(1+x^2)^{1&#x2F;2}$.一旦你做出猜想,对她求导看是否成立.</p><p>$$<br>\begin{align}<br>\frac{d}{dx}(1+x^2)^{\frac{1}{2}} &amp;&#x3D; \frac{1}{2}(1+x^2)^{-\frac{1}{2}}(2x)<br>\&amp;&#x3D;\frac{x}{\sqrt{1+x^2}}<br>\end{align}<br>$$</p><p>就像你看到的,用这个方法,我们很快确定:</p><p>$$<br>\int \frac{xdx}{\sqrt{1+x^2}} &#x3D; (1+x^2)^{1&#x2F;2} +c<br>$$</p><p>我们很推荐这个方法,但他需要慢慢习惯.</p><h3 id="例子-int-e-6x-dx"><a href="#例子-int-e-6x-dx" class="headerlink" title="例子:$\int e^{6x}dx$"></a>例子:$\int e^{6x}dx$</h3><p>我们知道$e^x$的倒数是$e^x$, 所以我们猜是$e^{6x}$,然后我们用链式法则检查猜测:</p><p>$$<br>\frac{d}{dx}(e)^{6x} &#x3D; e^{6x}(6) &#x3D; 6e^{6x}<br>$$</p><p>这里有一个b不在我们计算的积分中,所以我们应该把我恩德答案除以6.</p><p>$$<br>\int e^{6x}dx  &#x3D;\frac{1}{6}e^{6x} +c<br>$$</p><p>我们也可以用替换u &#x3D; 6x,他也可以解出,但会花费更久.</p><h1 id="Session-39"><a href="#Session-39" class="headerlink" title="Session 39"></a>Session 39</h1><h2 id="常微分方程简介"><a href="#常微分方程简介" class="headerlink" title="常微分方程简介"></a>常微分方程简介</h2><p>MIT有关于微分方程的一整节课程 18.03, 然而, 那是使用微分很好的解决我们对积分一直在做的事情的技术,我们在这里讨论.</p><p>最简单的微分方程就像$\frac{dy}{dx} &#x3D; f(x)$. 这个方程的解是反导数(积分)$y &#x3D; \int f(x)dx$. 我们目前只假设我们永远可以解出来. </p><p>现在我们只知道用替换的方法解 积分问题(包括”高级猜想”).</p><h3 id="例子-frac-d-dx-x-y-x3D-0-quad-or-quad-frac-d-dx-xy-x3D-0"><a href="#例子-frac-d-dx-x-y-x3D-0-quad-or-quad-frac-d-dx-xy-x3D-0" class="headerlink" title="例子:$(\frac{d}{dx} +x)y &#x3D; 0 \quad (or \quad \frac{d}{dx} +xy &#x3D; 0)$"></a>例子:$(\frac{d}{dx} +x)y &#x3D; 0 \quad (or \quad \frac{d}{dx} +xy &#x3D; 0)$</h3><p>这是我们第一个微分方程的有趣例子.  运算$(\frac{d}{dx} +x)$ 在量子力学中叫湮灭算子.这也是控制谐波振荡器基态的方程,并且他相对容易解出.</p><p>解出它的第一步是重写方程,分理处 $\frac{dy}{dx}$:</p><p>$$<br>\begin{align}<br>(\frac{d}{dx}+x)y &amp;&#x3D;0<br>\ \frac{dy}{dx} + xy &amp;&#x3D;0<br>\ \frac{dy}{dx} &amp;&#x3D; -xy<br>\end{align}<br>$$</p><p>这个例子和我们学的反导数最大的不同是变化率取决于x和y两者.我们还没有解决这种方程的方法.</p><p>然而,事实证明,我们可以使用微分和莱布尼兹符号来解决这个问题.关键步骤是分离变量让所有和y有关的项在等式一边,所有有关x的项在等式另一边.</p><p>$$<br>\frac{dy}{y} &#x3D; -xdx<br>$$</p><p>因为问题现在基于微分,而不是差分比率(改变率).因为这个，我们可以利用莱布尼兹符号的优势，对等式两边积分。注意，在左侧微分变量是y，在右边变量是x。</p><p>$$<br>\int \frac{dy}{y}  &#x3D; - \int \frac{}{}xdx<br>$$</p><p>$$<br>\begin{align}</p><p>lny +c_1 &amp;&#x3D; - \frac{x^2}{2} +c_2 \quad \text{(assume y &gt;0)}<br>\lny &amp;&#x3D;-\frac{x^2}{2} +c \quad \text{(we only need one constant c &#x3D; c2-c1)}<br>\ y &amp;&#x3D;e^{c+(-\frac{x^2}{2})}<br>\y &amp;&#x3D;Ae^{-\frac{x^2}{2}}\quad (A &#x3D; e^c)<br>\end{align}<br>$$</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/83898f5a-5956-4cc2-8b02-2343902a79c8/Untitled.png"                      alt="Untitled"                ></p><p>结果是 $y &#x3D; ae^{-\frac{x^2}{2}}$,对于任意 常数倍数a，尽管事实上$e^c \ne 0$.  我们可以用微分来检查这个结果。</p><p>$$<br>\begin{align}<br>y &amp;&#x3D; ae^{\frac{-x^2}{2}}<br>\ \frac{dy}{dx} &amp;&#x3D; \frac{d}{dx} ae^{\frac{-x^2}{2}}<br>\ &amp;&#x3D;ae^{\frac{-x^2}{2}} \cdot -x<br>\ &amp;&#x3D;y \cdot -x<br>\ \frac{dy}{dx} &amp;&#x3D; -xy<br>\end{align}<br>$$</p><p>这与我们第一步 $\frac{dy}{dx}$的等式匹配 . 所以 $y &#x3D; ae^{\frac{-x^2}{2}}$是我们微分方程的解. 我们在计算中没有猜测a的值.所以不管a是多少,这都是解.a &#x3D; 0 与所有a ≠0一起是可能的. 取决于最初条件.例如,如果 y(0) &#x3D; 1, 那么 </p><p>$y &#x3D;e^{-x^2&#x2F;2}$, 如果y(0) &#x3D;a, 那么$y &#x3D;ae^{-x^2&#x2F;2}$ </p><p><strong>这个函数也叫 标准正态分布,你会在概率论中看到</strong>. 在量子力学中,他帮助描述粒子位置.</p><p>微分方程的目的是解处他们.就像代数方程. 通常,微分方程告诉你关于加速度和速度之间的平衡. 例如,如果你在做空气阻力相关的计算, 有时在应用问题中,写出一个描述情况的微分方程是非常重要的.为了确定你选择了对了方程,你必须用现实世界发生的去确定你的答案.</p><h3 id="问题-我们不知道a是几怎么能说-y-x3D-ae-x-2-x2F-2-是我们的最终答案"><a href="#问题-我们不知道a是几怎么能说-y-x3D-ae-x-2-x2F-2-是我们的最终答案" class="headerlink" title="问题: 我们不知道a是几怎么能说$y &#x3D;ae^{-x^2&#x2F;2}$ 是我们的最终答案?"></a>问题: 我们不知道a是几怎么能说$y &#x3D;ae^{-x^2&#x2F;2}$ 是我们的最终答案?</h3><h3 id="回答-1"><a href="#回答-1" class="headerlink" title="回答:"></a>回答:</h3><p>我们叫$y &#x3D;ae^{-x^2&#x2F;2}$ 为通解,换句话说,通过选择不同a的值得到的解集就是问题的答案.</p><p>通常,我们会有更多的信息,而不只是方程$(\frac{d}{dx}+x)y &#x3D;0$ .例如 我们也许知道当x&#x3D;0,有y&#x3D;3.通过额外的信息,我们可以准确确定那个函数是解决方案.</p><p>如果我们没有额外的信息限制我们的答案为单一函数,那么解就不是一个函数,而是通过不同参数a的值描述的解的集合.</p><h3 id="问题-你可以解出x而不是y吗"><a href="#问题-你可以解出x而不是y吗" class="headerlink" title="问题: 你可以解出x而不是y吗?"></a>问题: 你可以解出x而不是y吗?</h3><h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案:"></a>答案:</h3><p>可以,你会得到这个函数的反函数.有时我们只需要一个隐式函数,有时我们坚持x是y的函数.指定解决方案的方式可能很复杂,你马上会看到, 但把y想成x的函数不是必须得.</p><h2 id="分离变量"><a href="#分离变量" class="headerlink" title="分离变量"></a>分离变量</h2><p>现在我们看看我们用来解决上一个问题的技术,并探讨将该方法还能用于那些其他问题.</p><p>总的来说分离变量法可以用的微分方程可以写作:</p><p>$$<br>\frac{dy}{dx} &#x3D; f(x)g(y)<br>$$</p><p>在我们之前的例子中, f(x) &#x3D; -x, g(y) &#x3D; y.</p><p>这个方法的关键是分离变量.我们可以这样是因为莱布尼兹发明了他的符号,让这样做很简洁.允许我们将微分计算视为普通计算.</p><p>$$<br>\begin{align}<br>\frac{dy}{dx} &amp;&#x3D; f(x)g(y)<br>\ \frac{dy}{g(y)} &amp;&#x3D; f(x)dx<br>\ h(y)dy &amp;&#x3D; f(x)dx \quad \text{where }h(y) &#x3D; \frac{1}{g(y)}</p><p>\end{align}<br>$$</p><p>下一步,我们对两边求反导数</p><p>$$<br>H(y) &#x3D; \int h(y)dy; \quad F(x) &#x3D; \int f(x)dx<br>$$</p><p>在我们的例子中 $H(y) &#x3D; ln|y| ,F(x) &#x3D; \frac{-x^2}{2}$.</p><p>这些反导数相等,所以我们有:</p><p>$$<br>H(y) &#x3D; F(x)+c \quad \text{Again ,我们只要一个c}<br>$$</p><p>我们称之为隐式方程,在我们例子中有$lny &#x3D; -x^2&#x2F;2 +c$ ,他没有准确告诉我们y是什么,但它隐式的描述了y. 为了显式解出y,我们需要反函数$H^{-1}$; 在我们的例子中,这个反函数是指示函数 ,显式方程是$y &#x3D;ae^{-x^2&#x2F;2}$ </p><p>在实践中, 隐式方程很容易找,但做反函数操作会很复杂.那样的话,我们会直接以隐函数作为答案.</p><h3 id="摘要1"><a href="#摘要1" class="headerlink" title="摘要1:"></a>摘要1:</h3><p>在例子中,我们可以写做$ln|y| &#x3D; -x^2&#x2F;2 +c$ , y≠0, 那么我们有  $|y| &#x3D;ae^{-x^2&#x2F;2}$ 或者 $y &#x3D;\pm ae^{-x^2&#x2F;2}$, 这与我们的答案几乎一致, 如果 $a &#x3D;  \pm A, A &gt;0$.</p><p>jerison 教授没有费事这么做因为这让计算很复杂.一旦他解出 y&gt;0的部分 ,他从之前的经验得到答案会是什么样,然后直接跳过然后去检查结果.(指数函数会经常出现,所以你也会想舒服的解决他们.)  </p><p>这仍然忽略了 y&#x3D;0的情况,这是一个非常无聊的解决方案,但仍然是这个问题的一个解.你可以通过y&#x3D;0带入$(\frac{d}{dx} +x)y &#x3D; 0 或者 \frac{dy}{dx} &#x3D; -xy$.</p><p>我们错过这个解并不令人惊讶,因为在分离变量过程中,我们除以y,  如果你除以一个数等于0的数会遇到一些问题.,或错过那个解.为了避免这些问题, 记下何时除以可能等于0的数,并完成计算后仔细检查该情况.</p><h3 id="摘要2"><a href="#摘要2" class="headerlink" title="摘要2:"></a>摘要2:</h3><p>我们有 </p><p>$$<br>\int h(y)dy &#x3D; \int f(x)dx<br>$$</p><p>变化为:</p><p>$$<br>H(y)&#x3D; F(x) +c<br>$$</p><p>左右两边都有随意常量和这样写等价.</p><h3 id="摘要3"><a href="#摘要3" class="headerlink" title="摘要3:"></a>摘要3:</h3><p>在我们的例子中,可加的常量c变为可乘的A.一般来说微分方程的解中总会有一个自由常量,但这个常量并不总是可加的. </p><h1 id="Session40"><a href="#Session40" class="headerlink" title="Session40"></a>Session40</h1><h2 id="微分方程和斜率-part1"><a href="#微分方程和斜率-part1" class="headerlink" title="微分方程和斜率 part1"></a>微分方程和斜率 part1</h2><p>一个曲线在每个点(x,y)的斜率是从原点到这点射线斜率的两倍. 找到这个曲线的一般方程.</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc6c3a0c-f072-4dd3-a268-ef2fed2dad56/Untitled.png"                      alt="Untitled"                ></p><p>这种类型的问题可以用微分方程非常简洁的描述. 切线的斜率是$\frac{dy}{dx}$. 从(0,0) 到(x,y)的射线的斜率是$\frac{y}{x}$.可以得到微分方程:</p><p>$$<br>\frac{dy}{dx} &#x3D; 2(\frac{y}{x})<br>$$</p><p>我们只有之中解决微分方程的方法,使用它:</p><p>$$<br>\begin{align}</p><p>\frac{dy}{dx} &amp;&#x3D; 2\frac{y}{x}<br>\ \frac{dy}{y} &amp;&#x3D; \frac{2dx}{x} \quad (separate variables)<br>\ \int\frac{dy}{y} &amp;&#x3D; \int \frac{2dx}{x} \quad(两边积分)<br>\ln|y| &amp;&#x3D; 2ln|x| +c \quad (反导数)<br>\ |y| &amp;&#x3D; e^cx^2<br>\end{align}<br>$$</p><p>结果中有绝对值 ,当 y&gt;0,我们有 $y &#x3D; e^cx^2$. 当 y &lt;0,  我们有 $y &#x3D; -e^cx^2$. 基于之前的经验,我们才结果会是 $y &#x3D; ax^2, \quad a &#x3D; \pm e^c \quad or  \quad a &#x3D; 0$.</p><p>因为我们计算中 除以y,所以我们的结果不包括a&#x3D;0,也就是 $y &#x3D; 0x^2$. 画出y&#x3D;0并确定也满足条件,所以确定这也是一个解.</p><p>我们总结这个问题的通解是</p><p>$$<br>y&#x3D; ax^2<br>$$</p><p>a可以为负,可以为正,可以为0.</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9e2ed5f2-a0db-4708-b15b-a001750e647d/Untitled.png"                      alt="Untitled"                ></p><p>如果我们想要检查我们的工作,我们可以通过求导带入.</p><p>注意: 在方程$\frac{dy}{dx} &#x3D; 2(\frac{y}{x})$中, 右侧在x&#x3D;0时无定义. 你可以从图二看出知道函数的值和导数,在x&#x3D;0不能告诉我们函数在其他地方的行为. 这很糟糕,这和我们对线性近似的理解矛盾.</p><p>出错的地方在x&#x3D;0时变化率没有说明,如果你仔细想这个函数在干什么, 当x 0 他可能跟随一个分支,当x&gt;0它可能跟随一个完全不同的分支.这是一个非常巧妙地观点,你不会被要求在家庭作业中讨论这个问题,但你应该知道,当x&#x3D;0时,这个微分方程有问题.</p><h1 id="Session-41"><a href="#Session-41" class="headerlink" title="Session 41"></a>Session 41</h1><h2 id="Review-for-Exam-2"><a href="#Review-for-Exam-2" class="headerlink" title="Review for Exam 2"></a>Review for Exam 2</h2><p>Exam2 通常是课程最难得部分, 包括的话题有:</p><ol><li>线性和二阶近似</li><li>画出 y&#x3D;f(x)</li><li>最大值,最小值问题</li><li>相关率</li><li>反导数(积分)分离变量</li><li>均值定理</li></ol><p>你也应该做一些相关题目让自己熟悉这类问题.</p><p>总之,这单元的关于导数应用的主题是,关于导数的信息为我们提供了有关函数本身的信息.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;session-34&quot;&gt;&lt;a href=&quot;#session-34&quot; class=&quot;headerlink&quot; title=&quot;session 34&quot;&gt;&lt;/a&gt;session 34&lt;/h1&gt;&lt;h2 id=&quot;均值定理&quot;&gt;&lt;a href=&quot;#均值定理&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2.Part B Optimization,Related Rates and Newton’s Method</title>
    <link href="http://example.com/[object%20Object]/2023/02/19/calculus18d01/"/>
    <id>http://example.com/[object%20Object]/2023/02/19/calculus18d01/</id>
    <published>2023-02-19T02:59:29.000Z</published>
    <updated>2023-04-09T16:09:10.697Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p><a class="link"   href="https://ocw.mit.edu/courses/18-01sc-single-variable-calculus-fall-2010/" >https://ocw.mit.edu/courses/18-01sc-single-variable-calculus-fall-2010/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>@ToDo<br>  LaTex支持<br>  图片加载</p><h1 id="Session-30"><a href="#Session-30" class="headerlink" title="Session 30"></a>Session 30</h1><p>隐式微分和最小值,最大值</p><h3 id="问题-固定体积的盒子怎么才能有最小的表面积-盒子没有顶部"><a href="#问题-固定体积的盒子怎么才能有最小的表面积-盒子没有顶部" class="headerlink" title="问题: 固定体积的盒子怎么才能有最小的表面积,盒子没有顶部."></a>问题: 固定体积的盒子怎么才能有最小的表面积,盒子没有顶部.</h3><p>另一个解决这个问题的方法是隐式导数, 我们给出前提 底面是正方形,</p><p>我们以同样的方式开始</p><p>$$<br>V &#x3D; x^2y, \quad A&#x3D;x^2 +4xy<br>$$</p><p>目标是找到A的最小值,V是常量</p><p>下一步我们求导</p><p>$$<br>\frac{d}{dx}V &#x3D; 2xy +x^2\frac{dy}{dx} \implies 0 &#x3D; 2xy + x^2y<br>$$</p><p>所以$y’ &#x3D; -\frac{2y}{x}$ </p><p>$$<br>\frac{dA}{dx} &#x3D; 2x +4y +4xy’<br>$$</p><p>当我们把$y’ &#x3D; -\frac{2y}{x}$ 带入,我们得到</p><p>$$<br>\frac{dA}{dx}  &#x3D;  2x + 4y + 4x(-\frac{2y}{x}) &#x3D; 2x +4y -8y<br>$$</p><p>$$<br>\frac{dA}{dx} &#x3D; 2x - 4y<br>$$</p><p>为了找到关键点,我们设 $\frac{dA}{dx} &#x3D; 0$ 我们得到 $0 &#x3D; 2x -4y$ 所以</p><p>$$<br>\frac{x}{y} &#x3D; 2<br>$$</p><p>所以我们可以得到底面边长和高的比例为2的时候,表面积最小. ,这是一个无量纲量,不会因为单位变化而变化.</p><p>缺点是,我们没办法检验这个关键点是最大值还是最小值.</p><h3 id="怎么检查呢"><a href="#怎么检查呢" class="headerlink" title="怎么检查呢?"></a>怎么检查呢?</h3><p>通过观察 A(0+) 和A(无穷) 或者通过你的直觉,是一个底很小的长盒子表面积大还是相反呢?</p><h2 id="问题-罐头设计"><a href="#问题-罐头设计" class="headerlink" title="问题:罐头设计"></a>问题:罐头设计</h2><p>在食品包装中有很多要考虑的因素,包括市场,可持续性,成本和材料,这个问题中我们最小化一个罐子的成本.</p><p>一个体积为1000cm³的罐子,找到他的高和半径,使得表面积最小</p><h1 id="Session-31"><a href="#Session-31" class="headerlink" title="Session 31"></a>Session 31</h1><p>相关比率介绍</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h3><p>考虑一个锥形罐子,灌顶半径为4feet,整个的高度为10feet,以2立方尺每分的速率注水,当水深5feet的时候,水升高的速度为多少?</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eba9d381-63ee-4965-ab68-de3a5cdf15ee/Untitled.png"                      alt="Untitled"                ></p><p>这个图会帮我们思考,例如,角很窄,所以高度的变化率不同,我们需要反应水位,我们还发现画一个精确地三维图很困难,一个简单的二维图也许会有帮助.</p><p>关键是画一个二维截面图, </p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a81f3515-0a69-4606-aac7-1560074a988e/Untitled.png"                      alt="Untitled"                ></p><p>我们会用变量r代表睡眠顶部从中心到边的距离,h代表水位高度.我们会发现r和h可以用相似三角形.</p><p>$$<br>\frac{r}{h} &#x3D; \frac{4}{10}<br>$$</p><p>我们的目标是找到当水到一半深的时候水上升的速度.我们知道的是水箱中水体积的变化速度是2立方尺每分钟, 我们需要水箱中水量和水的深度联立出方程</p><p>水箱的体积是:</p><p>$$<br>V &#x3D; \frac{1}{3} \cdot\pi r^2 \cdot h<br>$$</p><p>这个公式将体积和半径和高度连立起来,我们又知道半径和高度的关系,我们还有另一个可以用的信息</p><p>$$<br>\frac{dV}{dt} &#x3D; 2<br>$$</p><p>问题是 当h &#x3D; 5时, $\frac{dh}{dt}$是多少?</p><p>我们已经将描述中的所有信息转化为公式, </p><p>我们可以通过隐式微分解决问题,但是用h解决r很容易.</p><p>$$<br>r &#x3D; \frac{2}{5}h<br>$$</p><p>我们将公式带入V得到</p><p>$$<br>V &#x3D; \frac{1}{3}\pi(\frac{2}{5}h)^2 &#x3D; \frac{4}{3(25)}\pi h^3<br>$$</p><p>这个时候,我们可以解出h,但那是个糟糕的主意,隐式微分要更容易</p><p>$$<br>\frac{dV}{dt} &#x3D;\frac{dV}{dh}\frac{dh}{dt} &#x3D; \frac{\pi}{3}(\frac{2}{5})^23h^2\frac{dh}{dt} &#x3D; \frac{4}{25}\pi h^2h’<br>$$</p><p>我们将 $\frac{dV}{dt} &#x3D; 2, h&#x3D;5$ 带入得到 $h’ &#x3D; \frac{1}{2\pi}$</p><p>我们有水箱中水量变化的比率,要求水箱中水位上升的速度,关键点在于利用链式法则</p><p>$$<br>\frac{dV}{dt} &#x3D;\frac{dV}{dh}\frac{dh}{dt}<br>$$</p><p>相关率变化的问题的关键都在以应用链式法则解决问题.</p><h2 id="问题-用隐式微分求解优化问题"><a href="#问题-用隐式微分求解优化问题" class="headerlink" title="问题:用隐式微分求解优化问题"></a>问题:用隐式微分求解优化问题</h2><p>假设你要建设一个体积为V的粮仓,该粮仓由钢桶和半球形屋顶组成.覆盖桶表面的钢板非常昂贵,所以你希望最小化筒仓表面积,对给定V,筒仓的高和半径因为多少?</p><p>尽管这个问题的解法可以使用和罐头设计的解法相同,但用$\frac{d}{dr}SA$隐式微分更容易.</p><p>针对以下两种问题回答</p><p>a) 带有圆形地板的筒仓(放置地鼠进入)</p><p>b) 没有内置地板的筒仓(没有地鼠的区域使用)</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h3><p>我们的首要任务是绘制筒仓的草图,浙江也有助于我们找到总表面积喝体积.筒仓有半径r和高h.</p><p>a) 有地面的筒仓</p><p>所以表面积为</p><p>$$<br>SA &#x3D; 2\pi rh + 2\pi r^2 +\pi r^2 &#x3D; 2\pi rh + 3\pi r^2<br>$$</p><p>体积为</p><p>$$<br>V &#x3D; \pi r^2h + \frac{2}{3}\pi r^3<br>$$</p><p>我们可以利用这个公式求出$h &#x3D; \frac{2r}{3} - \frac{V}{\pi r^2}$ 然后代入表面积公式求导,但计算很复杂. 我们可以用另一种方法,隐式微分求解</p><p>$$<br>SA &#x3D; 2\pi rh &#x3D; 3\pi r^2 \<br>\frac{d}{dr} SA &#x3D; 2\pi h + 2\pi r \frac{dh}{dr} +6\pi r \qquad ①<br>$$</p><p>我们对体积公式用隐式微分</p><p>$$<br>V &#x3D; \pi r^2h + \frac{2}{3}\pi r^3<br>$$</p><p>$$<br>0 &#x3D; h’\pi r^2 + 2\pi rh +2\pi r^2 \<br>h’ &#x3D; -2\frac{h+r}{r}<br>$$</p><p>带入①式得</p><p>$$<br>\begin{align}<br>\frac{d}{dr} SA &amp; &#x3D; 2\pi h + 2\pi r (-2\frac{h+r}{r}) +6\pi r \<br>&amp; &#x3D;-2\pi h + 2\pi r</p><p>\end{align}<br>$$</p><p>令 $\frac{d}{dr} SA &#x3D; 0$ , 得到 $h &#x3D;r &#x3D; ^3\sqrt{\frac{3V}{5\pi}}$</p><p>这是最小值吗? 没有其他的关键点,极限是高而薄的筒仓,表面积非常大或小</p><p>使用体积V以求r的公式后我们知道 h&#x3D;0时,我们带入得到</p><p>$$<br>SA &#x3D; ^3\sqrt{\frac{243V^2\pi}{4}}<br>$$</p><p>当$h &#x3D;r &#x3D; ^3\sqrt{\frac{3V}{5\pi}}$,</p><p>$$<br>SA &#x3D; ^3\sqrt{9V^2\pi}<br>$$</p><p>结论是r&#x3D;h时有最小的表面积.</p><p>实际上我们计算出的筒仓是一个矩形,更像一个水箱或油桶,现实生活中高而薄的筒仓为农田流出空间.</p><p>b)不带底的筒仓</p><p>同理计算即可,最后得出 h&#x3D;0,说明当筒仓只有上部分半圆的时候可以达到最小表面积.</p><hr><h1 id="Session-32-Ring-on-a-String"><a href="#Session-32-Ring-on-a-String" class="headerlink" title="Session 32 Ring on a String"></a>Session 32 Ring on a String</h1><p>我们在做一个最大值,最小值的问题</p><p>考虑一个被点(0,0) 和点(a,b)固定的绳子上的一个圆环,</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f1141ea7-8d60-4936-bb7e-7aae9f0207e8/Untitled.png"                      alt="Untitled"                ></p><p>圆环可以自由滑动到任一点,找到圆环滑动到的点(x,y).</p><p>请注意, 如果b &#x3D; 0,如果两端在同一高度,圆环会停在两端的中间($x &#x3D; \frac{a}{2}$),我们可以通过物理实验验证这点.我们现在想通过数学来解释结果.这个问题有趣的原因之一是在做悬桥时,这个问题必须被考虑.</p><h3 id="物理原理"><a href="#物理原理" class="headerlink" title="物理原理:"></a>物理原理:</h3><p>圆环停在最低点(最低势能),所以问题是在约束下(x,y)在弦上的y最小值是多少?</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制:"></a>限制:</h3><p>弦的长度L固定了</p><p>$$<br>\sqrt{x^2 + y^2} + \sqrt{(x-a)^2 +(y-b)^2} &#x3D; L.<br>$$</p><p>函数y&#x3D;y(x) 在以上约束方程隐式确定.</p><p>我们在图中描述了约束曲线(环的可能位置) 这条曲线是有焦点(0,0)和(a,b)的椭圆,但知道这单并不有利于我们找到最低点.</p><p>实验表明环位于x&#x3D;0和x&#x3D;a之间(这是我们可以确定最小点不在弦的一端的方法,不要用二阶导测试).因为约束曲线两端高于中间,最低点是一个关键点.(y’(x) &#x3D;0的点),在课堂上我们还通过绘制最低点水平切线来确定这点.</p><p>为了确定这单,对约束方程隐式求导.</p><p>图中最后一个方程我们可以几何解读为:</p><p>$$<br>sin\alpha &#x3D;sin\beta \implies\alpha &#x3D; \beta<br>$$</p><p>α和β是左侧弦和右侧与垂直部分形成的夹角.</p><h3 id="物理和几何结论"><a href="#物理和几何结论" class="headerlink" title="物理和几何结论:"></a>物理和几何结论:</h3><p><strong>角α和β相等.</strong></p><p>使用向量计算计算重力在弦的两端的分力,人们发现弦的两半有相等的张力,———物理平衡. 这在建筑中是可取的,如果一端比另一端承受更多的力,他可能会断裂.</p><p>另一方面,等角属性表达了椭圆的几何属性:假设椭圆是一个镜子,来自焦点(0,0)的光线根据规则反射,入射角等于反射角,因此光线直接射向另一个焦点(a,b)这在 1990 年代初在德科尔多瓦博物馆的“天才之笔：艺术家的迷你高尔夫”展览中得到了很好的效果;通过将三通放在椭圆的一个焦点上，将孔放在另一个焦点上,一位艺术家创造了一个高尔夫球场，任何击球都会以一个洞结束。</p><h3 id="x和y的公式"><a href="#x和y的公式" class="headerlink" title="x和y的公式"></a>x和y的公式</h3><p>我们还没有找到(x,y)的位置我们现在来看看</p><p>$$<br>x &#x3D; \dfrac{a}{2}(1-\dfrac{b}{\sqrt{L^2 - a^2}}), \quad y &#x3D; \frac{1}{2}(b - \sqrt{L^2 -a^2})<br>$$</p><p>因为 α &#x3D; β</p><p>$$<br>x &#x3D; \sqrt{x^2 + y^2}sin\alpha; \quad a-x &#x3D; \sqrt{(x-a)^2 + (y-b)^2}sin\alpha<br>$$</p><p>将这连个等式加起来:</p><p>$$<br>a &#x3D; (\sqrt{x^2 +y^2} +\sqrt{(x-a)^2 + (y-b)^2})sin\alpha &#x3D; Lsin\alpha \implies sin\alpha &#x3D; \frac{a}{L}<br>$$</p><p>直角三角形的垂直边的方程是 (注意y &lt; 0):</p><p>$$<br>-y &#x3D; \sqrt{x^2 +y^2}cos\alpha; b-y &#x3D; \sqrt{(x-a)^2 + (y-b)^2}cos \beta<br>$$</p><p>将两个式子相加然后使用 α &#x3D; β得到</p><p>$$<br>b-2y &#x3D; (\sqrt{x^2 +y^2} +\sqrt{(x-a)^2 +(y-b)^2})cos\alpha &#x3D; Lcos\alpha \<br>\implies \<br>y &#x3D; \frac{1}{2}(b - Lcos\alpha)<br>$$</p><p>使用 关系$\alpha &#x3D; \frac{a}{L}$得到:</p><p>$$<br>\begin{align}<br>Lcos \alpha &amp;&#x3D;L\sqrt{1-sin^2\alpha} \<br>&amp;&#x3D;\sqrt{L^2 - a^2}<br>\end{align}<br>$$</p><p>然后得出</p><p>$$<br>y &#x3D; \frac{1}{2}(b-\sqrt{L^2 -a^2})<br>$$</p><p>最后,要求x,使用类似的直角三角形</p><p>$$<br>tan\alpha &#x3D; \frac{x}{-y} &#x3D; \frac{a-x}{b-y} \implies x(b-y) &#x3D; (-y)(a-x) \implies (b-2y)x &#x3D; -ay<br>$$</p><p>因此</p><p>$$<br>x &#x3D; \frac{-ay}{b-2y} &#x3D; \frac{a}{2}(1- \frac{b}{\sqrt{L^2-a^2}})<br>$$</p><p>至此,我们已经用a,b和L表示了L</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语:"></a>结语:</h3><p>在 18.02 中，您将学习如何使用称为拉格朗日乘数的方法处理任意数量变量中的约束最大&#x2F;最小值问题</p><h1 id="Session-33"><a href="#Session-33" class="headerlink" title="Session 33"></a>Session 33</h1><h2 id="牛顿方法"><a href="#牛顿方法" class="headerlink" title="牛顿方法"></a>牛顿方法</h2><p>牛顿方法在解形式为$f(x) &#x3D; 0$的方程时是很有用的工具.</p><p><strong>举例</strong>: 解决 $x^2 &#x3D; 5$</p><p>我们用牛顿的方法找到$\sqrt{5}$的近似.,任何你理解的方程都能用这种方法解.为了用牛顿的方法,我们定义 $f(x) &#x3D; x^2 +5$. 通过找到f(x) &#x3D;0时x的值,我们解出 $x^2 &#x3D; 5$.</p><p>我们的目标是找到图像在哪穿过x轴,我们首先猜$x_0 &#x3D; 2,因为\sqrt{5} \approx \sqrt{4} &#x3D; 2$ .这个猜测并不准确,f(2) &#x3D; -1, 我们再找f(x)&#x3D; 0的值,我们改善我们的猜想.</p><p>我们假设函数是线性的,不找到$x_0$ 处函数的切线穿过x轴.看图像,$(x_1,0)$  这一点给我们一个新的猜想.</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/332e4ba3-501a-4e8a-94bf-72d14aeef7ad/Untitled.png"                      alt="Untitled"                ></p><p>切线的方程是</p><p>$$<br>y - y_0 &#x3D; m(x - x_0)<br>$$</p><p>当切线截取x轴时,y&#x3D;0, x1是我们的新猜想</p><p>$$<br>\begin{align}<br>-y_0 &amp;&#x3D; m(x-x_0)\<br>-\frac{y_0}{m} &amp;&#x3D; x_1 - x_0 \<br>x_1 &amp;&#x3D; x_0 - \frac{y_0}{m}<br>\end{align}<br>$$</p><p>用f表示:</p><p>$$<br>y_0 &#x3D; f(x_0) \<br>m &#x3D; f’(x_0)<br>$$</p><p>因为m是y&#x3D;f(x)在点$(x_0,y_0)$处切线的斜率</p><p>$$<br>x_1 &#x3D; x_0 -\frac{f(x_0)}{f’(f_0)}<br>$$</p><p>牛顿方法的重点是我们可以通过不断重复上面得步骤来改善答案为了得到我们的$(n+1)^{st}$猜想,我们将这个公式应用于我们的第n个猜想</p><p>$$<br>x_{n+1} &#x3D; x_n -\frac{f(x_n)}{f’(f_n)}<br>$$</p><p>在我们的例子中,$x_0 &#x3D; 2, \quad f(x) &#x3D; x^2 -5, \quad f’(x) &#x3D; 2x$ ,因此</p><p>$$<br>x_1 &#x3D; x_0 - \frac{(x_0^2-5)}{2x_0} &#x3D; \frac{1}{2}x_0 + \frac{5}{2x_0}<br>$$</p><p>主要思想是不断重复这个过程:</p><p>$$<br>x_2 &#x3D; &#x3D; \frac{1}{2}x_1 + \frac{5}{2x_1} \<br>x_2 &#x3D; &#x3D; \frac{1}{2}x_2 + \frac{5}{2x_2}<br>$$</p><p>一直下去,该过程会非常接近$\sqrt{5}$</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/82e74e01-1b6d-4fd7-bfc8-42b7e4474761/Untitled.png"                      alt="Untitled"                ></p><p>注意到每次迭代时,精度的位数都会翻倍.$x_2$已经可以达到你的要求,$x_3$ 和计算机显示的一样好.</p><h2 id="牛顿方法继续"><a href="#牛顿方法继续" class="headerlink" title="牛顿方法继续"></a>牛顿方法继续</h2><p>今天我们来讨论牛顿法的准确性.</p><p>回忆牛顿法怎么工作:为了找到图像在那里穿越x轴, 你在和x轴相交处做一个简单的猜测$x_0$</p><p>然后你知道$x_0$处切线用来改善你的答案:$x_1$是切线与x轴的交点.现在你可以画出$x_1$处切线然后做出新的猜测$x_2$,一直下去.</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1e1e135a-7352-41c1-bf7f-581e5cbda158/Untitled.png"                      alt="Untitled"                ></p><p>用代数术语来讲</p><p>$$<br>x_1 &#x3D; x_0 -\frac{f(x_0)}{f’(x_0)}\quad x_{k+1} &#x3D; x_k -\frac{f(x_k)}{f’(x_k)}<br>$$</p><p>如果我们用这种方式获得近似解,我们要知道它的精确度是多少.如果 x是 精确地答案,那么 $x_1$就离准确值差了 $E_1 &#x3D; |x-x_1|$,我们第n步的误差为$E_n &#x3D; |x-x_n|$ </p><p>上次我们看到误差值$E_n &#x3D; |\sqrt{5} - x_n|$ 很快接近0 .事实证明$E_2 \sim E_1^2$ .所以如果 $E_0 &#x3D; 10^{-1}$,误差值会像下面这样降低:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/02c9178d-f3da-44dd-8ee2-391ee994ac55/Untitled.png"                      alt="Untitled"                ></p><p>数字精度每次都会翻倍.</p><p>牛顿的方法在$|f’|不是很小,|f’’|$不是很大,$x_0在答案x附近$的情况下工作很好.</p><h2 id="牛顿方法-那里可能出错"><a href="#牛顿方法-那里可能出错" class="headerlink" title="牛顿方法:那里可能出错?"></a>牛顿方法:那里可能出错?</h2><p>牛顿的方法在$|f’|不是很小,|f’’|$不是很大,$x_0在答案x附近$的情况下工作很好.我们不会太详细的讨论各种情况,但让我们看看为什么存在.如果$|f’’|$太大,图像会集聚弯曲,这种情况下切线也许不是很好的近似方法, $x_1$ 也许和答案并不靠近.如果$x_0$和$x_1$差很远会发生很多错误, 我们接下来讨论.</p><p>如果误差$E_0 &#x3D; |x-x_0|$ 比1大并且$E_1 \sim E_0^2$, 你估计的误差实际上会随着牛顿方法变大.</p><p>在例子$f(x) &#x3D; x^2 -5$中, 如果我们选择  $x_0 &#x3D; -2$ 我们会发现解决方案$-\sqrt{5}$,而不是 $\sqrt{5}$</p><p>这种与意外根的收敛如图所示</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3c84e531-54d2-46de-8ae1-c5d231d32077/Untitled.png"                      alt="Untitled"                ></p><p>在相同的例子中,如果我们选则$x_0 &#x3D; 0,然后 f’(x_0) &#x3D; 0$ 那么 $x_1 &#x3D; x_0 - \frac{f(x_0)}{f’(x_0)}$是未定义的.</p><p>最后, 牛顿方法有可能一直循环在两个值中并且不收敛,这个问题在图二中展现.</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7b66fe4d-63e6-4a2f-a7ba-e70e7b9e7ba9/Untitled.png"                      alt="Untitled"                ></p><p>牛顿的方法是求近解的好方法,但应用它需要一些智慧.你必须要小心得到不想要的值或者完全不是结果.你最初的猜测越好,你越可能得到正确的答案.</p><h2 id="x的立方根"><a href="#x的立方根" class="headerlink" title="x的立方根"></a>x的立方根</h2><p>表明对于任何非零起点$x_0,$牛顿方法永远没办法找到$x^3 &#x3D; 0$的确切值.</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="2c-1"><a href="#2c-1" class="headerlink" title="2c-1"></a>2c-1</h3><p>在12*12的纸板的四角切四个相等的正方形,折叠两侧,成为没有顶部的盒子,找到使盒子体积最大的切法.</p><h3 id="2c-2"><a href="#2c-2" class="headerlink" title="2c-2"></a>2c-2</h3><p>您需要设计一个长方形的谷仓，占地 20000 平方英尺，三面有围栏，第四面是长谷仓的墙壁。</p><p>找到最短围栏长度.</p><h3 id="2c-4"><a href="#2c-4" class="headerlink" title="2c-4"></a>2c-4</h3><p>美国邮政服务接受箱子的要求是长度加周长最大108inch,箱子最大体积是多少,尺寸是多少?</p><p>“长度”是三个维度中最长的，“周长”是垂直于长度的面部四个边的长度之和，即盒子的“腰线”测量值。请注意，此矩形面垂直于长度的最佳形状必须是正方形</p><h3 id="2c-10"><a href="#2c-10" class="headerlink" title="2c-10"></a>2c-10</h3><p>游泳者在海滩A点,垂直到达海滩的最短距离点是P,水中有一平台B,海岸线上离B最近的桥称为Q,假设A到P100米,B到Q 100米,P到Q 是a米,最后假设游泳者可以在海滩上5m&#x2F;s的跑步,子啊说中2m&#x2F;s的游泳,证明A到B话费最短时间的路径有下面的性质:路径与海岸线成角的正弦之比是两者中速度之比的倒数</p><p>$$<br>\frac{sin a^{-&gt;}}{sinb^{-&gt;}} &#x3D; \frac{5}{2}<br>$$</p><p>（在光学中，这被称为斯涅尔定律，描述了光线通过两个连续介质所走的路径。斯内尔通过实验发现，上述正弦之比是一个常数，不取决于路径的起点和终点。这个问题表明斯涅尔定律遵循一个最小原理：光线采取的路径最小化其总行进时间。正弦的比率是恒定的，因为它只取决于两种介质中的光速。)</p><h3 id="2c-13"><a href="#2c-13" class="headerlink" title="2c -13"></a>2c -13</h3><p>a) 一家航空公司将以200美元的票价填补其飞机的100个座位。票价每上涨5美元，飞机就会失去两名乘客。每减少5美元，该公司就会增加两名乘客。什幺价格可以最大化收入？</p><p>b) 一家公用事业公司有一个小型发电厂，每天可以生产x千瓦时的电力，每个成本为10 - x&#x2F;105美分，0 ≤ x ≤8×105。 消费者每天将使用105（10 − p &#x2F; 2）千瓦时的电力，价格为每千瓦时p美分。公用事业公司应该收取什幺价格才能最大化其利润？</p><h3 id="2E-2"><a href="#2E-2" class="headerlink" title="2E-2"></a>2E-2</h3><p>离岸4英里的信标灯（从直线垂直测量）以每分钟3转的速度旋转。当光束与海岸线成 60◦ 的角度时，海岸线上的光斑移动速度有多快？</p><h3 id="2E-3"><a href="#2E-3" class="headerlink" title="2E-3"></a>2E-3</h3><p>两艘船以30英里&#x2F;小时的速度行驶，第一艘向北行驶，第二艘船向东行驶。第二个在第一个到达后的第一个 10 分钟穿过路径。当第二个越过交叉点 10 英里时，他们的距离以什幺速度增加？</p><h3 id="2E-5"><a href="#2E-5" class="headerlink" title="2E-5"></a>2E-5</h3><p>一个人从滑轮上走开，拉着一根挂在滑轮上的绳子。绳索被固定在滑轮下方 10 英尺的高度。假设绳索另一端的重量以每秒 4 英尺的速度上升。当他&#x2F;她离滑轮正下方 20 英尺时，他&#x2F;她以什幺速度行走？</p><h3 id="2E-7"><a href="#2E-7" class="headerlink" title="2E-7"></a>2E-7</h3><p>一个槽以每秒 1 立方米的速度充满水。槽呈梯形横截面，下部底部长半米，侧面向外开口，与底座成45◦角。槽的长度为4米。当h为半米时，水位h上升的速度是多少？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Source&quot;&gt;&lt;a href=&quot;#Source&quot; class=&quot;headerlink&quot; title=&quot;Source&quot;&gt;&lt;/a&gt;Source&lt;/h3&gt;&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://ocw.mit.edu/courses/18</summary>
      
    
    
    
    
    <category term="calculus 18.01" scheme="http://example.com/tags/calculus-18-01/"/>
    
  </entry>
  
  <entry>
    <title>makefile</title>
    <link href="http://example.com/[object%20Object]/2023/02/18/makefile/"/>
    <id>http://example.com/[object%20Object]/2023/02/18/makefile/</id>
    <published>2023-02-18T01:54:05.000Z</published>
    <updated>2023-04-08T01:55:00.073Z</updated>
    
    <content type="html"><![CDATA[<p>创建一个文件夹 myproject</p><p>在文件夹下创建文件 Makefile</p><p>Makefile内写入</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">say_hello:</span><br><span class="line">echo <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure></div><p>在myproject下运行 make指令,输出如下</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">echo <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></div><hr><p>在上述行文中, say_hello 的行为就像是函数名,这叫target,目标,前置条件和依赖跟在目标后面,但这个例子中我们没有定义前置条件, echo “Hello World” 叫做 recipe 菜谱,recipe使用前置条件制作target, </p><p>recipes和前置条件,和目标一起组成规则rule</p><p>总结一下,下面是一个典型的rule</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target: prerequisites</span><br><span class="line">&lt;TAB&gt; recipe</span><br></pre></td></tr></table></figure></div><p>作为例子,目标也许是一个依赖前置条件(source file)的二进制文件.另一方面,先决条件也可以是依赖其他依赖项的目标.</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final_target: sub_target final_target.c</span><br><span class="line">Recipe_to_create_final_target</span><br><span class="line"></span><br><span class="line">sub_target: sub_target.c</span><br><span class="line">Recipe_to_create_sub_target</span><br></pre></td></tr></table></figure></div><p>traget 不一定是一个文件,也可以是给recipe的名字,就像我们例子中的那样,我们称之为虚假目标”phony targets”</p><p>回到上面的例子,当 make被执行时, echo “Hello World” 整条语句被打印出来,跟着真正的输出.通常我们不想要显示命令,为了阻止echo回显命令,我们需要在echo前加上@</p><hr><p>让我们在Makefile再加几条假指令:generate 和 clean </p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">say_hello:</span><br><span class="line">@echo <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line">generate:</span><br><span class="line">@echo <span class="string">&quot;Creating empty text files...&quot;</span></span><br><span class="line">touch file-&#123;<span class="number">1.</span><span class="number">.10</span>&#125;.txt</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">@echo <span class="string">&quot;Cleaning up...&quot;</span></span><br><span class="line">rm *.txt</span><br></pre></td></tr></table></figure></div><p>如果你尝试运行 make 只有目标 say_hello 会被执行,这是因为在makefile中只有第一条目标是默认目标 ,也叫 <em>default goal, 这也是你在多数项目看到 all是第一条目标的原因, all有责任 调用其他目标.我们可以覆盖掉这个行为,使用一个叫 .DEFAULT_GOAL 的假目标</em></p><p>让我们在makefile的开始加入这条指令</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.DEFAULT_GOAL := generate </span><br></pre></td></tr></table></figure></div><p>这条指令会默认运行目标 generate</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">Creating empty text files...</span><br><span class="line">touch file-&#123;<span class="number">1.</span><span class="number">.10</span>&#125;.txt</span><br></pre></td></tr></table></figure></div><p>正如名字所暗示的,价目标  <em>.DEFAULT_GOAL 一次只能运行一条指令, 这也是为什么多数 makefile包含 all 作为一个目标,这样可以调用需要多少的目标</em></p><p>然我们添加假指令 all 并移除  <em>.DEFAULT_GOAL</em></p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">all: say_hello generate</span><br><span class="line"></span><br><span class="line">say_hello:</span><br><span class="line">@echo <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line">generate:</span><br><span class="line">@echo <span class="string">&quot;Creating empty text files...&quot;</span></span><br><span class="line">touch file-&#123;<span class="number">1.</span><span class="number">.10</span>&#125;.txt</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">@echo <span class="string">&quot;Cleaning up...&quot;</span></span><br><span class="line">rm *.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>在运行 make 之前, 让我们加入另一条假指令 .PHONY 我们定义所有的不是文件的目标, make 会运行这些recipe不管带这些名字的文件存不存在,或者 文件的最后修改时间是什么 ,下面是完整的makefile</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: all say_hello generate clean</span><br><span class="line"></span><br><span class="line">all: say_hello generate</span><br><span class="line"></span><br><span class="line">say_hello:</span><br><span class="line">@echo <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line">generate:</span><br><span class="line">@echo <span class="string">&quot;Creating empty text files...&quot;</span></span><br><span class="line">touch file-&#123;<span class="number">1.</span><span class="number">.10</span>&#125;.txt</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">@echo <span class="string">&quot;Cleaning up...&quot;</span></span><br><span class="line">rm *.txt</span><br></pre></td></tr></table></figure></div><p>make指令会执行 say_hello 和 genereate :</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">Hello World</span><br><span class="line">Creating empty text files...</span><br><span class="line">touch file-&#123;<span class="number">1.</span><span class="number">.10</span>&#125;.txt</span><br></pre></td></tr></table></figure></div><p>最好不要再 all 里面调用clean, clean应该作为手动调用的指令,作为make的第一个参数</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">Cleaning up...</span><br><span class="line">rm *.txt</span><br></pre></td></tr></table></figure></div><p>现在你有了基本的认识,知道怎么写一个简单地makefile, 让我们看看更高级的例子吧</p><hr><h1 id="Advanced-examples"><a href="#Advanced-examples" class="headerlink" title="Advanced examples"></a>Advanced examples</h1><h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><p>在上面的例子中,多数目标和前置条件都是硬编码,但在实际的项目中,他们被替换成变量和模式.</p><p>最简单的定义一个变量的方式是使用 运算符 &#x3D;, 例如 给变量CC赋值一条命令 gcc :</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br></pre></td></tr></table></figure></div><p>这也叫递归展开变量 ,在像下面这条rule中使用:</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello: hello.c</span></span><br><span class="line">$&#123;CC&#125; hello.c -o hello</span><br></pre></td></tr></table></figure></div><p>就像你猜测的那样, recipe会展开成下面的样子,当指令传达到终端.</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure></div><p>${CC} 和$(CC)都是 调用 gcc 的合法引用. 但如果你尝试把变量赋值给变量自己,这会导致无限循环, 然我们验证一下:</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CC = $&#123;CC&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo $&#123;CC&#125;</span><br></pre></td></tr></table></figure></div><p>运行 make 会导致下面结果</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line"><span class="section">Makefile:8: *** Recursive variable &#x27;CC&#x27; references itself (eventually).  Stop.</span></span><br></pre></td></tr></table></figure></div><p>为了避免这种情况, 我们使用运算符 :&#x3D; (这叫做简单展开变量) 我们应该可以正确运行下面的 makefile</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC := gcc</span><br><span class="line">CC := $&#123;CC&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo $&#123;CC&#125;</span><br></pre></td></tr></table></figure></div><hr><h1 id="Patterns-and-functions"><a href="#Patterns-and-functions" class="headerlink" title="Patterns and functions"></a>Patterns and functions</h1><p>模式和函数</p><p>下面的makefile可以用变量,模式和函数编译所有的 C 程序, 让我们一行一行探索.</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Usage:</span></span><br><span class="line"><span class="comment"># make        # compile all binary</span></span><br><span class="line"><span class="comment"># make clean  # remove ALL binaries and objects</span></span><br><span class="line"></span><br><span class="line">.PHONY = all clean</span><br><span class="line"></span><br><span class="line">CC = gcc<span class="comment"># compiler to use</span></span><br><span class="line"></span><br><span class="line">LINKERFLAG = -lm</span><br><span class="line"></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">BINS := $(SRCS:%.c=%)</span><br><span class="line"></span><br><span class="line"><span class="section">all: $&#123;BINS&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="section">%: %.o</span></span><br><span class="line">@echo <span class="string">&quot;Checking..&quot;</span></span><br><span class="line">$&#123;CC&#125; $&#123;LINKERFLAG&#125; <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">@echo <span class="string">&quot;Creating object..&quot;</span></span><br><span class="line">$&#123;CC&#125; -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">@echo <span class="string">&quot;Cleaning up...&quot;</span></span><br><span class="line">rm -rvf *.o $&#123;BINS&#125;</span><br></pre></td></tr></table></figure></div><ul><li>以# 开头的是注释</li><li>行 .PHONY &#x3D; all clean 定义了假目标 all 和 clean</li><li>变量LINKERGLAG 定义了 在配方recipe中和 gcc一起使用的 标志</li><li>SRCS :&#x3D; $(wildcard  *.c):&amp;(wildcard pattern) 是函数名的一个函数,在这个例子中, 所有的后缀为.c的文件名都被存储在 变量SRCS中</li><li>BINS :&#x3D; $(SRCS:%.c&#x3D;%):这称为替换引用, 在这个例子中, 如果SRCS 有值 ‘foo.c bar.c’, BINS 就有’foo bar’</li><li>行 all: ${BINS} : 假目标 all 将 ${BINS} 中所有调用值作为单独目标</li><li>Rule:规则:</li></ul><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%: %.o</span></span><br><span class="line">@echo <span class="string">&quot;Checking..&quot;</span></span><br><span class="line">$&#123;CC&#125; $&#123;LINKERFLAG&#125; <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure></div><p>让我们通过一个例子来理解这个规则, 假设foo是 ${BINS} 中的一个值,那么 %可以匹配foo(%可以匹配任何目标名),下面是这条指令在展开后的形式</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">foo: foo.o</span></span><br><span class="line">@echo <span class="string">&quot;Checking..&quot;</span></span><br><span class="line">gcc -lm foo.o -o foo</span><br></pre></td></tr></table></figure></div><p>就像上面展示的,% 被 foo 取代, $&lt; 被 foo.o取代. $&lt;被模式化为与先决条件匹配,$@ 与目标匹配,这条规则,rule会调用 ${BINS} 中的所有值</p><ul><li>Rule:</li></ul><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">@echo <span class="string">&quot;Creating object..&quot;</span></span><br><span class="line">$&#123;CC&#125; -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div><p>上一个规则中的每个先决条件都被视为此规则的目标, 下面是这条规则的展开形式</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line">@echo <span class="string">&quot;Creating object..&quot;</span></span><br><span class="line">gcc -c foo.c</span><br></pre></td></tr></table></figure></div><p>最后,我们用clean移除target中所有二进制和object文件.</p><hr><p>下面是上面makefile的重写版本,假设放在一个只有 foo.c的路径中</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Usage:</span></span><br><span class="line"><span class="comment"># make        # compile all binary</span></span><br><span class="line"><span class="comment"># make clean  # remove ALL binaries and objects</span></span><br><span class="line"></span><br><span class="line">.PHONY = all clean</span><br><span class="line"></span><br><span class="line">CC = gcc<span class="comment"># compiler to use</span></span><br><span class="line"></span><br><span class="line">LINKERFLAG = -lm</span><br><span class="line"></span><br><span class="line">SRCS := foo.c</span><br><span class="line">BINS := foo</span><br><span class="line"></span><br><span class="line"><span class="section">all: foo</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: foo.o</span></span><br><span class="line">@echo <span class="string">&quot;Checking..&quot;</span></span><br><span class="line">gcc -lm foo.o -o foo</span><br><span class="line"></span><br><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line">@echo <span class="string">&quot;Creating object..&quot;</span></span><br><span class="line">gcc -c foo.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">@echo <span class="string">&quot;Cleaning up...&quot;</span></span><br><span class="line">rm -rvf foo.o foo</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;创建一个文件夹 myproject&lt;/p&gt;
&lt;p&gt;在文件夹下创建文件 Makefile&lt;/p&gt;
&lt;p&gt;Makefile内写入&lt;/p&gt;
&lt;div class=&quot;highlight-container&quot; data-rel=&quot;Cpp&quot;&gt;&lt;figure class=&quot;iseeu h</summary>
      
    
    
    
    
    <category term="makefile" scheme="http://example.com/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>2020数据结构题最优解</title>
    <link href="http://example.com/[object%20Object]/2022/10/20/suibi-18/"/>
    <id>http://example.com/[object%20Object]/2022/10/20/suibi-18/</id>
    <published>2022-10-20T06:04:53.000Z</published>
    <updated>2023-04-07T13:55:52.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>最简单的方法当然是暴力求解，遍历三个数组元素的所有可能组合，时间复杂度为O（n^3）</p><p>虽然说可以得到7分，但我觉得平时学习的时候一定要搞懂最优解，考试的时候迫不得已才用BF。</p><p>首先说说别人的方法，我们假设a&lt;&#x3D;b&lt;&#x3D;c，因为三个元素总会有大小之分，所以能找到次序，我的意思并不是说那个元素a一定是最小的，而是另最小的为a，如果三者相等距离为0，那这种情况一定是最小距离。</p><p>我们可以得到图中的几何关系，那么三个点的距离D即为2*l3，2倍的两个最远的点间的距离。如果要缩小D，只需要缩短这段距离即可。当然可以让c点更逼近a点，但是我们可以想一下，我们是从数组左边向右边递推的，所以让a从左向右更便于求解。当a超过b点，原来的b点就成为最小点，新的a点，因为我们要关注的始终是两个最远点的距离。如果a超过c，那a也应当成为c点。这里说的a点b点c点并不是说一定要a在s1，b在s2，我们定义a，b，c只是为了弄清他们的逻辑关系。</p><p>这种方法其实还是很抽象，所以我想了更加贴近几何的方法。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/%5Bobject%20Object%5D/2022/10/20/suibi-18/WechatIMG226.jpeg"                      class=""                ><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>如下图，三个数集分别表示在三条一维坐标中，暴力求解的问题就在于即使是s1的第一个元素和s3的最后元素也要去算，这是完全没有意义的，我们只要算这三条水平坐标系中最接近的三个点的距离，并不断从左端向右段比较即可。我们可以先抛开公式，以几何的方法去理解，三个点的最近距离就是三个点凑的最近的情况，怎么让三个点凑的最近呢？让右边的点向左，让左边的点靠近右都行，但前文已经说明，因为我们是从数组左端向右段推进的，所以让左边的数组向右递推更便于求解。如果递推过程中最后的点超过前面的两个点，那我们让落后的那个点继续往前逼近，直到遍历结束位置，这样我们就不会出现最前面的点和最后面的点这种情况了。如果哪次遍历我们找到的最小点，一定要是最小的点，是该数组最后一个点，那其他的点也没有必要继续向前推进了，因为这样只会拉大三个点之间的距离。读者可以自己画一下。<br>希望我的方法可以帮助你更好的理解这道题。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="/%5Bobject%20Object%5D/2022/10/20/suibi-18/2251666246061_.pic_hd_.jpeg"                      class=""                ><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_INT 0x7fffffff</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a&lt;b)?(a&lt;c?a:c):(b&lt;c?b:c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> a)</span> &#123;<span class="comment">//绝对值函数</span></span><br><span class="line">    <span class="keyword">return</span> a&lt;<span class="number">0</span>?-a:a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">most_close</span> <span class="params">(<span class="type">int</span> v1[], <span class="type">int</span> v2[], <span class="type">int</span> v3[], <span class="type">int</span> n1, <span class="type">int</span> n2, <span class="type">int</span> n3)</span> &#123;</span><br><span class="line">    <span class="comment">//v1,v2,v3为三个数组，n1，n2，n3 为数组长度</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="type">int</span> dis;</span><br><span class="line">    <span class="type">int</span> D = MAX_INT;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2 &amp;&amp; k &lt; n3 &amp;&amp; D&gt;<span class="number">0</span>) &#123;<span class="comment">//D=0 一定是最小距离，可以直接退出了。</span></span><br><span class="line">        dis = <span class="built_in">abs</span>(v1[i] - v2[j]) +<span class="built_in">abs</span>(v2[j] - v3[k]) + <span class="built_in">abs</span>(v3[k] - v1[i]);</span><br><span class="line">        <span class="keyword">if</span>(dis &lt; D)D= dis;</span><br><span class="line">        temp = min(v1[i],v2[j],v3[k]);<span class="comment">//找出最小值，将最小值向前推进</span></span><br><span class="line">        <span class="keyword">if</span> (temp == v1[i]) i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp == v2[j]) j++;</span><br><span class="line">        <span class="keyword">else</span> k++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> D;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">( <span class="type">void</span> )</span> &#123;</span><br><span class="line">    <span class="type">int</span> v1[] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> v2[] = &#123;<span class="number">-25</span>,<span class="number">-10</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line">    <span class="type">int</span> v3[] = &#123;<span class="number">2</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">30</span>,<span class="number">41</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, most_close(v1,v2,v3,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;

&lt;h1 id=&quot;理解&quot;&gt;&lt;a href=&quot;#理解&quot; class=&quot;headerlink&quot; title=&quot;理解&quot;&gt;&lt;/a&gt;理解&lt;/h1&gt;&lt;p&gt;最</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="408" scheme="http://example.com/tags/408/"/>
    
    <category term="几何" scheme="http://example.com/tags/%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>1024 Palindromic Number</title>
    <link href="http://example.com/[object%20Object]/2022/05/12/test-26/"/>
    <id>http://example.com/[object%20Object]/2022/05/12/test-26/</id>
    <published>2022-05-12T13:25:26.000Z</published>
    <updated>2022-05-12T13:35:24.053Z</updated>
    
    <content type="html"><![CDATA[<p>A number that will be the same when it is written forwards or backwards is known as a <strong>Palindromic Number</strong>. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.</p><p>Non-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. For example, if we start from 67, we can obtain a palindromic number in 2 steps: 67 + 76 &#x3D; 143, and 143 + 341 &#x3D; 484.</p><p>Given any positive integer <strong>N</strong>, you are supposed to find its paired palindromic number and the number of steps taken to find it.</p><p><em>Input Specification:</em></p><p>Each input file contains one test case. Each case consists of two positive numbers <strong>N</strong> and <strong>K</strong>, where <strong>N</strong> (≤1010) is the initial numer and <strong>K</strong> (≤100) is the maximum number of steps. The numbers are separated by a space.</p><p><em>Output Specification:</em></p><p>For each test case, output two numbers, one in each line. The first number is the paired palindromic number of <strong>N</strong>, and the second number is the number of steps taken to find the palindromic number. If the palindromic number is not found after <strong>K</strong> steps, just output the number obtained at the <strong>K</strong>th step and <strong>K</strong> instead.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">67 3</span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">484</span><br><span class="line">2</span><br></pre></td></tr></table></figure></div><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">69 3</span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1353</span><br><span class="line">3</span><br></pre></td></tr></table></figure></div><p><em>Analysis</em><br>c++ 现在用起来还是很费劲啊。人真的是有惰性，几天不做题，真的一点也不想做了。即使这样一道题，也足足做了2小时，我是废物啊(T_T)<br>这道题号是我生日，这是我的幸运题了。（根本不幸运，我恨超长数字！）</p><p><em>Code</em></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s1,s2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i]  + s2[i] + carry - <span class="number">2</span> * <span class="string">&#x27;0&#x27;</span> &gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            s1[i] = s1[i] + s2[i] + carry - <span class="string">&#x27;0&#x27;</span> - <span class="number">10</span>;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s1[i] = s1[i] + s2[i] - <span class="string">&#x27;0&#x27;</span> + carry;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry)s1+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPal</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;j &amp;&amp; s[i] == s[j])i++,j--;</span><br><span class="line">    <span class="keyword">return</span> i &gt;=j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPal</span>(s1))<span class="keyword">break</span>;</span><br><span class="line">        s2 = s1;</span><br><span class="line">        <span class="built_in">reverse</span>(s2.<span class="built_in">begin</span>(),s2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">add</span>();</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s1 &lt;&lt;endl &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;A number that will be the same when it is written forwards or backwards is known as a &lt;strong&gt;Palindromic Number&lt;/strong&gt;. For example, 1</summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
    <category term="PAT (Advanced Level) Practice" scheme="http://example.com/tags/PAT-Advanced-Level-Practice/"/>
    
  </entry>
  
  <entry>
    <title>1023 Have Fun with Numbers</title>
    <link href="http://example.com/[object%20Object]/2022/05/10/test-25/"/>
    <id>http://example.com/[object%20Object]/2022/05/10/test-25/</id>
    <published>2022-05-10T06:59:13.000Z</published>
    <updated>2022-05-10T07:02:23.860Z</updated>
    
    <content type="html"><![CDATA[<p>Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!</p><p>Now you are suppose to check if there are more numbers with this property. That is, double a given number with <strong>k</strong> digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.</p><p><em>Input Specification:</em></p><p>Each input contains one test case. Each case contains one positive integer with no more than 20 digits.</p><p><em>Output Specification:</em></p><p>For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234567899</span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">2469135798</span><br></pre></td></tr></table></figure></div><p><em>Analysis</em></p><p><em>Code</em></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> num;</span><br><span class="line">    <span class="type">int</span> numd[<span class="number">25</span>];</span><br><span class="line">    <span class="type">int</span> digit[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;,digitd[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getline(<span class="built_in">cin</span>,num);</span><br><span class="line">    reverse(num.begin(),num.end());</span><br><span class="line"><span class="comment">//    cout &lt;&lt; num&lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; num.size();i++)&#123;</span><br><span class="line">        digit[num[i]- <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(int i = 0;i &lt;=9;i++)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; digit[i];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>,temp,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.size();i++)&#123;</span><br><span class="line">        temp = (num[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">2</span> + carry;</span><br><span class="line">        numd[j++] = temp%<span class="number">10</span>;</span><br><span class="line">        carry = temp/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(int i = 0;i &lt; j; i++)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; numd[i];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(carry)numd[j++] = carry;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; j;i++)&#123;</span><br><span class="line">        digitd[numd[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(digit[i] != digitd[i])&#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(flag ? <span class="string">&quot;No\n&quot;</span>:<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = j<span class="number">-1</span>;i &gt;=<span class="number">0</span>;i--)<span class="built_in">cout</span> &lt;&lt; numd[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will o</summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
    <category term="PAT (Advanced Level) Practice" scheme="http://example.com/tags/PAT-Advanced-Level-Practice/"/>
    
  </entry>
  
  <entry>
    <title>1022 Digital Library PAT (Advanced Level) Practice</title>
    <link href="http://example.com/[object%20Object]/2022/05/08/test-24/"/>
    <id>http://example.com/[object%20Object]/2022/05/08/test-24/</id>
    <published>2022-05-08T06:59:13.000Z</published>
    <updated>2022-05-08T07:02:30.713Z</updated>
    
    <content type="html"><![CDATA[<p>A Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and published years. Each book is assigned an unique 7-digit number as its ID. Given any query from a reader, you are supposed to output the resulting books, sorted in increasing order of their ID’s.</p><p><em>Input Specification:</em></p><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤104) which is the total number of books. Then N blocks follow, each contains the information of a book in 6 lines:</p><ul><li>Line #1: the 7-digit ID number;</li><li>Line #2: the book title – a string of no more than 80 characters;</li><li>Line #3: the author – a string of no more than 80 characters;</li><li>Line #4: the key words – each word is a string of no more than 10 characters without any white space, and the keywords are separated by exactly one space;</li><li>Line #5: the publisher – a string of no more than 80 characters;</li><li>Line #6: the published year – a 4-digit number which is in the range [1000, 3000].</li></ul><p>It is assumed that each book belongs to one author only, and contains no more than 5 key words; there are no more than 1000 distinct key words in total; and there are no more than 1000 distinct publishers.</p><p>After the book information, there is a line containing a positive integer M (≤1000) which is the number of user’s search queries. Then M lines follow, each in one of the formats shown below:</p><ul><li>1: a book title</li><li>2: name of an author</li><li>3: a key word</li><li>4: name of a publisher</li><li>5: a 4-digit number representing the year</li></ul><p><em>Output Specification:</em></p><p>For each query, first print the original query in a line, then output the resulting book ID’s in increasing order, each occupying a line. If no book is found, print <code>Not Found</code> instead.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1111111</span><br><span class="line">The Testing Book</span><br><span class="line">Yue Chen</span><br><span class="line">test code debug sort keywords</span><br><span class="line">ZUCS Print</span><br><span class="line">2011</span><br><span class="line">3333333</span><br><span class="line">Another Testing Book</span><br><span class="line">Yue Chen</span><br><span class="line">test code sort keywords</span><br><span class="line">ZUCS Print2</span><br><span class="line">2012</span><br><span class="line">2222222</span><br><span class="line">The Testing Book</span><br><span class="line">CYLL</span><br><span class="line">keywords debug book</span><br><span class="line">ZUCS Print2</span><br><span class="line">2011</span><br><span class="line">6</span><br><span class="line">1: The Testing Book</span><br><span class="line">2: Yue Chen</span><br><span class="line">3: keywords</span><br><span class="line">4: ZUCS Print</span><br><span class="line">5: 2011</span><br><span class="line">3: blablabla</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1: The Testing Book</span><br><span class="line">1111111</span><br><span class="line">2222222</span><br><span class="line">2: Yue Chen</span><br><span class="line">1111111</span><br><span class="line">3333333</span><br><span class="line">3: keywords</span><br><span class="line">1111111</span><br><span class="line">2222222</span><br><span class="line">3333333</span><br><span class="line">4: ZUCS Print</span><br><span class="line">1111111</span><br><span class="line">5: 2011</span><br><span class="line">1111111</span><br><span class="line">2222222</span><br><span class="line">3: blablabla</span><br><span class="line">Not Found</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><em>Analysis</em></p><p><em>Code</em></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">search</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">set</span>&lt;<span class="type">int</span>&gt;&gt; &amp;m,<span class="built_in">string</span> &amp;s)</span>&#123; <span class="comment">//引用类型怎么用？</span></span><br><span class="line">    <span class="keyword">if</span>(m.find(s) != m.end())&#123;                   <span class="comment">//以及如果找到返回什么？</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = m[s].begin();it != m[s].end();it++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%07d\n&quot;</span>,*it);               </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">set</span>&lt;<span class="type">int</span>&gt;&gt;title,author,key,publisher,year;</span><br><span class="line"><span class="type">int</span> id,n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ttitle,tauthor,tkey,tpublisher,tyear;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;id);<span class="comment">//需要用scanf 把\n换行符也读进去，不然下一个getline只会读到一个换行符</span></span><br><span class="line">        getline(<span class="built_in">cin</span>,ttitle);</span><br><span class="line">        title[ttitle].insert(id);</span><br><span class="line">        getline(<span class="built_in">cin</span>,tauthor);</span><br><span class="line">        author[tauthor].insert(id);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; tkey)&#123;</span><br><span class="line">            key[tkey].insert(id);       <span class="comment">//没有tkey为键的map就创建一个？</span></span><br><span class="line">            <span class="type">char</span> ch = getchar();</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;\n&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getline(<span class="built_in">cin</span>,tpublisher);</span><br><span class="line">        publisher[tpublisher].insert(id);</span><br><span class="line">        getline(<span class="built_in">cin</span>,tyear);</span><br><span class="line">        year[tyear].insert(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d: &quot;</span>,&amp;num);</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        getline(<span class="built_in">cin</span>,temp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; temp &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                search(title,temp);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                search(author,temp);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                search(key,temp);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                search(publisher,temp);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                search(year,temp);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;A Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and pu</summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>1021 Deepest Root PAT (Advanced Level) Practice</title>
    <link href="http://example.com/[object%20Object]/2022/05/01/test-23/"/>
    <id>http://example.com/[object%20Object]/2022/05/01/test-23/</id>
    <published>2022-04-30T21:39:21.000Z</published>
    <updated>2022-04-30T21:41:58.733Z</updated>
    
    <content type="html"><![CDATA[<p>A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called <strong>the deepest root</strong>.</p><p><em>Input Specification:</em></p><p>Each input file contains one test case. For each case, the first line contains a positive integer <strong>N</strong> (≤104) which is the number of nodes, and hence the nodes are numbered from 1 to <strong>N</strong>. Then <strong>N</strong>−1 lines follow, each describes an edge by given the two adjacent nodes’ numbers.</p><p><em>Output Specification:</em></p><p>For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print <code>Error: K components</code>where <code>K</code> is the number of connected components in the graph.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure></div><p><em>Analysis</em></p><p><em>Code</em></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> visited[<span class="number">10015</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> edge[<span class="number">10015</span>][<span class="number">10015</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="type">int</span> s1;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(height &gt; maxHeight)&#123;</span><br><span class="line">        maxHeight = height;</span><br><span class="line">        temp.<span class="built_in">clear</span>();</span><br><span class="line">        temp.<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(height == maxHeight)&#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i] &amp;&amp; edge[v][i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i,height +<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> v1,v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        edge[v1][v2] = edge[v2][v1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                s1 = temp[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; temp.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    s.<span class="built_in">insert</span>(temp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;=<span class="number">2</span>)cout &lt;&lt; <span class="string">&quot;Error: &quot;</span>&lt;&lt;count&lt;&lt; <span class="string">&quot; components&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        temp.<span class="built_in">clear</span>();</span><br><span class="line">        maxHeight = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fill</span>(visited,visited+<span class="number">10015</span>,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(s1,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; temp.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(temp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();it != s.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are suppose</summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
    <category term="dfs" scheme="http://example.com/tags/dfs/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>1020 Tree Traversals PAT (Advanced Level) Practice</title>
    <link href="http://example.com/[object%20Object]/2022/05/01/test-22/"/>
    <id>http://example.com/[object%20Object]/2022/05/01/test-22/</id>
    <published>2022-04-30T19:46:37.000Z</published>
    <updated>2022-04-30T21:42:42.835Z</updated>
    
    <content type="html"><![CDATA[<p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p><p><em>Input Specification:</em></p><p>Each input file contains one test case. For each case, the first line gives a positive integer <strong>N</strong> (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.</p><p><em>Output Specification:</em></p><p>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2 3 1 5 7 6 4</span><br><span class="line">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 1 6 3 5 7 2</span><br></pre></td></tr></table></figure></div><p><em>Analysis</em><br>后续中序转前序的基础上加上下标</p><p><em>Code</em></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> &lt;<span class="type">int</span>,<span class="type">int</span> &gt; level;</span><br><span class="line"><span class="type">int</span> post[<span class="number">35</span>],in[<span class="number">35</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">pre</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &lt;= end)&#123;</span><br><span class="line">        level[index] = post[root];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = start;  in[i] != post[root]; i++);</span><br><span class="line">        pre(root - (end - i +<span class="number">1</span>),start,i<span class="number">-1</span>,<span class="number">2</span> * index +<span class="number">1</span>);</span><br><span class="line">        pre(root - <span class="number">1</span>, i+<span class="number">1</span>, end, <span class="number">2</span> * index +<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; post[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; in[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pre(n,<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> it = level.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it -&gt;second;</span><br><span class="line">    <span class="keyword">while</span>(++it != level.end())<span class="built_in">cout</span> &lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt; it-&gt;second;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are s</summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树给后序、中序求先序</title>
    <link href="http://example.com/[object%20Object]/2022/05/01/test-21/"/>
    <id>http://example.com/[object%20Object]/2022/05/01/test-21/</id>
    <published>2022-04-30T19:06:43.000Z</published>
    <updated>2022-04-30T19:20:02.066Z</updated>
    
    <content type="html"><![CDATA[ <img                       lazyload                     src="/images/loading.svg"                     data-src="/%5Bobject%20Object%5D/2022/05/01/test-21/20220501_031738.jpg"                      class=""                ><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> post[<span class="number">10</span>],in[<span class="number">10</span>],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &lt;= end)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,post[root]);</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; in[i] != post[root]; i++);</span><br><span class="line">        <span class="built_in">pre</span>(root - ( end - i +<span class="number">1</span>),start,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">pre</span>(root<span class="number">-1</span>,i+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;post[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pre</span>(n,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html"> &lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/%5Bobject%20Object%5D/2</summary>
      
    
    
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>1019 General Palindromic Number PAT (Advanced Level) Practice</title>
    <link href="http://example.com/[object%20Object]/2022/04/27/test-20/"/>
    <id>http://example.com/[object%20Object]/2022/04/27/test-20/</id>
    <published>2022-04-27T12:37:48.000Z</published>
    <updated>2022-04-27T12:46:48.672Z</updated>
    
    <content type="html"><![CDATA[<p>A number that will be the same when it is written forwards or backwards is known as a <strong>Palindromic Number</strong>. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.</p><p>Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number <strong>N</strong>&gt;0 in base <strong>b</strong>≥2, where it is written in standard notation with <strong>k</strong>+1 digits <strong>ai</strong> as ∑<strong>i</strong>&#x3D;0<strong>k</strong>(<strong>aibi</strong>). Here, as usual, 0≤<strong>ai</strong>&lt;<strong>b</strong> for all <strong>i</strong> and <strong>ak</strong> is non-zero. Then <strong>N</strong> is palindromic if and only if <strong>ai</strong>&#x3D;<strong>ak</strong>−<strong>i</strong> for all <strong>i</strong>. Zero is written 0 in any base and is also palindromic by definition.</p><p>Given any positive decimal integer <strong>N</strong> and a base <strong>b</strong>, you are supposed to tell if <strong>N</strong> is a palindromic number in base <strong>b</strong>.</p><p><em>Input Specification:</em></p><p>Each input file contains one test case. Each case consists of two positive numbers <strong>N</strong> and <strong>b</strong>, where 0&lt;<strong>N</strong>≤109 is the decimal number and 2≤<strong>b</strong>≤109 is the base. The numbers are separated by a space.</p><p><em>Output Specification:</em></p><p>For each test case, first print in one line <code>Yes</code> if <strong>N</strong> is a palindromic number in base <strong>b</strong>, or <code>No</code> if not. Then in the next line, print <strong>N</strong> as the number in base <strong>b</strong> in the form “<strong>ak</strong> <strong>ak</strong>−1 … <strong>a</strong>0”. Notice that there must be no extra space at the end of output.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27 2</span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">1 1 0 1 1</span><br></pre></td></tr></table></figure></div><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">121 5</span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">4 4 1</span><br></pre></td></tr></table></figure></div><p><em>Analysis</em><br>一道简单的回文数，把n进行进制转换并存在数组中，用头尾指针逐一比较，while退出的条件是head &lt; tail，用flag作为标记，把刚刚的数组反转并输出，就ac了～<br>如果这个数是0直接yes退出，因为0 无法进入循环</p><p><em>Code</em></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n,b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span> &lt;&lt; <span class="number">0</span> &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        s[i++] = n%b;</span><br><span class="line">        n/=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> head = <span class="number">0</span>,tail = i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( head &lt;= tail)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[head++] != s[tail--])&#123;flag = <span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(s,s + i);</span><br><span class="line">    <span class="built_in">printf</span>(flag ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;i;j++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>( j==<span class="number">0</span>?<span class="string">&quot;%d&quot;</span>:<span class="string">&quot; %d&quot;</span>,s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;A number that will be the same when it is written forwards or backwards is known as a &lt;strong&gt;Palindromic Number&lt;/strong&gt;. For example, 1</summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>1018 Public Bike Management PAT (Advanced Level) Practice</title>
    <link href="http://example.com/[object%20Object]/2022/04/26/test-19/"/>
    <id>http://example.com/[object%20Object]/2022/04/26/test-19/</id>
    <published>2022-04-26T12:26:00.000Z</published>
    <updated>2022-04-27T12:38:36.521Z</updated>
    
    <content type="html"><![CDATA[<p>There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city.</p><p>The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in <strong>perfect</strong> condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well.</p><p>When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen.</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://images.ptausercontent.com/213"                      alt="img"                ></p><p>The above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex <strong>S</strong> is the current number of bikes stored at <strong>S</strong>. Given that the maximum capacity of each station is 10. To solve the problem at <strong>S</strong>3, we have 2 different shortest paths:</p><ol><li>PBMC -&gt; <strong>S</strong>1 -&gt; <strong>S</strong>3. In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from <strong>S</strong>1 and then take 5 bikes to <strong>S</strong>3, so that both stations will be in perfect conditions.</li><li>PBMC -&gt; <strong>S</strong>2 -&gt; <strong>S</strong>3. This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen.</li></ol><p><em>Input Specification:</em></p><p>Each input file contains one test case. For each case, the first line contains 4 numbers: <strong>Cmax</strong> (≤100), always an even number, is the maximum capacity of each station; <strong>N</strong> (≤500), the total number of stations; <strong>Sp</strong>, the index of the problem station (the stations are numbered from 1 to <strong>N</strong>, and PBMC is represented by the vertex 0); and <strong>M</strong>, the number of roads. The second line contains <strong>N</strong> non-negative numbers <strong>Ci</strong> (<strong>i</strong>&#x3D;1,⋯,<strong>N</strong>) where each <strong>Ci</strong> is the current number of bikes at <strong>Si</strong> respectively. Then <strong>M</strong> lines follow, each contains 3 numbers: <strong>Si</strong>, <strong>Sj</strong>, and <strong>Tij</strong> which describe the time <strong>Tij</strong> taken to move betwen stations <strong>Si</strong> and <strong>Sj</strong>. All the numbers in a line are separated by a space.</p><p><em>Output Specification:</em></p><p>For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0−&gt;<strong>S</strong>1−&gt;⋯−&gt;<strong>Sp</strong>. Finally after another space, output the number of bikes that we must take back to PBMC after the condition of <strong>Sp</strong>is adjusted to perfect.</p><p>Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge’s data guarantee that such a path is unique.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10 3 3 5</span><br><span class="line">6 7 0</span><br><span class="line">0 1 1</span><br><span class="line">0 2 1</span><br><span class="line">0 3 3</span><br><span class="line">1 3 1</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 0-&gt;2-&gt;3 0</span><br></pre></td></tr></table></figure></div><p><em>Analysis</em></p><p>今天来写个c++吧，比起c，stl真是太方便了！<br>根据题意，有n+1个节点，其中1～n是车站，会向0号节点提出请求。每个车站有0～cmax量车，cmax必为偶数，如果车站的车数量为cmax辆或0辆，会向0号点提出申请，0号节点要将该节点车辆增或者减为cmax&#x2F;2 辆，0号节点要求从最短路到达sp节点，也就是提出请求的节点，0号节点向sp节点运送车辆同时，要将道路上经过的所有车站停车数量增或者补为cmax&#x2F;2 辆，如果最短路不止一条，走需要从0号站携带最少的车辆的那一条路，如果携带数量还是一样，走需要带回的最少车辆的那一路。本题需要注意的的有几点</p><ol><li>前面的多出来的车辆可以补后面的站，但后面站多出来的车辆不可以补前面的站。</li><li>在获取每个车站的车辆数的时候，减去cmax&#x2F;2 便于后面统计</li><li>最小携带数量需要走完全程才能算出，因为不满足最优子结构，不是简单的相加。</li></ol><p>在求最短路的时候，如果更新dis[]数组，有相等的情况，就要将之前的前驱和现在的前驱都存入pre数组，并在dfs遍历的时候比对哪一个的need 和back 最小。</p><p><em>Code</em></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">99999999</span>;</span><br><span class="line"><span class="type">int</span> cmax,n,m,sp;</span><br><span class="line"><span class="comment">//vexs记录点权，edge记录边权</span></span><br><span class="line"><span class="type">int</span> vexs[<span class="number">510</span>],edge[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="comment">//d为distance数组，用于求解dijkstra最短路</span></span><br><span class="line"><span class="type">int</span> d[<span class="number">510</span>];</span><br><span class="line"><span class="comment">//minneed记录最小需求，minback记录最小带回</span></span><br><span class="line"><span class="type">int</span> minneed = inf,minback = inf;</span><br><span class="line"><span class="comment">//visited标记是否被访问，在dijkstra中记录是否求出最短路</span></span><br><span class="line"><span class="type">bool</span> visited[<span class="number">510</span>];</span><br><span class="line"><span class="comment">//path 保存最终路径，temppath用作求解最终路径临时数组，pre记录前驱节点，可能不止一个</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; pre[<span class="number">510</span>],path,temppath;</span><br><span class="line"><span class="comment">//求解最短路函数，最开始传入sp。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    temppath.<span class="built_in">push_back</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> need = <span class="number">0</span>,back = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = temppath.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="type">int</span> id = temppath[j];</span><br><span class="line">            <span class="keyword">if</span>(vexs[id] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                back +=vexs[id];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(back &gt; (<span class="number">0</span> - vexs[id]))&#123;</span><br><span class="line">                    back +=vexs[id];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    need +=((<span class="number">0</span> - vexs[id]) - back);</span><br><span class="line">                    back = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(need &lt; minneed)&#123;</span><br><span class="line">            minneed = need;</span><br><span class="line">            minback = back;</span><br><span class="line">            path = temppath;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(need == minneed &amp;&amp; back &lt; minback)&#123;</span><br><span class="line">            minback = back;</span><br><span class="line">            path = temppath;</span><br><span class="line">        &#125;</span><br><span class="line">        temppath.<span class="built_in">pop_back</span>();   </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; pre[v].<span class="built_in">size</span>();i++)&#123;<span class="comment">//遍历前驱</span></span><br><span class="line">        <span class="built_in">dfs</span>(pre[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    temppath.<span class="built_in">pop_back</span>();     </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">510</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">510</span>; j++)</span><br><span class="line">            edge[i][j] = inf;</span><br><span class="line">    cin &gt;&gt; cmax &gt;&gt; n &gt;&gt; sp &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">//获取点权</span></span><br><span class="line">        cin &gt;&gt; vexs[i];</span><br><span class="line">        vexs[i] -=cmax/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> v1,v2,time;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="comment">//获取边权</span></span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; time;</span><br><span class="line">        edge[v1][v2] = edge[v2][v1] = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//辅助数组初始化</span></span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">        d[i] = edge[<span class="number">0</span>][i];      <span class="comment">//d 表示distance</span></span><br><span class="line">        <span class="keyword">if</span>(edge[<span class="number">0</span>][i] != inf)&#123;</span><br><span class="line">            pre[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> min = inf,k = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">//在和i节点相连的节点中选择边权最小的一个</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; d[j] &lt; min)&#123;</span><br><span class="line">                min = d[j];k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">        visited[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; d[k] + edge[j][k] &lt; d[j])&#123;</span><br><span class="line">                d[j] = d[k] + edge[j][k];</span><br><span class="line">                pre[j].<span class="built_in">clear</span>();</span><br><span class="line">                pre[j].<span class="built_in">push_back</span>(k);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!visited[j] &amp;&amp; d[k] + edge[j][k] == d[j])&#123;</span><br><span class="line">                pre[j].<span class="built_in">push_back</span>(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(sp);</span><br><span class="line">    cout &lt;&lt; minneed &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; path[path.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = path.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; path[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; minback&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a </summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>1017 Queueing at Bank PAT (Advanced Level) Practice</title>
    <link href="http://example.com/[object%20Object]/2022/04/24/test-18/"/>
    <id>http://example.com/[object%20Object]/2022/04/24/test-18/</id>
    <published>2022-04-24T12:22:14.000Z</published>
    <updated>2022-05-10T07:04:14.389Z</updated>
    
    <content type="html"><![CDATA[<p>Suppose a bank has <strong>K</strong> windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his&#x2F;her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour.</p><p>Now given the arriving time <strong>T</strong> and the processing time <strong>P</strong> of each customer, you are supposed to tell the average waiting time of all the customers.</p><p><em>Input Specification:</em></p><p>Each input file contains one test case. For each case, the first line contains 2 numbers: <strong>N</strong> (≤104) - the total number of customers, and <strong>K</strong> (≤100) - the number of windows. Then <strong>N</strong> lines follow, each contains 2 times: <code>HH:MM:SS</code> - the arriving time, and <strong>P</strong> - the processing time in minutes of a customer. Here <code>HH</code> is in the range [00, 23], <code>MM</code> and <code>SS</code> are both in [00, 59]. It is assumed that no two customers arrives at the same time.</p><p>Notice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average.</p><p><em>Output Specification:</em></p><p>For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">7 3</span><br><span class="line">07:55:00 16</span><br><span class="line">17:00:01 2</span><br><span class="line">07:59:59 15</span><br><span class="line">08:01:00 60</span><br><span class="line">08:00:00 30</span><br><span class="line">08:00:02 2</span><br><span class="line">08:03:00 10</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.2</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><em>Analysis</em></p><p>和之前那道银行排序题大同小异，不需要用队列结构了。但这道题有很多坑，第一点早于8点之前到的人如果直接归为8点到的会排序后出现不同的结果，第二八点前到的等待时间也算等待时间，我就是掉进这里面总也通不过测试(T_T)。</p><p>别的也没啥了，关键这是两天前做的现在想不起来了(￣∇￣)。</p><p><em>Code</em></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">double</span> a_time;</span><br><span class="line">    <span class="type">double</span> p_time;</span><br><span class="line">&#125;node,CSTM[<span class="number">10015</span>];</span><br><span class="line">CSTM c;</span><br><span class="line"><span class="type">double</span> wind[<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a,<span class="type">const</span> <span class="type">void</span>* b)</span>&#123;</span><br><span class="line">    node * pa = (node*)a;</span><br><span class="line">    node * pb = (node*)b;</span><br><span class="line">    <span class="keyword">return</span> (pa-&gt;a_time &gt; pb-&gt;a_time)? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    <span class="type">int</span> h,m,s;</span><br><span class="line">    <span class="type">double</span> p;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d %lf&quot;</span>,&amp;h,&amp;m,&amp;s,&amp;p);</span><br><span class="line">        <span class="keyword">if</span>(p &gt; <span class="number">60</span>)p = <span class="number">60</span>;</span><br><span class="line">        c[i].a_time = (h<span class="number">-8</span>)*<span class="number">60.0</span> + m + s/<span class="number">60.0</span>;</span><br><span class="line">        c[i].p_time = p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for(int i = 0;i&lt;n;i++)printf(&quot;--%.2lf  %.2lf  \n&quot;,c[i].a_time,c[i].p_time);</span></span><br><span class="line">    qsort(c,n,<span class="keyword">sizeof</span>(node),cmp);</span><br><span class="line"><span class="comment">//    for(int i = 0;i&lt;n;i++)printf(&quot;++%.2lf  %2.lf  \n&quot;,c[i].a_time,c[i].p_time);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i].a_time &lt;<span class="number">0</span>) sum -= c[i].a_time,c[i].a_time = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for(int i = 0;i&lt;n;i++)printf(&quot;==%.2lf  %2.lf  \n&quot;,c[i].a_time,c[i].p_time);</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k &amp;&amp; i &lt;n;i++)&#123;</span><br><span class="line">        wind[cnt] = c[cnt].a_time + c[cnt].p_time;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> min;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"><span class="comment">//    for(int i = 0;i&lt;3;i++)printf(&quot;%.2lf  &quot;,wind[i]);</span></span><br><span class="line"><span class="comment">//    putchar(&#x27;\n&#x27;);</span></span><br><span class="line">    <span class="keyword">while</span>(cnt &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[cnt].a_time &gt; <span class="number">540</span>)<span class="keyword">break</span>;</span><br><span class="line">        min = wind[<span class="number">0</span>];index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wind[i] &lt; min)&#123;min = wind[i];index = i;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        printf(&quot;%.2lf %d  %d\n&quot;,wind[index],index,cnt);</span></span><br><span class="line">        <span class="keyword">if</span>(wind[index] &lt;= c[cnt].a_time)&#123;</span><br><span class="line">            wind[index] = c[cnt].a_time + c[cnt].p_time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum+= wind[index] - c[cnt].a_time;</span><br><span class="line">            wind[index] += c[cnt].p_time;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        printf(&quot;%.2lf %.2lf %.2lf\n&quot;,wind[0],wind[1],wind[2]);</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>,cnt,sum/cnt);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Suppose a bank has &lt;strong&gt;K&lt;/strong&gt; windows open for service. There is a yellow line in front of the windows which devides the waiting </summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>1016 Phone Bills PAT (Advanced Level) Practice</title>
    <link href="http://example.com/[object%20Object]/2022/04/20/test-17/"/>
    <id>http://example.com/[object%20Object]/2022/04/20/test-17/</id>
    <published>2022-04-20T13:00:28.000Z</published>
    <updated>2022-04-20T13:30:19.730Z</updated>
    
    <content type="html"><![CDATA[<p>A long-distance telephone company charges its customers by the following rules:</p><p>Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records.</p><p><em>Input Specification:</em></p><p>Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records.</p><p>The rate structure consists of a line with 24 non-negative integers denoting the toll (cents&#x2F;minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day.</p><p>The next line contains a positive number <strong>N</strong> (≤1000), followed by <strong>N</strong> lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (<code>MM:dd:HH:mm</code>), and the word <code>on-line</code> or <code>off-line</code>.</p><p>For each test case, all dates will be within a single month. Each <code>on-line</code> record is paired with the chronologically next record for the same customer provided it is an <code>off-line</code> record. Any <code>on-line</code> records that are not paired with an <code>off-line</code> record are ignored, as are <code>off-line</code>records not paired with an <code>on-line</code> record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock.</p><p><em>Output Specification:</em></p><p>For each test case, you must print a phone bill for each customer.</p><p>Bills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (<code>dd:HH:mm</code>), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 10</span><br><span class="line">10</span><br><span class="line">CYLL 01:01:06:01 on-line</span><br><span class="line">CYLL 01:28:16:05 off-line</span><br><span class="line">CYJJ 01:01:07:00 off-line</span><br><span class="line">CYLL 01:01:08:03 off-line</span><br><span class="line">CYJJ 01:01:05:59 on-line</span><br><span class="line">aaa 01:01:01:03 on-line</span><br><span class="line">aaa 01:02:00:01 on-line</span><br><span class="line">CYLL 01:28:15:41 on-line</span><br><span class="line">aaa 01:05:02:24 on-line</span><br><span class="line">aaa 01:04:23:59 off-line</span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CYJJ 01</span><br><span class="line">01:05:59 01:07:00 61 $12.10</span><br><span class="line">Total amount: $12.10</span><br><span class="line">CYLL 01</span><br><span class="line">01:06:01 01:08:03 122 $24.40</span><br><span class="line">28:15:41 28:16:05 24 $3.85</span><br><span class="line">Total amount: $28.25</span><br><span class="line">aaa 01</span><br><span class="line">02:00:01 04:23:59 4318 $638.80</span><br><span class="line">Total amount: $638.80</span><br></pre></td></tr></table></figure></div><p><em>Analysis</em><br>题意为给你一天24小时每小时电话收费标准和N条通话记录，通话记录分为拨打电话和挂断电话两类，必须能够匹配才算有效数据。数据内包括拨打电话的月日时间分钟和通话人。需要统计每个人的总花费，每条记录花费。首先创建通话记录结构变量，然后给通话记录排序，（使用库函数qsort排序）姓名升序排序，相同的放在一起，姓名相同的记录按照时间升序排序。这样在最后检测的时候如果相邻两个数据使用人名称相同且符合前一个为拨打后一个为挂断，就为有效数据。通话费用以00:00:00计费，挂断时间费用减去拨打时间费用即为拨号过程费用。<br>输出格式我用了一点小技巧，但是程序稳健型不是很好，可以参考<a class="link"   href="https://www.liuchuo.net/archives/2350" >柳神的方法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，我没学过c++，不知道怎么用那种数据类型。</p><p>这题真的好复杂啊(＞人＜;)！</p><p><em>Code</em></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//通话记录结构</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">25</span>];</span><br><span class="line">    <span class="type">int</span> status,month,day,hour,minute,time;</span><br><span class="line">&#125;Node;</span><br><span class="line">Node call[<span class="number">1015</span>];</span><br><span class="line"><span class="type">int</span> rate[<span class="number">25</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a,<span class="type">const</span> <span class="type">void</span>* b)</span>&#123;<span class="comment">//qsort比较函数</span></span><br><span class="line">    Node *pa = (Node *)a;</span><br><span class="line">    Node *pb = (Node *)b;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(pa-&gt;name,pb-&gt;name) == <span class="number">0</span>)?pa-&gt; time - pb-&gt;time : <span class="built_in">strcmp</span>(pa-&gt;name,pb-&gt;name);<span class="comment">//名称升序排列，名称相同时间升序排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">price</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//计算 第i个通话记录从 00:00:00开始的费用</span></span><br><span class="line">    <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">    res +=call[i].day * rate[<span class="number">24</span>] * <span class="number">60</span> + call[i].minute * rate[call[i].hour];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;call[i].hour;j++)&#123;</span><br><span class="line">        res +=rate[j] * <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res/<span class="number">100.0</span>;<span class="comment">//美分换算美元</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">24</span>;i++)&#123;<span class="comment">//获取费率</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;rate[i]);</span><br><span class="line">        rate[<span class="number">24</span>] += rate[i];<span class="comment">//便于计算超过一天的通话记录的费用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">char</span> status[<span class="number">20</span>];<span class="comment">//临时变量，保存 拨通挂断字符串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d:%d:%d:%d %s&quot;</span>,call[i].name,&amp;call[i].month,&amp;call[i].day,&amp;call[i].hour,&amp;call[i].minute,status);</span><br><span class="line">        call[i].time = call[i].day * <span class="number">24</span> * <span class="number">60</span> + call[i].hour * <span class="number">60</span> + call[i].minute;</span><br><span class="line">        call[i].status = (<span class="built_in">strcmp</span>(status,<span class="string">&quot;on-line&quot;</span>)==<span class="number">0</span>)?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//拨通为1，挂断为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    qsort(call,n,<span class="keyword">sizeof</span>(Node),cmp);<span class="comment">//通话记录排序</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">25</span>] = <span class="string">&quot;######&quot;</span>;<span class="comment">//保存上一个通话记录姓名</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;<span class="comment">//第一次输出标记</span></span><br><span class="line">    <span class="type">double</span> sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(call[i].name,call[i<span class="number">-1</span>].name) == <span class="number">0</span> &amp;&amp; call[i].status == <span class="number">0</span> &amp;&amp; call[i<span class="number">-1</span>].status ==<span class="number">1</span> )&#123;<span class="comment">//合法数据判断</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,call[i].name) != <span class="number">0</span>)&#123;<span class="comment">//与一个通话记录姓名不同，开始新的输出和统计</span></span><br><span class="line">                <span class="built_in">strcpy</span>(name,call[i].name);<span class="comment">//更新上一个通话记录姓名</span></span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Total amount: $%.2lf\n&quot;</span>,sum);</span><br><span class="line">                &#125;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s %02d\n&quot;</span>,call[i].name,call[i].month);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d %02d:%02d:%02d %d $%.2lf\n&quot;</span>,</span><br><span class="line">                call[i<span class="number">-1</span>].day,call[i<span class="number">-1</span>].hour,call[i<span class="number">-1</span>].minute,</span><br><span class="line">                call[i].day,call[i].hour,call[i].minute,call[i].time - call[i<span class="number">-1</span>].time,price(i)-price(i<span class="number">-1</span>));</span><br><span class="line">                sum +=price(i)-price(i<span class="number">-1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d %02d:%02d:%02d %d $%.2lf\n&quot;</span>,</span><br><span class="line">                call[i<span class="number">-1</span>].day,call[i<span class="number">-1</span>].hour,call[i<span class="number">-1</span>].minute,</span><br><span class="line">                call[i].day,call[i].hour,call[i].minute,call[i].time - call[i<span class="number">-1</span>].time,price(i)-price(i<span class="number">-1</span>));</span><br><span class="line">                sum +=price(i)-price(i<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Total amount: $%.2lf\n&quot;</span>,sum);<span class="comment">//输出最后一个人的总花费</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;A long-distance telephone company charges its customers by the following rules:&lt;/p&gt;
&lt;p&gt;Making a long-distance call costs a certain amount</summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>1015 Reversible Primes PAT (Advanced Level) Practice</title>
    <link href="http://example.com/[object%20Object]/2022/04/20/test-16/"/>
    <id>http://example.com/[object%20Object]/2022/04/20/test-16/</id>
    <published>2022-04-20T09:50:40.000Z</published>
    <updated>2022-04-20T10:03:59.767Z</updated>
    
    <content type="html"><![CDATA[<p>A <strong>reversible prime</strong> in any number system is a prime whose “reverse” in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime.</p><p>Now given any two positive integers <strong>N</strong> (&lt;105) and <strong>D</strong> (1&lt;<strong>D</strong>≤10), you are supposed to tell if <strong>N</strong> is a reversible prime with radix <strong>D</strong>.</p><p><em>Input Specification:</em></p><p>The input file consists of several test cases. Each case occupies a line which contains two integers <strong>N</strong> and <strong>D</strong>. The input is finished by a negative <strong>N</strong>.</p><p><em>Output Specification:</em></p><p>For each test case, print in one line <code>Yes</code> if <strong>N</strong> is a reversible prime with radix <strong>D</strong>, or <code>No</code> if not.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">73 10</span><br><span class="line">23 2</span><br><span class="line">23 10</span><br><span class="line">-2</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><em>Analysis</em><br>可逆素数就是倒着写还是素数，题目说给一个数同时给一个进制D，问在进制D下这个数是可逆素数吗？只要把这个数转换成进制D然后再倒叙转换成十进制验证就好了。要注意这个给的数本身可能不是素数，需要加一个判断。<br>有意思的是第一个测试73，在《生活大爆炸》中谢尔顿说73是最完美的数，因为73是质数，而且是第21 个质数，21 刚好是7×3，而37 是第12 个质数，12 刚好是第21 反过来，好像谢尔顿提出这个问题也是在生活大爆炸的73集( ´ ▽ &#96; )ﾉ</p><p><em>Code</em></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">isprime</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">verify</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isprime (n) == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        s[index++] = n%d;</span><br><span class="line">        n = n/d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        rev += s[i] * <span class="built_in">pow</span>(d,index - i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isprime(rev) == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line">        <span class="keyword">if</span>(verify(n,d) == <span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;A &lt;strong&gt;reversible prime&lt;/strong&gt; in any number system is a prime whose “reverse” in that number system is also a prime. For example in</summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>1014 Waiting in Line PAT (Advanced Level) Practice</title>
    <link href="http://example.com/[object%20Object]/2022/04/20/test-15/"/>
    <id>http://example.com/[object%20Object]/2022/04/20/test-15/</id>
    <published>2022-04-19T20:11:36.000Z</published>
    <updated>2022-04-20T03:49:37.469Z</updated>
    
    <content type="html"><![CDATA[<p>Suppose a bank has <strong>N</strong> windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are:</p><ul><li>The space inside the yellow line in front of each window is enough to contain a line with <strong>M</strong> customers. Hence when all the <strong>N</strong> lines are full, all the customers after (and including) the (<strong>NM</strong>+1)st one will have to wait in a line behind the yellow line.</li><li>Each customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number.</li><li><strong>Customeri</strong> will take <strong>Ti</strong> minutes to have his&#x2F;her transaction processed.</li><li>The first <strong>N</strong> customers are assumed to be served at 8:00am.</li></ul><p>Now given the processing time of each customer, you are supposed to tell the exact time at which a customer has his&#x2F;her business done.</p><p>For example, suppose that a bank has 2 windows and each window may have 2 customers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning, <strong>Customer1</strong> is served at <strong>window1</strong>while<strong>Customer2</strong> is served at <strong>window2</strong>. <strong>Customer3</strong> will wait in front of  <strong>window1</strong> and  <strong>Customer4</strong> will wait in front of <strong>window2</strong>.  <strong>Customer5</strong> will wait behind the yellow line.</p><p>At 08:01, <strong>Customer1</strong> is done and <strong>Customer5</strong>  enters the line in front of  <strong>window1</strong> since that line seems shorter now. <strong>Customer2</strong> will leave at 08:02, <strong>Customer4</strong> at 08:06, <strong>Customer3</strong>  at 08:07, and finally <strong>Customer5</strong> at 08:10.</p><p><em>Input Specification:</em></p><p>Each input file contains one test case. Each case starts with a line containing 4 positive integers: <strong>N</strong> (≤20, number of windows), <strong>M</strong> (≤10, the maximum capacity of each line inside the yellow line), <strong>K</strong> (≤1000, number of customers), and <strong>Q</strong> (≤1000, number of customer queries).</p><p>The next line contains <strong>K</strong> positive integers, which are the processing time of the <strong>K</strong> customers.</p><p>The last line contains <strong>Q</strong> positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to <strong>K</strong>.</p><p><em>Output Specification:</em></p><p>For each of the <strong>Q</strong> customers, print in one line the time at which his&#x2F;her transaction is finished, in the format <code>HH:MM</code> where <code>HH</code> is in [08, 17] and <code>MM</code> is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output <code>Sorry</code> instead.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 2 7 5</span><br><span class="line">1 2 6 4 3 534 2</span><br><span class="line">3 4 5 6 7</span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">08:07</span><br><span class="line">08:06</span><br><span class="line">08:10</span><br><span class="line">17:00</span><br><span class="line">Sorry</span><br></pre></td></tr></table></figure></div><p><em>Analysis</em></p><p>题意为有N个窗口，每个窗口前有M个等待位置，当M个等待位置未满，顾客选择队伍最短的那个，如果有并列，选择序号最小的那个。如果等待位置满了，需要有空缺才可以顺序补上。<br>可以想象K个顾客是排好队进银行的，在前N×M个位置，只要顺序给N个窗口分发即可，分发M次。如果N×M循环顾客还没有发完，就要进行选则。每个窗口创建一个结构体变量，内部记录poptime，endtime，和一个长度为M的队。poptime为队头的人结束的时间点，endtime为队尾结束的时间。同时利用endtime也可以确定新入队的元素是否会被说sorry。如果endtime已经到了17:00，后面入队的人一定会被说sorry。<br>利用辅助数组time[i] 记录第i 个人服务结束的时间，sorry[i]数组标记第 i 个人是否会被说sorry，时间以8:00为原点以分钟累计，在输出时转换一下就好。<br>poptime并不是时间段，而是时间点，在前N×M个人入队时都为窗口第一个人服务时间，因为这些人是同时开始排队的。N×M人之后，下一个人选择poptime最小的窗口入队，因为这一队是最早有空位置的，该队队头出队新人入队，用数组模拟循环队列，出队后，这个窗口的的poptime加上下一个人的服务时间，作为这个队下一次弹出的时间。如此循环直到所有人服务结束。<br>思路来自柳神，详情请参考以下链接：</p><p><a class="link"   href="https://www.liuchuo.net/archives/2943" >1014 Waiting in Line (30)-PAT甲级真题（queue的应用） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><em>Code</em></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> poptime,endtime;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">queue</span>[<span class="number">15</span>];</span><br><span class="line">    <span class="type">int</span> head,tail;</span><br><span class="line">&#125;Node;</span><br><span class="line">Node window[<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> serve[<span class="number">1015</span>];        <span class="comment">//每个人服务时常</span></span><br><span class="line"><span class="type">int</span> time[<span class="number">1015</span>];         <span class="comment">//每个人服务结束时间</span></span><br><span class="line"><span class="type">int</span> sorry[<span class="number">1015</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//被说sorry标记</span></span><br><span class="line"><span class="type">int</span> N,M,K,Q;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;N,&amp;M,&amp;K,&amp;Q);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=K;i++)&#123;        <span class="comment">//获取每个人办理时常</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;serve[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;        <span class="comment">//初始化</span></span><br><span class="line">        window[i].endtime = <span class="number">0</span>;</span><br><span class="line">        window[i].head = <span class="number">0</span>;</span><br><span class="line">        window[i].tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=M;i++)&#123;        <span class="comment">//处理前N*M个数据，直接顺序填入窗口即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt;= K)&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[j].endtime &gt;= <span class="number">540</span>)sorry[index] =<span class="number">1</span>;       <span class="comment">//结束时间必须在17:00前还是开始必须在17:00前？</span></span><br><span class="line">                window[j].endtime+=serve[index];</span><br><span class="line">                time[index] = window[j].endtime;</span><br><span class="line">                window[j].<span class="built_in">queue</span>[window[j].tail++] = serve[index];</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span>)window[j].poptime = serve[index];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> v,min;</span><br><span class="line">    <span class="keyword">while</span>(index &lt;=K)&#123;                       <span class="comment">//如果填完N*M个还有客户的话继续更新</span></span><br><span class="line">        v = <span class="number">1</span>,min = window[<span class="number">1</span>].poptime;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=N;i++)&#123;            <span class="comment">//选择一个弹出时间最短的，也就是最早有空位的那个窗口</span></span><br><span class="line">            <span class="keyword">if</span>(window[i].poptime &lt; min)&#123;v = i;min = window[i].poptime;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(window[v].endtime &gt;=<span class="number">540</span>)sorry[index] = <span class="number">1</span>;    <span class="comment">//如果窗口服务时常已经超过17:00，后面的人会被说sorry</span></span><br><span class="line">        window[v].endtime +=serve[index];               <span class="comment">//更新窗口结束服务时间</span></span><br><span class="line">        time[index] = window[v].endtime;                <span class="comment">//更新该客户服务结束时间</span></span><br><span class="line">        window[v].head++;                               <span class="comment">//该窗口弹出出队对头客户</span></span><br><span class="line">        <span class="keyword">if</span>(window[v].head &gt;=<span class="number">15</span>)window[v].head = <span class="number">0</span>;      <span class="comment">//循环队</span></span><br><span class="line">        window[v].poptime +=window[v].<span class="built_in">queue</span>[window[v].head];        <span class="comment">//更新弹出时间</span></span><br><span class="line">        window[v].<span class="built_in">queue</span>[window[v].tail++] = serve[index];           <span class="comment">//入队</span></span><br><span class="line">        <span class="keyword">if</span>(window[v].tail &gt;=<span class="number">15</span>)window[v].tail =<span class="number">0</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=Q;i++)&#123;                                         <span class="comment">//查询时间，将分钟累计转换成精确时间</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="keyword">if</span>(sorry[num] ==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;Sorry\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d\n&quot;</span>,time[num]/<span class="number">60</span> + <span class="number">8</span>,time[num]%<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Suppose a bank has &lt;strong&gt;N&lt;/strong&gt; windows open for service. There is a yellow line in front of the windows which devides the waiting </summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
    <category term="queue" scheme="http://example.com/tags/queue/"/>
    
    <category term="队" scheme="http://example.com/tags/%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>1013 Battle Over Cities PAT (Advanced Level) Practice</title>
    <link href="http://example.com/[object%20Object]/2022/04/20/test-14/"/>
    <id>http://example.com/[object%20Object]/2022/04/20/test-14/</id>
    <published>2022-04-19T17:44:09.000Z</published>
    <updated>2022-04-19T17:57:55.261Z</updated>
    
    <content type="html"><![CDATA[<p>It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from&#x2F;toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly.</p><p>For example, if we have 3 cities and 2 highways connecting <strong>city</strong>1-<strong>city</strong>2 and <strong>city</strong>1-<strong>city</strong>3. Then if <strong>city</strong>1 is occupied by the enemy, we must have 1 highway repaired, that is the highway <strong>city</strong>2-<strong>city</strong>3.</p><p><em>Input Specification:</em></p><p>Each input file contains one test case. Each case starts with a line containing 3 numbers <strong>N</strong> (&lt;1000), <strong>M</strong> and <strong>K</strong>, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then <strong>M</strong> lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to <strong>N</strong>. Finally there is a line containing <strong>K</strong> numbers, which represent the cities we concern.</p><p><em>Output Specification:</em></p><p>For each of the <strong>K</strong> cities, output in a line the number of highways need to be repaired if that city is lost.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 2 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure></div><p><em>Analysis</em><br>题意为给出N个城市，通过M条高速路相连，问如果丢失了 i 城市，需要修几条路能确保所有城市仍然相连，其实就是联通分量个数减去一。在学习深度搜索的时候有说过为了应对有的节点不相连，就在dfs最外层加一个循环，这个循环每进入一次dfs其实就说明有一个联通分量，所以在进入dfs时用一个变量统计就可求出联通分量个数了。<br>重点要知道dfs可以统计联通分量个数</p><p><em>Code</em></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> edge[<span class="number">1015</span>][<span class="number">1015</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> visited[<span class="number">1015</span>];</span><br><span class="line"><span class="type">int</span> N,M,K;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="literal">false</span> &amp;&amp; edge[v][i] ==<span class="number">1</span>)&#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;N,&amp;M,&amp;K);</span><br><span class="line">    <span class="type">int</span> v1,v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=M;i++)&#123;                <span class="comment">//获取M条边</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v1,&amp;v2);</span><br><span class="line">        edge[v1][v2] = edge[v2][v1] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=K;i++)&#123;                <span class="comment">//查找K次</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);                     <span class="comment">//被占领的城市</span></span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(visited));  <span class="comment">//重置visited数组</span></span><br><span class="line">        visited[v] = <span class="literal">true</span>;cnt = <span class="number">0</span>;          <span class="comment">//将被占领城市标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=N;i++)&#123;            <span class="comment">//深搜</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="literal">false</span>)&#123;</span><br><span class="line">                dfs(i);                     <span class="comment">//对i节点深搜</span></span><br><span class="line">                cnt++;                      <span class="comment">//统计强联通分量个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from&amp;</summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
    <category term="dfs" scheme="http://example.com/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>1012 The Best Rank PAT (Advanced Level) Practice</title>
    <link href="http://example.com/[object%20Object]/2022/04/20/test-13/"/>
    <id>http://example.com/[object%20Object]/2022/04/20/test-13/</id>
    <published>2022-04-19T16:18:20.000Z</published>
    <updated>2022-04-19T16:24:39.188Z</updated>
    
    <content type="html"><![CDATA[<p>To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: <code>C</code> - C Programming Language, <code>M</code> - Mathematics (Calculus or Linear Algrbra), and <code>E</code> - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.</p><p>For example, The grades of <code>C</code>, <code>M</code>, <code>E</code> and <code>A</code> - Average of 4 students are given as the following:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StudentID  C  M  E  A</span><br><span class="line">310101     98 85 88 90</span><br><span class="line">310102     70 95 88 84</span><br><span class="line">310103     82 87 94 88</span><br><span class="line">310104     91 91 91 91</span><br></pre></td></tr></table></figure></div><p>Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.</p><p><em>Input Specification:</em></p><p>Each input file contains one test case. Each case starts with a line containing 2 numbers <strong>N</strong> and <strong>M</strong> (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then <strong>N</strong> lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of <code>C</code>, <code>M</code> and <code>E</code>. Then there are <strong>M</strong> lines, each containing a student ID.</p><p><em>Output Specification:</em></p><p>For each of the <strong>M</strong> students, print in one line the best rank for him&#x2F;her, and the symbol of the corresponding rank, separated by a space.</p><p>The priorities of the ranking methods are ordered as <code>A</code> &gt; <code>C</code> &gt; <code>M</code> &gt; <code>E</code>. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.</p><p>If a student is not on the grading list, simply output <code>N/A</code>.</p><p><em>Sample Input:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">310101 98 85 88</span><br><span class="line">310102 70 95 88</span><br><span class="line">310103 82 87 94</span><br><span class="line">310104 91 91 91</span><br><span class="line">310105 85 90 90</span><br><span class="line">310101</span><br><span class="line">310102</span><br><span class="line">310103</span><br><span class="line">310104</span><br><span class="line">310105</span><br><span class="line">999999</span><br></pre></td></tr></table></figure></div><p><em>Sample Output:</em></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 C</span><br><span class="line">1 M</span><br><span class="line">1 E</span><br><span class="line">1 A</span><br><span class="line">3 A</span><br><span class="line">N/A</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><em>Analysis</em></p><p>简单题，不过说一下吧，题意是给n个学生的 学号、c语言成绩、数学成绩、英语成绩、并要求平均分。给出m个学号，输出该学生这四项分数中最高的一个排名，如果有并列按平均&gt;c语言&gt;数学&gt; 英语的优先级，找不到输出n&#x2F;a。由于数据量最多只有2000，那每一次都遍历一遍求出要找的同学每一门课的排名输出最高即可。</p><p><em>Code</em></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> n,M;</span><br><span class="line"><span class="type">char</span> name[<span class="number">2015</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> math[<span class="number">2015</span>],clanguage[<span class="number">2015</span>],english[<span class="number">2015</span>],average[<span class="number">2015</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">input</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d%d&quot;</span>,name[i],&amp;clanguage[i],&amp;math[i],&amp;english[i]);</span><br><span class="line">        average[i] = (clanguage[i] +math[i] +english[i] )/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> id[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">char</span> id[])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(id,name[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> loc;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    input();                            <span class="comment">//获取输入</span></span><br><span class="line"><span class="comment">//    for(int i = 1;i&lt;=5;i++)printf(&quot;%s %d %d %d %d\n&quot;,name[i],clanguage[i],math[i],english[i],average[i]);</span></span><br><span class="line">    <span class="type">int</span> c,m,e,a;                        <span class="comment">//存储该同学每一门课的最高排名</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=M;i++)&#123;            <span class="comment">//m次查询</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,id);                 <span class="comment">//获取同学id</span></span><br><span class="line">        loc = search(id);               <span class="comment">//查询id数据下标</span></span><br><span class="line"><span class="comment">//        printf(&quot;--%s %d\n&quot;,id,loc);</span></span><br><span class="line">        <span class="keyword">if</span>(loc)&#123;                        <span class="comment">//找到</span></span><br><span class="line">            c = m = e = a = <span class="number">1</span>;          <span class="comment">//排名初试为1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;    <span class="comment">//遍历所有学生，如果有大于该门课的成绩，这个排名加一</span></span><br><span class="line">                <span class="keyword">if</span>(math[i] &gt; math[loc])m++;</span><br><span class="line">                <span class="keyword">if</span>(english[i] &gt; english[loc])e++;</span><br><span class="line">                <span class="keyword">if</span>(clanguage[i] &gt;clanguage[loc])c++;</span><br><span class="line">                <span class="keyword">if</span>(average[i] &gt; average[loc])a++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a &lt;=c &amp;&amp; a &lt;=m &amp;&amp; a &lt;=e)<span class="built_in">printf</span>(<span class="string">&quot;%d A\n&quot;</span>,a);              <span class="comment">//平均排名最高</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c &lt;= a &amp;&amp; c &lt;=e &amp;&amp; c &lt;=m)<span class="built_in">printf</span>(<span class="string">&quot;%d C\n&quot;</span>,c);        <span class="comment">//c排名最高</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m &lt;=a &amp;&amp; m &lt;=c &amp;&amp; m &lt;=e)<span class="built_in">printf</span>(<span class="string">&quot;%d M\n&quot;</span>,m);         <span class="comment">//数学排名最高</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d E\n&quot;</span>,e);                                    <span class="comment">//英语排名最高</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                          <span class="comment">//没找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;N/A\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: &lt;code&gt;C&lt;/code&gt; - C Pro</summary>
      
    
    
    
    
    <category term="PAT甲级" scheme="http://example.com/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
  </entry>
  
</feed>
