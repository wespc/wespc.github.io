<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="peng cheng">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://wespc.github.io/[object object]/2023/03/02/shellscript/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="网站Shell Scripting Tutorial  1. 介绍这个教程的目的帮人们理解shell脚本编程的基本知识(aka shell scripting), 也可能会介绍一些在Bourne shell下简单但强大的编程技巧. 因此，它已被编写为一对一或小组教程和练习的基础，并作为后续使用的参考。 面向读者:本教程假定具有一些先前的经验;即：  使用交互式 Unix&#x2F;Linux sh">
<meta property="og:type" content="article">
<meta property="og:title" content="shellscript 教程">
<meta property="og:url" content="https://wespc.github.io/[object%20Object]/2023/03/02/shellscript/index.html">
<meta property="og:site_name" content="ピーターのブログ">
<meta property="og:description" content="网站Shell Scripting Tutorial  1. 介绍这个教程的目的帮人们理解shell脚本编程的基本知识(aka shell scripting), 也可能会介绍一些在Bourne shell下简单但强大的编程技巧. 因此，它已被编写为一对一或小组教程和练习的基础，并作为后续使用的参考。 面向读者:本教程假定具有一些先前的经验;即：  使用交互式 Unix&#x2F;Linux sh">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b7822b97-9aaa-4532-aa09-aaa3f31f88d5/Untitled.png">
<meta property="article:published_time" content="2023-03-02T11:47:24.000Z">
<meta property="article:modified_time" content="2023-04-08T01:58:53.001Z">
<meta property="article:author" content="Peng Cheng">
<meta property="article:tag" content="shellscript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b7822b97-9aaa-4532-aa09-aaa3f31f88d5/Untitled.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/IMG_3147_2.jpeg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/IMG_3147_2.jpeg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/IMG_3147_2.jpeg">
    <!--- Page Info-->
    
    <title>
        
            shellscript 教程 -
        
        チェンのブログ
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    
        <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    
<script src="/js/libs/anime.min.js"></script>

    <h1 class="ml13">
        チェンのブログ
    </h1>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }
    </script>
</div>
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    window.config = {"hostname":"wespc.github.io","root":"/","language":"en"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left"},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":["hi there!!"]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/568368.JPEG","dark":"/images/568368.JPEG"},"title":"Enjoy your wonderful life","subtitle":{"text":["time waits for no one!","But we have an unstoppable will to go forward.","好风吹进生活里"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"links":{"github":"https://github.com/wespc","instagram":null,"zhihu":null,"twitter":null,"email":"pcid757@gmail.com","spotify":"https://open.spotify.com/user/31kayfa46vzpavdsdrwhn3xotqyu?si=04cf3f7709db4d45","douban":"https://www.douban.com/people/wisepc/"},"qrs":{"weixin":"/images/IMG_3798.JPG"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.6.0","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":null},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ピーターのブログ" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container">

    <div class="navbar-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/IMG_3147_2.jpeg">
                </a>
            
            <a class="logo-title" href="/">
                
                チェンのブログ
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">31</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">49</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                <div class="w-full flex items-center pt-6 justify-start">
                    <h1 class="article-title-regular text-second-text-color text-4xl md:text-6xl font-bold px-2 sm:px-6 md:px-8 py-3">shellscript 教程</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/IMG_3147_2.jpeg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">peng cheng</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">hi there!!</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-03-02 19:47:24</span>
        <span class="mobile">2023-03-02 19:47:24</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-04-08 09:58:53</span>
            <span class="mobile">2023-04-08 09:58:53</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/shellscript/">shellscript</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <h1 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h1><p><a class="link"   target="_blank" rel="noopener" href="https://www.shellscript.sh/index.html" >Shell Scripting Tutorial <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><h2 id="这个教程的目的"><a href="#这个教程的目的" class="headerlink" title="这个教程的目的"></a>这个教程的目的</h2><p>帮人们理解shell脚本编程的基本知识(aka shell scripting), 也可能会介绍一些在Bourne shell下简单但强大的编程技巧. 因此，它已被编写为一对一或小组教程和练习的基础，并作为后续使用的参考。</p>
<h2 id="面向读者"><a href="#面向读者" class="headerlink" title="面向读者:"></a>面向读者:</h2><p>本教程假定具有一些先前的经验;即：</p>
<ul>
<li>使用交互式 Unix&#x2F;Linux shell</li>
<li>最少的编程知识 - 变量、函数的使用是有用的背景知识</li>
<li>了解一些 Unix&#x2F;Linux 命令，并有能力使用一些更常用的命令。 （ls、cp、echo 等）</li>
<li>使用 ruby、perl、python、C、Pascal 或任何编程语言（甚至 BASIC）的进程员，他们可能会阅读 shell 脚本，但并不认为他们确切地理解它们是如何工作的。</li>
</ul>
<h2 id="本教程中使用的排版约束"><a href="#本教程中使用的排版约束" class="headerlink" title="本教程中使用的排版约束"></a>本教程中使用的排版约束</h2><p>重要的单词会在第一次出现时用<em>斜体</em>标出</p>
<p>代码段和脚本展示为等宽文本.</p>
<p>命令行条目前面将带有美元符号 （$）。如果您的提示不同,请输入命令:</p>
<p>然后，您的互动应与给出的示例匹配（例如下面的 .&#x2F;my-script.sh）。</p>
<p>脚本输出（例如下面的“Hello World”）显示在行首。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;#!/bin/sh&#x27;</span> &gt; my-script.sh</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;echo Hello World&#x27;</span> &gt;&gt; my-script.sh</span><br><span class="line">$ <span class="built_in">chmod</span> 755 my-script.sh</span><br><span class="line">$ ./my-script.sh</span><br><span class="line">Hello World</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div>

<p>整个脚本将以灰色背景显示，并包括对脚本纯文本的引用（如果可用）：</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.shellscript.sh/eg/my-script.sh.txt" >my-script.sh <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># This is a comment!</span></span><br><span class="line"><span class="built_in">echo</span> Hello World	<span class="comment"># This is a comment, too!</span></span><br></pre></td></tr></table></figure></div>

<p>请注意，要使文档可执行，必须设置可执行位，对于 shell 脚本，还必须设置可读位：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> a+rx my-script.sh</span><br><span class="line">$ ./my-script.sh</span><br></pre></td></tr></table></figure></div>

<h1 id="2-哲学"><a href="#2-哲学" class="headerlink" title="2.哲学"></a>2.哲学</h1><p>Shell脚本编程在一些Unix系统管理员中有点不好。一般因为这两件事</p>
<ul>
<li>与 C 进程甚至解释型 Perl 进程相比，解释进程的运行速度。</li>
<li>由于编写简单的批处理作业类型的 shell 脚本很容易，因此周围有很多质量差的 shell 脚本。</li>
</ul>
<p>部分由于这一点，创建好的 shell 脚本存在一定的大男子主义。例如，可以用作CGI进程的脚本，而不会在速度上输给Perl太多（尽管在许多情况下，两者都会输给C，这是速度的唯一标准）。</p>
<p>有许多因素可以进入好的、干净的、快速的 shell 脚本。</p>
<ul>
<li>最重要的标准必须是 感情 可阅读的排版.</li>
<li>第二是避免没必要的命令.</li>
</ul>
<p>清晰的布局使得 shell 脚本看起来像“黑魔法”，是易于维护和理解的脚本</p>
<p>您可能会认为使用简单的脚本，这不是一个太重要的问题，但这里有两件事值得牢记。</p>
<ol>
<li>首先，一个简单的脚本会比预期的更频繁地成长为一个庞大而复杂的脚本。</li>
<li>其次，如果没有其他人能理解它是如何工作的，你将在余生中自己维护它！</li>
</ol>
<p>关于 shell 脚本的某些东西似乎使它们特别容易被严重缩进，并且由于主要的控制结构是 if&#x2F;then&#x2F;else 和循环，缩进对于理解脚本的作用至关重要。</p>
<p>许多 shell 脚本中的一个弱点是以下行：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /tmp/myfile | grep <span class="string">&quot;mystring&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>这样会快的多</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;mystring&quot;</span> /tmp/myfile</span><br></pre></td></tr></table></figure></div>

<p>不多，你可能会考虑; 操作系统必须加载 &#x2F;bin&#x2F;grep可执行文档, 在我的系统上，这是一个相当小的 75600 字节， 在内存中开辟管道(pipe)用于传输, 加载运行 &#x2F;bin&#x2F;cat 可执行文件,他甚至更小在我的计算机上只有9528字节,将其连接到管道的输入，然后让它运行。</p>
<p>当然,OS存在就是做这种事的,通常这样做也很高效.但如果在一个循环中这个命令被运行很多次, 因为不用定位和加载 cat可执行文件,设置和释放管道而产生的不同就很不同,特别是CGI环境, 已经有很多其他因素拖慢进程, 而不会使脚本本身成为太大障碍.一些Unices在他们所谓的“创建和拆除流程”方面比其他Unices更有效率 - 即即加载它们，执行它们，然后再次清除它们。但是，无论您的Unix风格如何做到这一点，它都宁愿根本不需要这样做。</p>
<p>因此，您可能会听到提到没用的 cat 奖（UUoC），</p>
<p><a class="link"   target="_blank" rel="noopener" href="http://catb.org/jargon/html/U/UUOC.html" >UUOC <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>在某些圈子中也被称为在严肃的shell脚本中无偿使用猫一词的奖项，该奖项不时在comp.unix.shell新闻组上流传。这纯粹是同行相互检查并确保事情正确完成的一种方式。</p>
<p>这让我很好地想到了别的东西：永远不要觉得自己与自己的 shell 脚本太近;就其性质而言，源头不能关闭。如果您向客户提供 shell 脚本，他&#x2F;她可以很容易地检查它。因此，您不妨接受它将由您传递给的任何人进行检查;通过 GPL 利用这一点 - 鼓励人们免费为您提供反馈和错误修复！</p>
<h1 id="3-第一个脚本"><a href="#3-第一个脚本" class="headerlink" title="3.第一个脚本"></a>3.第一个脚本</h1><p>作为我们第一个脚本,我们就写一个输出 “Hello World” 的脚本.然后，我们将尝试从Hello World进程中获得更多比您读过的任何其他教程更多的内容：-）</p>
<p>创建一个文件如下:</p>
<p>first.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># This is a comment!</span></span><br><span class="line"><span class="built_in">echo</span> Hello World        <span class="comment"># This is a comment, too!</span></span><br></pre></td></tr></table></figure></div>

<p>第一行告诉 Unix 这个文件要被 by&#x2F;bin&#x2F;sh 执行. 这是 Unix系统的Bourne shell 的标准位置. 如果你在用 GNU&#x2F;Linux, &#x2F;bin&#x2F;sh 通常是到bash的符号链.</p>
<p>第二行以特殊符号 <code>#</code> 开始. 这标志着这行是注释, 会完全被shell忽略.</p>
<p>唯一的例外是文件的第一行 以<code>#!</code> 开始,就像我们做的那样. 这是Unix 特别对待的特殊指令. 这意味着即使你用csh,ksh 或其他任何交互式shell,  接下来的东西应该被 Bourne shell 解释.</p>
<p>相似的, Perl 脚本会已 <code>#!/usr/bin/perl</code> 开始,会告诉你的交互式shell接下来的 进程应该被perl执行. 对于Bourne shell 我们会继续用 <code>#!/bin/sh.</code></p>
<p>第三行运行一个命令 :<code>echo</code>, 和两个参数 ,第一个 “Hello”, 第二个”World”.</p>
<p>注意<code>echo</code> 会自动放一个空格在他和参数之间. <code>#</code> 仍然标注一个注释. #和他之后的任何内容会被shell忽视.</p>
<p>现在运行 <code>chmod 755 first.sh</code> 让文本可执行, 运行 <code>./first.sh</code> 你的屏幕之后应该看起看起来像这样.</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> 755 first.sh</span><br><span class="line">$ ./first.sh</span><br><span class="line">Hello World</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div>

<p>你也许已经猜到了,你也可以这样运行:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> Hello World</span><br><span class="line">Hello World</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div>

<p>现在让我们做点改变.</p>
<p>首先注意<code>echo</code> 在他的参数之间放了一个空格, 在”Hello” 和”World” 之间多放几个空格. 你预期会输出什么? 放TAB 在中间呢?</p>
<p>像往常一样,编写程序看看结果.</p>
<p>输出完全一样. 我们用两个参数调用<code>echo</code>, 他并不关心中间的空格.</p>
<p>现在修改代码重试:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># This is a comment!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello      World&quot;</span>       <span class="comment"># This is a comment, too!</span></span><br></pre></td></tr></table></figure></div>

<p>这次他起作用了,你也许也猜到了.如果你有其他编程语言经验.</p>
<p>但理解更复杂的指令和shell脚本的关键是理解并能解释为什么?<code>echo</code> 现在只有一个参数,字符串”Hello       World”. 他完全打印出来.</p>
<p>这里要理解的一点是，shell 在将参数传递给被调用的进程<strong>之前</strong>解析参数。</p>
<p>在这种情况下，它去掉引号，但将字符串作为一个参数传递。</p>
<p>作为最后一个例子, 输入下列脚本.. 尝试运行前猜测结果.</p>
<p>first2.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># This is a comment!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello      World&quot;</span>       <span class="comment"># This is a comment, too!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello * World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> Hello * World</span><br><span class="line"><span class="built_in">echo</span> Hello      World</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span> World</span><br><span class="line"><span class="built_in">echo</span> Hello <span class="string">&quot;     &quot;</span> World</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello &quot;</span>*<span class="string">&quot; World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> `hello` world</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> world</span><br></pre></td></tr></table></figure></div>

<p>是不是所有的都猜到了,如果没有,不用担心,只是一些在后面的教程会提到的东西. … and yes, 我们会用到比echo更强大的指令.</p>
<h1 id="4-变量-Part-1"><a href="#4-变量-Part-1" class="headerlink" title="4. 变量 Part 1"></a>4. 变量 Part 1</h1><p>几乎每种现有的编程语言都有变量的概念-内存块的符号名称，我们可以为其赋值、读取和操作其内容。Bourne shell 也不例外，本节将介绍这个想法。环境为我们设置的变量在变量 - 第二部分中进一步介绍. 让我们回顾一下我们的第一个 Hello World 示例。这可以使用变量来完成（尽管这是一个如此简单的例子)，它并不真正保证它！请注意，“&#x3D;”符号周围不能有空格：<code>VAR=value</code>; <code>VAR = value</code>不起作用。第一个例子中,shell 会看到“&#x3D;”符号，并将命令视为变量赋值。在第二种情况下，shell 假定 VAR 是命令的名称并尝试执行它。</p>
<p>如果你思考下, 这说得通, 你还能怎幺告诉它运行命令 VAR，它的第一个参数是“&#x3D;”，它的第二个参数是“value”？</p>
<p>在 var.sh 中输入以下代码：</p>
<p>var.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">MY_MESSAGE=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$MY_MESSAGE</span></span><br></pre></td></tr></table></figure></div>

<p>这会将字符串“Hello World”分配给变量<code>MY_MESSAGE</code>然后<code>echo</code>出变量的值。</p>
<p>请注意，我们需要字符串 Hello World 周围的引号。虽然我们可以摆脱 <code>echo Hello World</code>，因为echo将接受任意数量的参数，但一个变量只能保存一个值，因此必须将带有空格的字符串括起来，以便shell知道将其视为一个。否则，shell 将在分配 <code>MY_MESSAGE=Hello</code> 后尝试执行命令 <code>World</code>。</p>
<p>shell 并不关心变量的类型. 他们也许会存储字符串,正数,实数 任何你喜欢的.</p>
<p>用Perl的人一定因此很开心. 如果你从C, Pascal 或更糟 Ada 开始, 这就很奇怪了.</p>
<p>事实上,他们都以字符串存储.但是期望数字的例程可以这样对待它们。<br>如果你给一个变量赋值字符串然后尝试 +1, 你不会侥幸逃脱的：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ x=<span class="string">&quot;hello&quot;</span></span><br><span class="line">$ <span class="built_in">expr</span> <span class="variable">$x</span> + 1</span><br><span class="line"><span class="built_in">expr</span>: non-numeric argument</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div>

<p>这是因为外部进程 expr 只期望数字。但是两者之间没有语法差异：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MY_MESSAGE=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line">MY_SHORT_MESSAGE=hi</span><br><span class="line">MY_NUMBER=1</span><br><span class="line">MY_PI=3.142</span><br><span class="line">MY_OTHER_PI=<span class="string">&quot;3.142&quot;</span></span><br><span class="line">MY_MIXED=123abc</span><br></pre></td></tr></table></figure></div>

<p>但请注意，必须正确转义特殊字符以避免 shell 解释。</p>
<p>这在第六章会解释 转义字符.Escape Characters</p>
<p>我们可以使用 read 命令交互式设置变量名称;以下脚本会询问您的名字，然后亲自向您打招呼：</p>
<p>VAR2.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> What is your name?</span><br><span class="line"><span class="built_in">read</span> MY_NAME</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$MY_NAME</span> - hope you&#x27;re well.&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>Mario Bacinsky善意地向我指出，我最初错过了最后一行的双引号，这意味着单词“you’re”中的单引号不匹配，导致错误。正是这种事情会让 shell 程序员发疯，所以要小心他们！</p>
<p>这是用shell内置命令<code>read</code> 从标准输入读入一行到 提供的变量中.</p>
<p>注意 即使你给出你的全名而不用双引号括起来,他仍然可以正确输出. 这是怎么工作的? 对于前面的MY_MESSAGE变量，我们必须在它周围加上双引号来设置它。</p>
<p>是这样的,read指令自动在输入放置引号,所以空格不会出错.(当然，您需要引用输出 - 例如 <code>echo“$MY_MESSAGE”</code>）</p>
<h2 id="变量的范围"><a href="#变量的范围" class="headerlink" title="变量的范围"></a>变量的范围</h2><p>Bourne shell 中的变量可以不声明,像c中那样.但如果你尝试阅读 为声明变量, 结果是空串.没有warnings 或errors. 这可能造成隐含bugs. 如果你赋值<code>MY_OBFUSCATED_VARIABLE=Hello</code>  然后你什么也得不到(因为第二个OBFUSCATED 拼错了).</p>
<p>有一个名为 <code>export</code> 的命令，它对变量的范围有根本的影响。为了真正理解你的变量怎么了,你需要知道这是怎么工作的.</p>
<p>创建一个小shell 脚本, <code>myvar2.sh</code> :</p>
<p>myvar2.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;MYVAR is: <span class="variable">$MYVAR</span>&quot;</span></span><br><span class="line">MYVAR=<span class="string">&quot;hi there&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;MYVAR is: <span class="variable">$MYVAR</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>现在运行脚本:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./myvar2.sh</span><br><span class="line">MYVAR is:</span><br><span class="line">MYVAR is: hi there</span><br></pre></td></tr></table></figure></div>

<p>MYVAR 还没被设置为任何值,所以是空的.然后我们给他一个值, 然后他有了预期结果.</p>
<p>现在运行:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ MYVAR=hello</span><br><span class="line">$ ./myvar2.sh</span><br><span class="line">MYVAR is:</span><br><span class="line">MYVAR is: hi there</span><br></pre></td></tr></table></figure></div>

<p>他还是没有被设置,怎么回事?</p>
<p>当你从交互shell调用 myvar2.sh, 将生成一个新的 shell 来运行脚本。 这部分是因为 脚本开始行的 #!&#x2F;bin&#x2F;sh .我们之前提到的.</p>
<p>我们需要导出变量以便它被另一个进程继承 - 包括一个 shell 脚本。类型：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> MYVAR</span><br><span class="line">$ ./myvar2.sh</span><br><span class="line">MYVAR is: hello</span><br><span class="line">MYVAR is: hi there</span><br></pre></td></tr></table></figure></div>

<p>现在 看看脚本第三行,MYVAR的值变了, 但没有办法将值再传回你的交互shell. 尝试读MYVAR的值:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYVAR</span></span><br><span class="line">hello</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div>

<p>一旦shell 脚本退出,他的环境就摧毁了. 但MYVAR 保持在你的交互shell的值.</p>
<p>为了获得脚本中环境变化,我们必须获取脚本 - 这有效地在我们自己的交互式 shell 中运行脚本，而不是生成另一个 shell 来运行它。</p>
<p>我们可以通过“.”（点）命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ MYVAR=hello</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYVAR</span></span><br><span class="line">hello</span><br><span class="line">$ . ./myvar2.sh          <span class="comment"># 注意两点之间有空格,否则出错.</span></span><br><span class="line">MYVAR is: hello</span><br><span class="line">MYVAR is: hi there</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYVAR</span></span><br><span class="line">hi there</span><br></pre></td></tr></table></figure></div>

<p>现在，这个变化又进入了我们的shell！例如，这就是您的 .profile 或 .bash_profile 文档的工作方式。</p>
<p>注意在这个例子中,我们不需要 <code>export MYVAR</code>.感谢 sway 指出我最初说的是echo MYVAR ，而不是应该echo$MYVAR。另一个使用 shell 脚本容易犯错误的例子。关于变量，在这一点上值得一提的另一件事是考虑以下 shell 脚本：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;What is your name?&quot;</span></span><br><span class="line"><span class="built_in">read</span> USER_NAME</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$USER_NAME</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I will create you a file called <span class="variable">$USER_NAME_file</span>&quot;</span></span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$USER_NAME_file</span></span><br></pre></td></tr></table></figure></div>

<p>想想你会得到什么答案.例如,如果你输入steve作为USER_NAME, 脚本会创建 <code>steve_file</code> 吗?</p>
<p>事实上,不会.这会出错,除非有个变量叫做<code>USER_NME_file</code>. shell不知道变量在哪结束,剩下的从哪开始.我们该怎么定义?</p>
<p>答案是，我们将变量本身括在大括号中：</p>
<p>user.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;What is your name?&quot;</span></span><br><span class="line"><span class="built_in">read</span> USER_NAME</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$USER_NAME</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I will create you a file called <span class="variable">$&#123;USER_NAME&#125;</span>_file&quot;</span></span><br><span class="line"><span class="built_in">touch</span> <span class="string">&quot;<span class="variable">$&#123;USER_NAME&#125;</span>_file&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>脚本现在知道我们引用变量 <code>USER_NAME</code> 并且我们希望它以“_file”为后缀。这可能是许多新的 shell 脚本进程员的垮台，因为问题的根源可能很难追踪。</p>
<p>还要注意“${USER_NAME}_file”周围的引号 - 如果用户输入“Steve Parker”（注意空格），那幺如果没有引号，传递给 touch 的参数将是 Steve 和 Parker_file - 也就是说，我们实际上是在创建 steve 和Parker_file，这是要创建的两个文档，而不是一个。引号避免了这一点。感谢克里斯强调这一点。</p>
<h1 id="5-通配符-Wildcards"><a href="#5-通配符-Wildcards" class="headerlink" title="5 通配符 Wildcards"></a>5 通配符 Wildcards</h1><p>通配符实在不算什么新的内容如果你之前用Unix.</p>
<p>不过，它们在 shell 脚本中的用处并不一定很明显。本节实际上只是让旧的灰色单元格思考当您在 shell 脚本中时的外观 - 预测使用不同语法的效果是什幺。之后将使用，特别是在循环部分中。</p>
<p>首先考虑如何将所有文档从 &#x2F;tmp&#x2F;a 复制到 &#x2F;tmp&#x2F;b 中。所有.txt文档？所有.html文档？</p>
<p>希望你能想出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> /tmp/a/* /tmp/b/</span><br><span class="line">$ <span class="built_in">cp</span> /tmp/a/*.txt /tmp/b/</span><br><span class="line">$ <span class="built_in">cp</span> /tmp/a/*.html /tmp/b/</span><br></pre></td></tr></table></figure></div>

<p>现在，如何在不使用ls &#x2F;tmp&#x2F;a&#x2F;的情况下列出&#x2F;tmp&#x2F;a&#x2F;中的文档？echo &#x2F;tmp&#x2F;a&#x2F;* 怎幺样？这和ls输出之间的两个主要区别是什幺？怎么利用它？还是障碍？</p>
<p>如何将所有.txt文档重命名为 .bak？注意到，</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> *.txt *.bak</span><br></pre></td></tr></table></figure></div>

<p>不会有预期的效果;考虑一下在传递给 MV 之前，shell 如何对其进行扩展。 如果有帮助，请尝试使用 echo 而不是 mv 执行此操作。我们稍后会进一步研究这个问题，因为它使用了一些尚未涵盖的概念。</p>
<h1 id="6-转义字符"><a href="#6-转义字符" class="headerlink" title="6. 转义字符"></a>6. 转义字符</h1><p>某些字符对shell很重要;例如，我们已经看到，使用双引号 （“） 字符会影响空格和 TAB 字符的处理方式，例如：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> Hello       World</span><br><span class="line">Hello World</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello       World&quot;</span></span><br><span class="line">Hello     World</span><br></pre></td></tr></table></figure></div>

<p>那我们怎么显示: Hello                 “World” ?</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello   \&quot;World\&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>第一个和最后一个 “ 字符将整个批次包装到一个传递给 echo 的参数中，以便两个单词之间的间距保持原样。但是代码：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello   &quot;</span> World <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>将解释为三个参数：</p>
<ol>
<li>“Hello       “</li>
<li>World</li>
<li>“”</li>
</ol>
<p>所以输出是</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello    World</span><br></pre></td></tr></table></figure></div>

<p>请注意，我们完全丢失了引号。这是因为第一个和第二个引号标记了 Hello 和后面的空格;第二个参数是未引用的“世界”，第三个参数是空字符串;””.</p>
<p>感谢帕特里克指出这一点：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello   &quot;</span>World<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>实际上只有一个参数（引号参数之间没有空格），您可以通过将 echo 命令替换为（例如）ls 来测试这一点。</p>
<p>大多数字符（<em>，’等）不是通过将它们放在双引号（“”）中来解释的（即，它们是字面意思）。它们按原样获取并传递给被调用的命令。使用星号 （</em>） 的示例是：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> *</span><br><span class="line">case.shtml escape.shtml first.shtml </span><br><span class="line">functions.shtml hints.shtml index.shtml </span><br><span class="line">ip-primer.txt raid1+0.txt</span><br><span class="line">$ <span class="built_in">echo</span> *txt</span><br><span class="line">ip-primer.txt raid1+0.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">*</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;*txt&quot;</span></span><br><span class="line">*txt</span><br></pre></td></tr></table></figure></div>

<p>在第一个示例中，* 扩展为表示当前目录中的所有文档。</p>
<p>在第二个示例中，*txt 表示以 txt 结尾的所有文档。</p>
<p>在第三个中，我们将 * 放在双引号中，它是按字面解释的。</p>
<p>在第四个示例中，同样适用，但我们已将 txt 附加到字符串中。</p>
<p>但是，“、$、’ 和 \ 仍然由 shell 解释，即使它们在双引号中也是如此。</p>
<p>反斜杠 （\） 字符用于标记这些特殊字符，以便它们不由 shell 解释，而是传递给正在运行的命令（例如，echo）。</p>
<p>所以输出字符串：（假设$X的值是 5）：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A quote is <span class="string">&quot;, backslash is \, backtick is `.</span></span><br><span class="line"><span class="string">A few spaces are    and dollar is $. <span class="variable">$X</span> is 5.</span></span><br></pre></td></tr></table></figure></div>

<p>我们必须写：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;A quote is \&quot;, backslash is \\, backtick is \`.&quot;</span></span><br><span class="line">A quote is <span class="string">&quot;, backslash is \, backtick is `.</span></span><br><span class="line"><span class="string">$ echo &quot;</span>A few spaces are    and dollar is \$. \<span class="variable">$X</span> is <span class="variable">$&#123;X&#125;</span>.<span class="string">&quot;</span></span><br><span class="line"><span class="string">A few spaces are    and dollar is $. <span class="variable">$X</span> is 5.</span></span><br></pre></td></tr></table></figure></div>

<p>我们已经知道 ” 对保存空格的作用, 美元符号 ($)特殊因为他标记变量, 那样 $X 会被shell替换为 变量x的内容. 反斜线()特殊因为他自身用来标记其他特殊字符.  我们需要以下选项来构建完整的 shell：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;This is \\ a backslash&quot;</span></span><br><span class="line">This is \ a backslash</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;This is \&quot; a quote and this is \\ a backslash&quot;</span></span><br><span class="line">This is <span class="string">&quot; a quote and this is \ a backslash</span></span><br></pre></td></tr></table></figure></div>

<p>因此，必须对反斜杠本身进行转义，以表明它是从字面上理解的。另一个特殊字符，反引号，将在后面的第 12 章 “外部进程”中讨论。</p>
<h1 id="7-循环-Loops"><a href="#7-循环-Loops" class="headerlink" title="7 循环 Loops"></a>7 循环 Loops</h1><p>大多数语言都有循环的概念：如果我们想重复一个任务二十次，我们不希望输入代码二十次，每次可能都有轻微的变化。</p>
<p>因此，我们在 Bourne shell 中有 for 和 while 循环。这比其他语言的功能要少一些，但没有人声称 shell 编程具有 C 的强大功能。</p>
<h2 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h2><p>for 循环循环遍历一组值，直到列表用尽：</p>
<p>for.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Looping ... number <span class="variable">$i</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<p>尝试这段代码并观察行为,请注意，这些值可以是任何值：</p>
<p>for2.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> hello 1 * 2 goodbye </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Looping ... i is set to <span class="variable">$i</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<p>这是非常值得尝试的。确保您了解这里发生的事情。尝试一下没有*并掌握这个想法.然后重新阅读通配符部分，并在 * 就位的情况下重试。在不同的目录中也尝试一下，用双引号括起来的 *，并尝试在前面 加上反斜杠 （*）</p>
<p>如果您目前无法访问 shell（在阅读本教程时手头有一个 shell 非常有用）,上面的脚本结果如下:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Looping .... number 1</span><br><span class="line">Looping .... number 2</span><br><span class="line">Looping .... number 3</span><br><span class="line">Looping .... number 4</span><br><span class="line">Looping .... number 5</span><br></pre></td></tr></table></figure></div>

<p>第二个例子:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Looping ... i is <span class="built_in">set</span> to hello</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to 1</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to (name of first file <span class="keyword">in</span> current directory)</span><br><span class="line">    ... etc ...</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to (name of last file <span class="keyword">in</span> current directory)</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to 2</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to goodbye</span><br></pre></td></tr></table></figure></div>

<p>因此，正如您所看到的，只需循环访问给定的任何输入，直到输入用完为止。</p>
<h2 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环."></a>While 循环.</h2><p>虽然循环可以更有趣！（取决于你对乐趣的看法，以及你多久走出家门一次……</p>
<p>while.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">INPUT_STRING=hello</span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$INPUT_STRING</span>&quot;</span> != <span class="string">&quot;bye&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Please type something in (bye to quit)&quot;</span></span><br><span class="line">  <span class="built_in">read</span> INPUT_STRING</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You typed: <span class="variable">$INPU</span></span></span><br><span class="line"><span class="string">_STRING&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<p>这里发生的情况是，echo 和 read 语句将无限期运行，直到您在出现提示时键入“bye”。</p>
<p>查看变量 - 第一部分，了解为什幺我们在测试之前设置 INPUT_STRING&#x3D;hello。这使它成为一个重复循环，而不是传统的while循环。</p>
<p>冒号 （:)始终计算为 true;虽然有时可能需要使用它，但通常最好使用真正的退出条件。将退出上述循环与以下循环进行比较;看看哪个更优雅。还要考虑一些每种情况都比另一种更有用：</p>
<p>while2.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Please type something in (^C to quit)&quot;</span></span><br><span class="line">  <span class="built_in">read</span> INPUT_STRING</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You typed: <span class="variable">$INPUT_STRING</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<p>另一个有用的技巧是<code>while read</code>循环。此示例使用 <code>case</code> 语句，我们将在后面介绍该语句。它从文档 myfile.txt 中读取，对于每一行，告诉你它认为正在使用什幺语言。</p>
<p>（注意：每行必须以 LF（换行符）结尾 - 如果 cat myfile.txt 不以空行结尾，则不会处理最后一行。</p>
<p>这会将文档“myfile.txt”读取，一次一行，读入变量“$input_text”。然后，case 语句检查 $input_text 的值。如果从myfile中读到的单词是“hello”.txt那幺它输出“English”。如果它是“gday”，那幺它将echo Australian。如果从myfile 独到的行内单词或多个单词没有与提供的任何模版匹配,那么 捕获全部 “*”默认选项会展示信息”Unknown Language: $input_text” - 当然,”$input-text” 是 他从myfile.txt 读到的行内值</p>
<p>while3.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> input_text</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$input_text</span> <span class="keyword">in</span></span><br><span class="line">        hello)          <span class="built_in">echo</span> English    ;;</span><br><span class="line">        howdy)          <span class="built_in">echo</span> American   ;;</span><br><span class="line">        gday)           <span class="built_in">echo</span> Australian ;;</span><br><span class="line">        bonjour)        <span class="built_in">echo</span> French     ;;</span><br><span class="line">        <span class="string">&quot;guten tag&quot;</span>)    <span class="built_in">echo</span> German     ;;</span><br><span class="line">        *)              <span class="built_in">echo</span> Unknown Language: <span class="variable">$input_text</span></span><br><span class="line">                ;;</span><br><span class="line">   <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span> &lt; myfile.txt</span><br></pre></td></tr></table></figure></div>

<p>比如我们的 mufile.txt 文件有以下五行:</p>
<p>这个文件叫 myfile.txt 我们们会把他作为样例输入.</p>
<p>hello</p>
<p>gday</p>
<p>bonjour</p>
<p>hola</p>
<p>这个脚本的运行如下:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./while3.sh</span><br><span class="line">Unknown Language: this file is called myfile.txt and we are using it as an example input.</span><br><span class="line">English</span><br><span class="line">Australian</span><br><span class="line">French</span><br><span class="line">Unknown Language: hola</span><br></pre></td></tr></table></figure></div>

<p>我最近从Linux From Scratch项目中学到的一个方便的Bash（但不是Bourne Shell）技巧是：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> rc&#123;0,1,2,3,4,5,6,S&#125;.d</span><br></pre></td></tr></table></figure></div>

<p>而不是更麻烦的：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> runlevel <span class="keyword">in</span> 0 1 2 3 4 5 6 S</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">mkdir</span> rc<span class="variable">$&#123;runlevel&#125;</span>.d</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<p>这也可以被迭代完成,:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /</span><br><span class="line">$ <span class="built_in">ls</span> -ld &#123;,usr,usr/local&#125;/&#123;bin,sbin,lib&#125;</span><br><span class="line">drwxr-xr-x    2 root     root         4096 Oct 26 01:00 /bin</span><br><span class="line">drwxr-xr-x    6 root     root         4096 Jan 16 17:09 /lib</span><br><span class="line">drwxr-xr-x    2 root     root         4096 Oct 27 00:02 /sbin</span><br><span class="line">drwxr-xr-x    2 root     root        40960 Jan 16 19:35 usr/bin</span><br><span class="line">drwxr-xr-x   83 root     root        49152 Jan 16 17:23 usr/lib</span><br><span class="line">drwxr-xr-x    2 root     root         4096 Jan 16 22:22 usr/local/bin</span><br><span class="line">drwxr-xr-x    3 root     root         4096 Jan 16 19:17 usr/local/lib</span><br><span class="line">drwxr-xr-x    2 root     root         4096 Dec 28 00:44 usr/local/sbin</span><br><span class="line">drwxr-xr-x    2 root     root         8192 Dec 27 02:10 usr/sbin</span><br></pre></td></tr></table></figure></div>

<h1 id="8-测试-Test"><a href="#8-测试-Test" class="headerlink" title="8 测试 Test"></a>8 测试 Test</h1><p>几乎所有脚本都会写测试. 看起来可能不是这样，因为测试通常不直接调用。测试更常称为 [.   [ 是要测试的符号链接，只是为了让 shell 进程更具可读性。它通常也是一个内置的shell（这意味着shell本身解释 [ 为 Test，即使你的Unix环境设置不同）：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> [</span><br><span class="line">[ is a shell <span class="built_in">builtin</span></span><br><span class="line">$ <span class="built_in">which</span> [</span><br><span class="line">/usr/bin/[</span><br><span class="line">$ <span class="built_in">ls</span> -l /usr/bin/[</span><br><span class="line">lrwxrwxrwx 1 root root 4 Mar 27 2000 /usr/bin/[ -&gt; <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">ls</span> -l /usr/bin/test</span><br><span class="line">-rwxr-xr-x 1 root root 35368 Mar 27  2000 /usr/bin/test</span><br></pre></td></tr></table></figure></div>

<p>这意味着 ‘[‘ 实际上是一个进程，就像 ls 和其他进程一样，所以它必须被空格包围：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [<span class="variable">$foo</span> = <span class="string">&quot;bar&quot;</span> ]</span><br></pre></td></tr></table></figure></div>

<p>不会运行.他会被解释为 <code>if text&amp;foo = “bar” ]</code>, 也就是没有’[’ 的’]’.  确保在所有操作符周围都留有空格.</p>
<p>我用“SPACE”一词突出显示了强制性空格 - 将“SPACE”替换为实际空格;如果那里没有空间，它将不起作用：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> SPACE [ SPACE <span class="string">&quot;<span class="variable">$foo</span>&quot;</span> SPACE = SPACE <span class="string">&quot;bar&quot;</span> SPACE ]</span><br></pre></td></tr></table></figure></div>

<p>注意一些 shell 也接受 “&#x3D;&#x3D;” 进行字符串比较;这不是可移植的，字符串应使用单个“&#x3D;”，整数应使用“-eq”。</p>
<p>测试是一个简单但功能强大的比较实用进程。有关完整的详细信息，请在您的系统上运行 man test，但这里有一些用法和典型示例。</p>
<p>测试最常通过 if 和 while 语句间接调用。这也是如果您创建一个名为 test 的进程并尝试运行它，您会遇到困难的原因，因为将调用此内置 shell 而不是您的进程！</p>
<p><code>if…then…else…</code> 的语法是:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ... ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="comment"># if-code</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># else-code</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>

<p>请注意，fi 是 if 倒过来！稍后在 case 和 esac 中再次使用。另外，请注意语法 - “<code>if [ ... ]</code>”和“<code>then</code>”命令必须位于不同的行上。或者，分号 “;” 可以分隔它们：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ... ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>

<p>你也可以用<code>elif</code> ,像这样</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  [ something ]; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Something&quot;</span></span><br><span class="line"> <span class="keyword">elif</span> [ something_else ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Something else&quot;</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;None of the above&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>

<p>如果 <code>[ something]</code> 成功的话, 会用echo 输出”Something”  否则他会测试 <code>[ something_else]</code>, .如果这个成功,  <code>echo “Something else ”</code> .如果其他都失败, 会 <code>echo “None of the ablove”</code> .</p>
<p>尝试以下代码片段，在运行之前，将变量 X 设置为各种值（try -1、0、1、hello、bye, etc）。您可以按如下方式执行此操作（感谢 Dave 指出需要导出变量(export)，如变量 - 第 I 部分中所述）：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ X=5</span><br><span class="line">$ <span class="built_in">export</span> X</span><br><span class="line">$ ./test.sh</span><br><span class="line">  ... output of test.sh ...</span><br><span class="line">$ X=hello</span><br><span class="line">$ ./test.sh</span><br><span class="line">  ... output of test.sh ...</span><br><span class="line">$ X=test.sh</span><br><span class="line">$ ./test.sh</span><br><span class="line">  ... output of test.sh ...</span><br></pre></td></tr></table></figure></div>

<p>然后重试，使用 $X 作为现有文档的名称，例如 &#x2F;etc&#x2F;hosts。</p>
<p>text.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -lt <span class="string">&quot;0&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;X is less than zero&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -gt <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;X is more than zero&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -le <span class="string">&quot;0&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is less than or equal to  zero&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -ge <span class="string">&quot;0&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is more than or equal to zero&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> = <span class="string">&quot;0&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is the string or number \&quot;0\&quot;&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> = <span class="string">&quot;hello&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X matches the string \&quot;hello\&quot;&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> != <span class="string">&quot;hello&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is not the string \&quot;hello\&quot;&quot;</span></span><br><span class="line">[ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is of nonzero length&quot;</span></span><br><span class="line">[ -f <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is the path of a real file&quot;</span> || \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;No such file: <span class="variable">$X</span>&quot;</span></span><br><span class="line">[ -x <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is the path of an executable file&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -nt <span class="string">&quot;/etc/passwd&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is a file which is newer than /etc/passwd&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>请注意，我们可以使用分号 （<code>;</code>) 将两行连接在一起。这样做通常是为了在简单的 <code>if</code> 语句中节省一点空间。</p>
<p>反斜杠 （<code>\</code>） 有一个类似但相反的目的：它告诉 shell 这不是行的末尾，但应将下一行视为当前行的一部分。这对于可读性很有用。通常将下一行缩进到反斜杠 （<code>\</code>） 或分号 （<code>;</code>) 之后。</p>
<p>例如，分号 （;)经常像这样用来连接 if 和 then 关键字：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -nt <span class="string">&quot;/etc/passwd&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is a file which is newer than /etc/passwd&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>

<p>虽然反斜杠 （\） 用于在 shell 脚本文档中将单行命令拆分为两行，但出于可读性目的：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -nt <span class="string">&quot;/etc/passwd&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is a file which is newer than /etc/passwd&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>正如我们从这些示例中看到的，<code>test</code> 可以对数字、字符串和文档名执行许多测试。</p>
<p><code>a，-e</code>（都表示“文档存在”），<code>-S</code>（文档是套接字），<code>-nt</code>（文档更新于），<code>-ot</code>（文档早于），<code>-ef</code>（路径引用同一文档）和<code>-O</code>（文档归运行测试的用户所有）</p>
<p>有一种更简单的 <code>if</code> 语句编写方法：<code>&amp;&amp;</code> 和 <code>||</code>命令分别提供在结果为 true 或 false 时运行的代码。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">[ <span class="variable">$X</span> -ne 0 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;X isn&#x27;t zero&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;X is zero&quot;</span></span><br><span class="line">[ -f <span class="variable">$X</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;X is a file&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;X is not a file&quot;</span></span><br><span class="line">[ -n <span class="variable">$X</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;X is of non-zero length&quot;</span> || \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is of zero length&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>这种语法是可行，是因为有一个名为 <code>[</code> 的文档（或 shell 内置）链接到<code>test</code>。</p>
<p>但是，请谨慎使用此构造，因为过度使用可能会导致代码非常难以阅读。</p>
<p>if…then…else… 结构更可读. 建议使用 <code>[...]</code> 结构用于 while 循环和您不想过度分散读者的注意力的琐碎的健全性检查</p>
<p>请注意，当您将 X 设置为非数值时，前几次比较会产生以下消息：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test.sh: [: <span class="built_in">integer</span> expression expected before -lt</span><br><span class="line">test.sh: [: <span class="built_in">integer</span> expression expected before -gt</span><br><span class="line">test.sh: [: <span class="built_in">integer</span> expression expected before -le</span><br><span class="line">test.sh: [: <span class="built_in">integer</span> expression expected before -ge</span><br></pre></td></tr></table></figure></div>

<p>这是因为 -lt、-gt、-le 和 -ge 比较仅适用于整数，不适用于字符串。字符串比较，例如 ！&#x3D; 会很乐意将 “5” 视为字符串，但没有明智的方法将 “Hello” 视为整数，因此整数比较会抱怨。</p>
<p>如果您希望 shell 脚本的行为更优雅，则必须在测试变量之前检查变量的内容 - 可能是这样的：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;Please guess the magic number: &quot;</span></span><br><span class="line"><span class="built_in">read</span> X</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$X</span> | grep <span class="string">&quot;[^0-9]&quot;</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># If the grep found something other than 0-9</span></span><br><span class="line">  <span class="comment"># then it&#x27;s not an integer.</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Sorry, wanted a number&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># The grep found only 0-9, so it&#x27;s an integer. </span></span><br><span class="line">  <span class="comment"># We can safely do a test on it.</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -eq <span class="string">&quot;7&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;You entered the magic number!&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>

<p>通过这种方式，您可以向用户回显更有意义的消息，并优雅地退出。</p>
<p><code>$？</code>变量在变量 - 第二部分中进行了解释，而grep是一头复杂的野兽，所以这里是：<code>grep [0-9]</code> 查找包含数字 （0-9） 和可能的其他字符的文本行，因此 <code>grep [^0-9]</code> 中的插入符号 （<code>^</code>） 仅查找那些不仅由数字组成的行。然后我们可以采取相反的做法（通过失败而不是成功采取行动）。好吗？<code>&gt;/dev/null 2&gt;&amp;1</code> 将任何输出或错误定向到特殊的“null”设备，而不是转到用户的屏幕。非常感谢 Paul Schermerhorn 纠正我 - 这个页面曾经声称 <code>grep -v [0-9]</code> 会起作用，但这显然太简单了。</p>
<p>我们可以在 while 循环中使用测试，如下所示：</p>
<p>stes2.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">X=0</span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Enter some text (RETURN to quit)&quot;</span></span><br><span class="line">  <span class="built_in">read</span> X</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You said: <span class="variable">$X</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<p>此代码将继续要求输入，直到您点击 RETURN（X 为零长度）。感谢贾斯汀·希思指出script不起作用 - 我漏了$X周围的引号<code>while[ -n “$X” ]</code>。没有这些引号，当$X为空时，没有什幺可以测试的。</p>
<p>亚历山大·韦伯指出，运行这个脚本会以凌乱的方式结束：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./test2.sh</span><br><span class="line">Enter some text (RETURN to quit)</span><br><span class="line">fred</span><br><span class="line">You said: fred</span><br><span class="line">Enter some text (RETURN to quit)</span><br><span class="line">wilma</span><br><span class="line">You said: wilma</span><br><span class="line">Enter some text (RETURN to quit)</span><br><span class="line"></span><br><span class="line">You said:</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div>

<p>这可以通过循环中的另一个测试来整理：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">X=0</span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Enter some text (RETURN to quit)&quot;</span></span><br><span class="line">  <span class="built_in">read</span> X</span><br><span class="line">  <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;You said: <span class="variable">$X</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<p>另请注意，我在此页面上对 if 语句使用了两种不同的语法。这些是：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -lt <span class="string">&quot;0&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;X is less than zero&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">..........  and  ........</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You said: <span class="variable">$X</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>

<p>必须在 if 语句和 then 构造之间有一个中断。这可以是分号或换行符，哪个都没关系，但是 if 和 then 之间必须有一个或另一个。最好只说：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You said: <span class="variable">$X</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>但是<code>then</code>和<code>fi</code>是绝对需要的。</p>
<h1 id="9-Case"><a href="#9-Case" class="headerlink" title="9. Case"></a>9. Case</h1><p><code>case</code> 语句省去了通过一整套 <code>if…then…else</code>声明。它的语法非常简单：</p>
<p>talk.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Please talk to me ...&quot;</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">read</span> INPUT_STRING</span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$INPUT_STRING</span> <span class="keyword">in</span></span><br><span class="line">	hello)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Hello yourself!&quot;</span></span><br><span class="line">		;;</span><br><span class="line">	<span class="built_in">bye</span>)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;See you again!&quot;</span></span><br><span class="line">		<span class="built_in">break</span></span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Sorry, I don&#x27;t understand&quot;</span></span><br><span class="line">		;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;That&#x27;s all folks!&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>好吧，所以它不是世界上最好的健谈者;这只是一个例子！</p>
<p>尝试运行它并检查它是如何工作的…</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./talk.sh</span><br><span class="line">Please talk to me ...</span><br><span class="line">hello</span><br><span class="line">Hello yourself!</span><br><span class="line">What <span class="keyword">do</span> you think of politics?</span><br><span class="line">Sorry, I don<span class="string">&#x27;t understand</span></span><br><span class="line"><span class="string">bye</span></span><br><span class="line"><span class="string">See you again!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">That&#x27;</span>s all folks!</span><br><span class="line">$</span><br></pre></td></tr></table></figure></div>

<p>语法非常简单, <code>case</code> 行本身格式不变, 他的意思是我们在测试变量 <code>INPUT_STRING</code>的值.</p>
<p>然后列出我们理解的选项，后跟右括号，如<code>hello）</code>和<code>bye）</code>。</p>
<p>这意味着，如果<code>INPUT_STRING</code>匹配 <code>hello</code>，则执行该段代码，直到双分号。</p>
<p>如果<code>INPUT_STRING</code>匹配<code>bye</code>，则打印再见消息并退出循环。请注意，如果我们想完全退出脚本，那幺我们将使用命令 <code>exit</code> 而不是 <code>break</code>。</p>
<p>这里的第三个选项，<code>*）</code>，是默认的捕获全部条件;它不是必需的，但通常对于调试目的很有用，即使我们认为我们知道测试变量将具有什幺值。</p>
<p>整个 <code>case</code> 语句以 <code>esac</code> 结尾（大小写倒置！），然后我们以 <code>done</code> 结束 <code>while</code> 循环。</p>
<p>这和<code>case</code> 条件一样复杂，但它们可能是一个非常有用和强大的工具。</p>
<p>它们通常用于解析传递给 shell 脚本的参数以及其他用途。</p>
<h1 id="10-变量-Part-ii"><a href="#10-变量-Part-ii" class="headerlink" title="10.变量 -Part ii"></a>10.变量 -Part ii</h1><p>已经为您设置了一组变量，其中大多数变量不能为其赋值。</p>
<p>这些可以包含有用的信息，脚本可以使用这些信息来了解它正在运行的环境。</p>
<p>我们将要看的第一组变量是 <code>$0 ..$9</code> 和 <code>$#</code>。</p>
<p>变量 <code>$0</code> 是进程的基本名称。(basename).<code>$1 ..$9</code> 是调用脚本时使用的前 9 个附加参数。变量 <code>$@</code> 是所有参数 <code>$1 ..whatever</code>。变量 <code>$*</code> 类似，但不保留任何空格和引号，因此“File with spaces”变为“File”与“”spaces”。 这和我们在 第一个脚本 中看到的<code>echo</code>很像. 作为一般规则，请使用 <code>$@</code> 并避免使用 <code>$*</code>。<code>$#</code> 是调用脚本时使用的参数数。</p>
<p>让我们举一个示例脚本：</p>
<p>var3.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I was called with <span class="variable">$#</span> parameters&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My name is <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My first parameter is <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My second parameter is <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All parameters are <span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>让我们看看运行此代码并查看输出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ /home/steve/var3.sh</span><br><span class="line">I was called with 0 parameters</span><br><span class="line">My name is /home/steve/var3.sh</span><br><span class="line">My first parameter is</span><br><span class="line">My second parameter is    </span><br><span class="line">All parameters are </span><br><span class="line">$</span><br><span class="line">$ ./var3.sh hello world earth</span><br><span class="line">I was called with 3 parameters</span><br><span class="line">My name is ./var3.sh</span><br><span class="line">My first parameter is hello</span><br><span class="line">My second parameter is world</span><br><span class="line">All parameters are hello world earth</span><br></pre></td></tr></table></figure></div>

<p>请注意，<code>$0</code> 的值会根据脚本的调用方式而变化。外部实用进程<code>basename</code>可以帮助整理此问题：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My name is `basename <span class="variable">$0</span>`&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><code>$#</code> 和 <code>$1 ..$9</code> 由shell自动设置。我们可以使用 <code>shift</code> 命令获取 9 个以上的参数;请看下面的脚本：</p>
<p>var4.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -gt <span class="string">&quot;0&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$1 is <span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<p>此脚本一直使用 <code>shift</code>，直到 <code>$#</code> 降至零，直到列表为空。</p>
<p>另一个特殊变量是 <code>$？</code>。这包含上次运行命令的退出值。所以代码：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/usr/local/bin/my-command</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -ne <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Sorry, we had a problem there!&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>

<p>将尝试运行 <code>/usr/local/bin/my-command</code>，如果一切顺利，该命令应以零值退出，或在失败时以非零值退出。调用命令后,我们可以通过检查 <code>$？</code>的值来处理返回.这有助于使脚本健壮且更智能。</p>
<p>运行良好的应用进程在成功时应返回零。因此引用：</p>
<blockquote>
<p>罗马帝国灭亡的主要原因之一是，由于缺乏零，他们无法表明他们的C计划成功终止。（罗伯特·弗斯）</p>
</blockquote>
<p>环境为您设置的另外两个主要变量是 <code>$$</code> 和 <code>$！</code>。这两个都是进程编号。</p>
<p><code>$$</code> 变量是当前运行的 shell 的 PID（进程标识符）。这对于创建临时文档很有用，例如 <code>/tmp/my-script.$$</code>，如果脚本的许多实例可以同时运行，并且它们都需要自己的临时文档，这将非常有用。</p>
<p><code>$！</code>变量是上次运行后台进程的 PID。这对于跟踪流程进行工作非常有用。</p>
<p>另一个有趣的变量是<code>IFS</code>。这是内部字段分隔符。默认值为空格制表符换行符 <code>SPACE TAB NEWLINE</code>，但如果要更改它，则更容易复制，如下所示：</p>
<p>var5.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">old_IFS=<span class="string">&quot;<span class="variable">$IFS</span>&quot;</span></span><br><span class="line">IFS=:</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Please input some data separated by colons ...&quot;</span></span><br><span class="line"><span class="built_in">read</span> x y z</span><br><span class="line">IFS=<span class="variable">$old_IFS</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x is <span class="variable">$x</span> y is <span class="variable">$y</span> z is <span class="variable">$z</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>此脚本运行如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./ifs.sh</span><br><span class="line">Please input some data separated by colons ...</span><br><span class="line">hello:how are you:today</span><br><span class="line">x is hello y is how are you z is today</span><br></pre></td></tr></table></figure></div>

<p>在处理 IFS（但任何不完全由您控制的变量）时，重要的是要意识到它可能包含空格、换行符和其他“不可控”字符。因此，最好在它周围使用双引号，即：<code>old_IFS=“$IFS”</code>而不是<code>old_IFS=$IFS</code>。</p>
<h1 id="11-变量-Part-III"><a href="#11-变量-Part-III" class="headerlink" title="11.变量 - Part III"></a>11.变量 - Part III</h1><p>正如我们在变量 - 第一部分中提到的，变量周围的大括号可避免混淆：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo=sun</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$fooshine</span>     <span class="comment"># $fooshine is undefined</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo&#125;</span>shine   <span class="comment"># displays the word &quot;sunshine&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>不过，这还不是全部 - 这些花括号还有另一个更强大的用途。我们可以处理变量未定义或为空的问题（在外壳中，未定义和 null 之间没有太大区别）。</p>
<p>使用默认值</p>
<p>请考虑以下代码片段，该代码片段提示用户输入，但接受默认值：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;What is your name [ `whoami` ] &quot;</span></span><br><span class="line"><span class="built_in">read</span> myname</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$myname</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  myname=`<span class="built_in">whoami</span>`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is : <span class="variable">$myname</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>将“<code>-en</code>”传递给 <code>echo</code> 告诉它不要添加换行符（对于 bash 和 csh）。对于 Dash、Bourne 和其他兼容的 shell，您可以在行尾使用“\c”。Ksh理解这两种形式。（注意：参见 &#x2F;echo.html 了解不同实现的说明 - 特别是 Dash&#x2F;Bourne vs Bash）</p>
<p>如果您通过按“RETURN”接受默认值，此脚本将像这样运行：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">steve$ ./name.sh</span><br><span class="line">What is your name [ steve ]</span><br><span class="line">Your name is : steve</span><br></pre></td></tr></table></figure></div>

<p>…或者，使用用户输入：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">steve$ ./name.sh</span><br><span class="line">What is your name [ steve ] foo</span><br><span class="line">Your name is : foo</span><br></pre></td></tr></table></figure></div>

<p>使用 shell 变量功能可以更好地完成此操作。通过使用大括号和特殊的“：-”用法，您可以指定在变量未设置时使用的默认值：</p>
<aside>
💡 `注意这是反引号  `   不是单引号 ‘`

</aside>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;What is your name [ `whoami` ] &quot;</span></span><br><span class="line"><span class="built_in">read</span> myname</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is : <span class="variable">$&#123;myname:-`whoami`&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>这可以被视为一种特殊情况 - 我们使用 whoami 命令的输出，该命令打印您的登录名 （UID）。更规范的示例是使用固定文本，如下所示：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is : <span class="variable">$&#123;myname:-John Doe&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>与反引号的其他用法一样，“<code>whoami</code>”在子 shell 中运行，因此在反引号内的任何 cd 命令或设置任何其他变量都不会影响当前运行的 shell。</p>
<p>使用和设置默认值</p>
<p>还有另一种语法“：&#x3D;”，如果未定义，它将变量设置为默认值：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is : <span class="variable">$&#123;myname:=John Doe&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>这种技术意味着任何后续对<code>$myname</code>变量的访问将始终获得一个值，要幺由用户输入，要幺由“John Doe”输入。</p>
<h1 id="12-外部程序"><a href="#12-外部程序" class="headerlink" title="12. 外部程序"></a>12. 外部程序</h1><p>外部进程通常在 shell 脚本中使用;有一些内置命令（<code>echo</code>，其中和<code>test</code>通常是内置的），但许多有用的命令实际上是Unix实用进程，如<code>tr</code>，<code>grep</code>，<code>expr</code>和<code>cut</code>。</p>
<p>反引号 （<code>&#39;</code>） 也经常与外部命令相关联。因此，我们将首先讨论反引号。</p>
<p>反引号用于指示将随附的文本作为命令执行。这很容易理解。首先，使用交互式 shell 从 <code>/etc/passwd</code> 读取您的全名：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep <span class="string">&quot;^<span class="variable">$&#123;USER&#125;</span>:&quot;</span> /etc/passwd | <span class="built_in">cut</span> -d: -f5</span><br><span class="line">Steve Parker</span><br></pre></td></tr></table></figure></div>

<p>现在我们将这个输出抓取到一个变量中，我们可以更轻松地操作该变量：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ MYNAME=`grep <span class="string">&quot;^<span class="variable">$&#123;USER&#125;</span>:&quot;</span> /etc/passwd | <span class="built_in">cut</span> -d: -f5`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYNAME</span></span><br><span class="line">Steve Parker</span><br></pre></td></tr></table></figure></div>

<aside>
❓ ^ caret 符号什么作用?

</aside>

<p><a class="link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20342828/what-does-symbol-mean-in-batch-script" >What does symbol ^ mean in Batch script? <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b7822b97-9aaa-4532-aa09-aaa3f31f88d5/Untitled.png"
                      alt="Untitled"
                ></p>
<p>因此，我们看到反引号只是从我们选择运行的任何命令或一组命令中捕获标准输出。如果要运行慢速命令或命令集并解析其输出的各个位，它还可以提高性能：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">find / -name <span class="string">&quot;*.html&quot;</span> -<span class="built_in">print</span> | grep <span class="string">&quot;/index.html$&quot;</span></span><br><span class="line">find / -name <span class="string">&quot;*.html&quot;</span> -<span class="built_in">print</span> | grep <span class="string">&quot;/contents.html$&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>这段代码可能需要很长时间才能运行，我们正在执行两次！ 更好的解决方案是：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">HTML_FILES=`find / -name <span class="string">&quot;*.html&quot;</span> -<span class="built_in">print</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$HTML_FILES</span>&quot;</span> | grep <span class="string">&quot;/index.html$&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$HTML_FILES</span>&quot;</span> | grep <span class="string">&quot;/contents.html$&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>注意：<code>$HTML_FILES</code> 两边的引号对于保留列出的每个文档之间的换行符至关重要。否则，<code>grep</code> 将看到一大行长文本，而不是每个文档一行。</p>
<p>这样，我们只运行一次慢速查找，大约将脚本的执行时间减半。</p>
<p>我们将在本教程的提示和技巧部分中进一步讨论具体示例。</p>
<h1 id="13-函数"><a href="#13-函数" class="headerlink" title="13. 函数"></a>13. 函数</h1><p>Bourne shell 脚本编程的一个经常被忽视的特性是，您可以轻松地编写函数以在脚本中使用。这通常通过以下两种方式之一完成;使用简单的脚本，该函数只是在调用它的同一文档中声明。</p>
<p>但是，在编写一套脚本时，编写有用函数的“库”通常更容易，并在使用这些函数的其他脚本的开头获取该文档。这个一会讲.</p>
<p>方法是一样的，但是它完成了;我们将在这里主要使用第一种方法。第二种（库）方法基本相同，只是命令</p>
<p><code>. ./library.sh</code></p>
<p>在脚本的开头。</p>
<p>对于是调用 shell 函数过程还是函数(<em>functions procedures or functions</em>)，可能会有一些混淆;传统上，函数的定义是它返回单个值，并且不输出任何内容。另一方面，过程不返回值，但可能会产生输出。shell 函数可以不执行任何操作，也可以执行其中之一或两者兼而有之。人们普遍认为，在 shell 脚本中，它们被称为函数。</p>
<p>函数可以通过以下四种不同方式之一返回值：</p>
<ul>
<li>更改一个或多个变量的状态</li>
<li>使用 exit 命令结束 shell 脚本</li>
<li>使用 return 命令结束函数，并将提供的值返回到 shell 脚本的调用部分</li>
<li>echo 输出到 stdout，输出会被捕获就像 <code>c=&#39;expr $a + $b&#39;</code></li>
</ul>
<p>这很像 C，因为<code>exit</code>停止进程，<code>return</code>将控制权返回给调用方。</p>
<p>不同之处在于 shell 函数不能更改其参数，尽管它可以更改全局参数。</p>
<p>使用函数的简单脚本如下所示：</p>
<p>function.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># A simple script with a function...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">add_a_user</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  USER=<span class="variable">$1</span></span><br><span class="line">  PASSWORD=<span class="variable">$2</span></span><br><span class="line">  <span class="built_in">shift</span>; <span class="built_in">shift</span>;</span><br><span class="line">  <span class="comment"># Having shifted twice, the rest is now comments ...</span></span><br><span class="line">  COMMENTS=<span class="variable">$@</span>      <span class="comment"># $@是所有变量</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Adding user <span class="variable">$USER</span> ...&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> useradd -c <span class="string">&quot;<span class="variable">$COMMENTS</span>&quot;</span> <span class="variable">$USER</span></span><br><span class="line">  <span class="built_in">echo</span> passwd <span class="variable">$USER</span> <span class="variable">$PASSWORD</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Added user <span class="variable">$USER</span> (<span class="variable">$COMMENTS</span>) with pass <span class="variable">$PASSWORD</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># Main body of script starts here</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Start of script...&quot;</span></span><br><span class="line">add_a_user bob letmein Bob Holness the presenter</span><br><span class="line">add_a_user fred badpassword Fred Durst the singer</span><br><span class="line">add_a_user bilko worsepassword Sgt. Bilko the role model</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;End of script...&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>shift作用:</p>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/shift-12b68ed49b624ef6a59a25a25b011f97">此脚本一直使用 <code>shift</code>，直到 <code>$#</code> 降至零，直到列表为空。</a> </p>
<p>第 4 行以 （） 结尾将自身标识为函数声明。这后面跟着 {，匹配 } 后面的所有内容都被视为该函数的代码。</p>
<p>在调用函数之前，不会执行此代码。函数被读入，但在实际调用它们之前基本上被忽略。</p>
<p>请注意，对于此示例，useradd 和 passwd 命令以 echo 为前缀 - 这是一种有用的调试技术，用于检查是否会执行正确的命令。这也意味着您可以运行脚本，而无需成为 root 用户或向系统添加狡猾的用户帐户！</p>
<p>我们已经习惯了 shell 脚本按顺序执行的想法。函数并非如此。</p>
<p>在这种情况下，函数<code>add_a_user</code>被读入并检查语法，但在显式调用之前不会执行。这就是 2014 年 Shellshock 错误发挥作用的地方。</p>
<p>函数定义后的其他命令被执行，即使它们不是函数本身的一部分。有关此内容的更多信息，请参阅 <a class="link"   target="_blank" rel="noopener" href="http://steve-parker.org/articles/shellshock/%E3%80%82" >http://steve-parker.org/articles/shellshock/。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>执行从 <code>echo</code> 语句“脚本开始…”开始。下一行，<code>add_a_user bob letmein Bob Holness</code> 被识别为函数调用，因此进入 <code>add_a_user</code> 函数并开始执行，并向环境添加某些内容：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$1</span>=bob</span><br><span class="line"><span class="variable">$2</span>=letmein</span><br><span class="line"><span class="variable">$3</span>=Bob</span><br><span class="line"><span class="variable">$4</span>=Holness</span><br><span class="line"><span class="variable">$5</span>=the</span><br><span class="line"><span class="variable">$6</span>=presenter</span><br></pre></td></tr></table></figure></div>

<p>因此，在该函数中，<code>$1</code> 设置为 <code>bob</code>，而不管函数外部的 <code>$1</code> 可能设置为什幺。</p>
<p>因此，如果我们想在函数中引用“original”$1，我们必须为它分配一个名称 - 例如：<code>A=$1</code> 在我们调用函数之前。然后，在函数中，我们可以引用<code>$A</code>。</p>
<p>我们再次使用 <code>shift</code> 命令将 <code>$3</code> 及以后的参数转换为 <code>$@</code>。</p>
<p>然后，该函数添加用户并设置其密码。它<code>echo</code>es该效果的注释，并将控制权返回到主代码的下一行。</p>
<h2 id="变量的范围-1"><a href="#变量的范围-1" class="headerlink" title="变量的范围"></a>变量的范围</h2><p>习惯于其他语言的进程员可能会对 shell 函数的作用域规则感到惊讶。基本上，除了参数（<code>$ 1</code>、<code>$2</code>、<code>$@</code>等）之外，没有范围。</p>
<p>采用以下简单代码段：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">myfunc</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;I was called as : <span class="variable">$@</span>&quot;</span></span><br><span class="line">  x=2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### Main script starts here </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Script was called with <span class="variable">$@</span>&quot;</span></span><br><span class="line">x=1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x is <span class="variable">$x</span>&quot;</span></span><br><span class="line">myfunc 1 2 3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x is <span class="variable">$x</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>当调用脚本时，当 用[<code>scope.sh](http://scope.sh/) a b c</code> 调用时，会给出以下输出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Script was called with a b c</span><br><span class="line">x is 1</span><br><span class="line">I was called as : 1 2 3</span><br><span class="line">x is 2</span><br></pre></td></tr></table></figure></div>

<p><code>$@</code> 参数在函数中更改，以反映函数的调用方式。然而，变量 <code>x</code> 实际上是一个全局变量 - <code>myfunc</code> 更改了它，当控制返回到主脚本时，该更改仍然有效。</p>
<p>如果函数的输出通过管道传输到其他地方，则会在子 shell 中调用该函数 - 即“<code>myfunc 1 2 3 |tee out.log</code>“第二次仍然会说”x is 1”。</p>
<p>这是因为调用了一个新的 shell 进程来从管道运行 <code>myfunc（）</code>。这会使调试非常令人沮丧;阿斯特丽德有一个脚本突然失败了，</p>
<p>当“<code>| tee</code>“被添加，并且为什幺必须这样做并不明显。<code>tee</code>必须在管道左侧的功能之前启动;用简单的例子 “<code>ls | grep foo</code>”, <code>grep</code> 必须先启动, 一旦 <code>LS</code> 启动，其标准输入就会绑定到 <code>LS</code> 的标准输出。在 shell 脚本中，在我们知道要通过管道传输 <code>tee</code> 之前，shell 已经启动了，所以操作系统必须启动 <code>tee</code>，然后启动一个新的 shell 来调用 <code>myfunc（）</code>。这令人沮丧，但非常值得注意。</p>
<p>函数也不能更改调用它们的值 - 这必须通过更改变量本身来完成，而不是通过传递给脚本的参数来完成。</p>
<p>一个例子更清楚地说明了这一点：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">myfunc</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$1 is <span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$2 is <span class="variable">$2</span>&quot;</span></span><br><span class="line">  <span class="comment"># cannot change $1 - we&#x27;d have to say:</span></span><br><span class="line">  <span class="comment"># 1=&quot;Goodbye Cruel&quot;</span></span><br><span class="line">  <span class="comment"># which is not a valid syntax. However, we can</span></span><br><span class="line">  <span class="comment"># change $a:</span></span><br><span class="line">  a=<span class="string">&quot;Goodbye Cruel&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### Main script starts here </span></span><br><span class="line"></span><br><span class="line">a=Hello</span><br><span class="line">b=World</span><br><span class="line">myfunc <span class="variable">$a</span> <span class="variable">$b</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;a is <span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;b is <span class="variable">$b</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>这个相当愤世嫉俗的功能改变了$a，所以消息“你好世界”变成了“再见残酷的世界”。</p>
<h2 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归 Recursion"></a>递归 Recursion</h2><p>函数可以是递归的 - 下面是阶乘函数的简单示例：</p>
<p>factorial.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">factorial</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> -gt <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    i=`<span class="built_in">expr</span> <span class="variable">$1</span> - 1`</span><br><span class="line">    j=`factorial <span class="variable">$i</span>`</span><br><span class="line">    k=`<span class="built_in">expr</span> <span class="variable">$1</span> \* <span class="variable">$j</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$k</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Enter a number:&quot;</span></span><br><span class="line">  <span class="built_in">read</span> x</span><br><span class="line">  factorial <span class="variable">$x</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<p>正如所承诺的，我们现在将简要讨论在 shell 脚本之间使用库。这些也可以用来定义公共变量，正如我们将看到的。</p>
<p>common.lib</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.lib</span></span><br><span class="line"><span class="comment"># Note no #!/bin/sh as this should not spawn </span></span><br><span class="line"><span class="comment"># an extra shell. It&#x27;s not the end of the world </span></span><br><span class="line"><span class="comment"># to have one, but clearer not to.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">STD_MSG=<span class="string">&quot;About to rename some files...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rename</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment"># expects to be called as: rename .txt .bak </span></span><br><span class="line">  FROM=<span class="variable">$1</span></span><br><span class="line">  TO=<span class="variable">$2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> *<span class="variable">$FROM</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    j=`<span class="built_in">basename</span> <span class="variable">$i</span> <span class="variable">$FROM</span>`</span><br><span class="line">    <span class="built_in">mv</span> <span class="variable">$i</span> <span class="variable">$&#123;j&#125;</span><span class="variable">$TO</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>function2.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># function2.sh</span></span><br><span class="line">. ./common.lib</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$STD_MSG</span></span><br><span class="line">rename .txt .bak</span><br></pre></td></tr></table></figure></div>

<p>function3.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># function3.sh</span></span><br><span class="line">. ./common.lib</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$STD_MSG</span></span><br><span class="line">rename .html .html-bak</span><br></pre></td></tr></table></figure></div>

<p>在这里，我们看到两个用户 shell 脚本，<a target="_blank" rel="noopener" href="http://function2.sh/"><code>function2.sh</code></a> 和 <a target="_blank" rel="noopener" href="http://function3.sh/"><code>function3.sh</code></a>，每个脚本都源自公共库文档 <code>common.lib</code>，并使用该文档中声明的变量和函数。</p>
<p>这没什幺惊天动地的，只是如何在 shell 编程中完成代码重用的一个例子。</p>
<h2 id="返回代码-Return-Codes"><a href="#返回代码-Return-Codes" class="headerlink" title="返回代码 Return Codes"></a>返回代码 Return Codes</h2><p>有关退出代码的详细信息，请参阅教程的Hints and Tips部分的退出代码部分。现d在，尽管我们将简要地看一下<code>return</code> 调用。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">adduser</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  USER=<span class="variable">$1</span></span><br><span class="line">  PASSWORD=<span class="variable">$2</span></span><br><span class="line">  <span class="built_in">shift</span> ; <span class="built_in">shift</span></span><br><span class="line">  COMMENTS=<span class="variable">$@</span></span><br><span class="line">  useradd -c <span class="string">&quot;<span class="variable">$&#123;COMMENTS&#125;</span>&quot;</span> <span class="variable">$USER</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -ne <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span>   <span class="comment"># $? 是上次运行命令的退出值</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Useradd failed&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  passwd <span class="variable">$USER</span> <span class="variable">$PASSWORD</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -ne <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Setting password failed&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 2</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Added user <span class="variable">$USER</span> (<span class="variable">$COMMENTS</span>) with pass <span class="variable">$PASSWORD</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Main script starts here</span></span><br><span class="line"></span><br><span class="line">adduser bob letmein Bob Holness from Blockbusters</span><br><span class="line">ADDUSER_RETURN_CODE=$?</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ADDUSER_RETURN_CODE</span>&quot;</span> -eq <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Something went wrong with useradd&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$ADDUSER_RETURN_CODE</span>&quot;</span> -eq <span class="string">&quot;2&quot;</span> ]; <span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Something went wrong with passwd&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Bob Holness added to the system.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>

<p>此脚本检查它发出的两个外部调用（<code>useradd</code> 和 <code>passwd</code>），并让用户知道它们是否失败。然后，该函数定义一个返回代码 1 以指示 useradd 的任何问题，并定义 2 以指示 passwd 的任何问题。这样，调用脚本就知道问题出在哪里。</p>
<p>很长一段时间，本教程都检查两次“<code>$？</code>”，而不是设置 <code>ADDUSER_RETURN_CODE=$？</code>，然后每次都查看 <code>ADDUSER_RETURN_CODE</code> 的值。这是一个错误（感谢Elyza指出它）。您必须保存 <code>$？</code>，因为一旦运行另一个命令（例如 if），其值就会被替换。这就是为什幺我们将 <code>adduser</code> 返回值保存在 <code>$ADDUSER_RETURN_CODE</code> 变量中，然后再对其内容进行操作。<code>$ADDUSER_RETURN_CODE</code>肯定会保持不变;<code>$?</code>将随执行的每个命令而更改。</p>
<h1 id="14-Hints-and-Tips"><a href="#14-Hints-and-Tips" class="headerlink" title="14. Hints and Tips"></a>14. Hints and Tips</h1><p>查看 <a class="link"   target="_blank" rel="noopener" href="http://www.shellscript.sh/tips/" >www.shellscript.sh/tips/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 以获取更多最新的提示和建议</p>
<p>老实说，下面的内容已经过时了。下面网站的 &#x2F;tips 部分有更多、更有用的提示。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.shellscript.sh/tips/" > <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>Unix 充满了文本操作实用进程，其中一些更强大的实用进程我们现在将在本教程的这一部分中讨论。这样做的意义在于，Unix下几乎所有的东西都是文本。实际上，您能想到的任何内容都由文本文档或命令行界面 （CLI） 控制。唯一无法使用 shell 脚本自动执行的是仅限 GUI 的实用进程或功能。而在Unix下，它们并不多！</p>
<p>你可能听说过有人说，用 *nix，“一切都是一个文档”——这是真的。</p>
<p>我们这里有几个小节…以下是一般建议、提示和技巧。</p>
<p>省略一些网址</p>
<p>我们已经在上面展示了简单但有效的 <code>cut</code>命令的使用。我们将在这里讨论一些更常见的外部进程的例子。</p>
<p><code>grep</code> 对于 shell 脚本进程员来说是一个非常有用的实用进程。 grep 的一个例子是：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">steves=`grep -i steve /etc/passwd | <span class="built_in">cut</span> -d: -f1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All users with the word \&quot;steve\&quot; in their passwd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Entries are: <span class="variable">$steves</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>如果只有一个匹配项，则此脚本看起来不错。但是，如果 &#x2F;etc&#x2F;passwd 中有两行带有词“steve”，则交互式 shell 将显示：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&gt; grep -i steve /etc/passwd </span><br><span class="line">steve:x:5062:509:Steve Parker:/home/steve:/bin/bash</span><br><span class="line">fred:x:5068:512:Fred Stevens:/home/fred:/bin/bash</span><br><span class="line">$&gt; grep -i steve /etc/passwd |<span class="built_in">cut</span> -d: -f1</span><br><span class="line">steve</span><br><span class="line">fred</span><br></pre></td></tr></table></figure></div>

<p>但脚本将显示：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entries are: steve fred</span><br></pre></td></tr></table></figure></div>

<p>通过将结果放入变量中，我们将换行符更改为空格; <code>SH</code> 手册页告诉我们，<code>$IFS</code>中的第一个字符将用于此目的。</p>
<p>默认情况下，IFS 为 <space><tab><cr>。也许虽然我们想保留换行符：如果我们把空格变成换行符，看起来会更好……这是 <code>tr</code> 的工作：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">steves=`grep -i steve /etc/passwd | <span class="built_in">cut</span> -d: -f1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All users with the word \&quot;steve\&quot; in their passwd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Entries are: &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$steves</span>&quot;</span> | <span class="built_in">tr</span> <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\012&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>请注意，tr 将空格转换为八进制字符 012（换行符）。 tr的另一个常见用途是它使用范围…它可以将文本转换为大写或小写，例如：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">steves=`grep -i steve /etc/passwd | <span class="built_in">cut</span> -d: -f1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All users with the word &quot;</span>steve<span class="string">&quot; in their passwd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Entries are: &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$steves</span>&quot;</span> | <span class="built_in">tr</span> <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\012&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[a-z]&#x27;</span> <span class="string">&#x27;[A-Z]&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>在这里，我们添加了 [a-z] 到 [A-Z] 的翻译。请注意，a-z 范围内的值数量与 A-Z 完全相同。然后，这可以将属于 ASCII 范围 a-z 的任何字符转换为 A-Z …换句话说，将小写字母转换为大写字母。<code>TR</code> 实际上比这更聪明：<code>TR [：lower：] [：upper：]</code> 也可以完成这项工作，而且可能更具可读性。它也不是那幺可移植;并非每个 TR 都能做到这一点。</p>
<h2 id="欺骗-Cheating"><a href="#欺骗-Cheating" class="headerlink" title="欺骗 Cheating"></a>欺骗 Cheating</h2><p>那些不能…欺骗的人</p>
<p>作弊没有错！有些事情shell不是很擅长。两个有用的工具是<code>sed</code>和<code>awk</code>。虽然这是两个非常强大的实用进程，它们本身可以用作迷你编程语言，但由于非常简单的特定原因，它们经常在 shell 脚本中使用。</p>
<p>虽然这意味着系统必须加载一个大型可执行文档（sed 为 52k，awk 为 110k），这是一件令人讨厌的事情，但一个好工人不会责怪他的工具的原因是，一个好工人首先使用正确的工具。</p>
<p>因此，让我介绍一下这两个，用途非常简单。</p>
<p>用awk作弊</p>
<p>考虑 wc，它计算文本文档中的字符、行数和单词数。其输出为：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">wc</span> hex2env.c</span><br><span class="line">	102	189	2306	hex2env.c</span><br></pre></td></tr></table></figure></div>

<p>如果我们想将行数放入一个变量中，只需使用：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NO_LINES=`<span class="built_in">wc</span> -l file`</span><br></pre></td></tr></table></figure></div>

<p>这将在整行中阅读。</p>
<p>由于输出是空格填充的，因此我们无法可靠地将数字 102 放入字符串中。相反，我们使用<code>awk</code>与C中的<code>scanf</code>类似的性质 - 它去除了不需要的空格.它将它们放入变量 <code>$1 $2 $3</code> 等。所以我们使用这个结构：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NO_LINES=`<span class="built_in">wc</span> -l file | awk <span class="string">&#x27;&#123; print $1 &#125;&#x27;</span>`</span><br></pre></td></tr></table></figure></div>

<p>变量NO_LINES现在为 102。</p>
<h3 id="用sed作弊"><a href="#用sed作弊" class="headerlink" title="用sed作弊"></a>用sed作弊</h3><p>另一个方便的实用进程是 sed - 流编辑器。Perl 非常擅长处理正则表达式，而 shell 则不然。因此，我们可以通过调用 sed 来快速使用 <code>s/from/to/g</code> 结构。例如：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed s/eth0/eth1/g file1 &gt;  file2</span><br></pre></td></tr></table></figure></div>

<p>将文档 1 中 <code>eth0</code> 的每个实例更改为文档 2 中的 <code>eth1</code>。</p>
<p>如果我们只更改单个字符，tr 将是要使用的工具，更小，因此加载速度更快。</p>
<p>tr 不能做的另一件事是从文档中删除字符：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;SOMETHING&#125;</span> | sed s/<span class="string">&quot;bad word&quot;</span>//g</span><br></pre></td></tr></table></figure></div>

<p>这会从变量 <code>$&#123;SOMETHING&#125;</code> 中删除短语“bad word”。人们可能会说，“但是 grep 可以做到这一点！”——grep 只处理整行。考虑以下文档：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This line is okay.</span><br><span class="line">This line contains a bad word. Treat with care.</span><br><span class="line">This line is fine, too.</span><br></pre></td></tr></table></figure></div>

<p>Grep 将删除整个第二行，只留下一个两行文档;sed 会将文档更改为读取：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This line is okay.</span><br><span class="line">This line contains a . Treat with care.</span><br><span class="line">This line is fine, too.</span><br></pre></td></tr></table></figure></div>

<h2 id="Telnet-提示"><a href="#Telnet-提示" class="headerlink" title="Telnet 提示"></a>Telnet 提示</h2><p>这是我从 Sun 的资源管理器实用进程中学到的一个有用的技术。虽然 telnet 不再用于服务器，但它仍然被某些网络设备使用，例如终端集中器等。通过创建如下脚本、您自己的脚本或从命令行创建，您可以运行：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./telnet1.sh | telnet</span><br></pre></td></tr></table></figure></div>

<p>我有几个人问过我这个问题，并倾向于将他们指向预期的代码套件，它非常复杂和笨重;</p>
<p>这段代码应该在系统之间非常可移植（只要它们有 egrep）。如果它不能在你的系统上工作，请尝试使用带有 -q 开关的 GNU grep，或者使用专有的 grep 并直接使用 &#x2F;dev&#x2F;null。不过，仍然比安装预期的要容易得多。</p>
<p>telnet.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">host=127.0.0.1</span><br><span class="line">port=23</span><br><span class="line">login=steve</span><br><span class="line">passwd=hellothere</span><br><span class="line">cmd=<span class="string">&quot;ls /tmp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> open <span class="variable">$&#123;host&#125;</span> <span class="variable">$&#123;port&#125;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;login&#125;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;passwd&#125;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;cmd&#125;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">exit</span></span><br></pre></td></tr></table></figure></div>

<p>但是，Sun 添加了一些巧妙的错误检查代码（请注意，您可以从当前的 shell 或 shell 脚本中设置和导出变量，以避免将密码存储在可读文档中）：</p>
<p><code>$ ./telnet2.sh | telnet &gt; file1</code>  </p>
<p>telnet2.sh</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># telnet2.sh | telnet &gt; FILE1 </span></span><br><span class="line">host=127.0.0.1</span><br><span class="line">port=23</span><br><span class="line">login=steve</span><br><span class="line">passwd=hellothere</span><br><span class="line">cmd=<span class="string">&quot;ls /tmp&quot;</span></span><br><span class="line"><span class="built_in">timeout</span>=3</span><br><span class="line">file=file1</span><br><span class="line">prompt=<span class="string">&quot;$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> open <span class="variable">$&#123;host&#125;</span> <span class="variable">$&#123;port&#125;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line">tout=<span class="variable">$&#123;timeout&#125;</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;tout&#125;</span>&quot;</span> -ge 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tail</span> -1 <span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span> 2&gt;/dev/null | egrep -e <span class="string">&quot;login:&quot;</span> &gt; /dev/null</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;login&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 1</span><br><span class="line">        tout=-5</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">sleep</span> 1</span><br><span class="line">        tout=`<span class="built_in">expr</span> <span class="variable">$&#123;tout&#125;</span> - 1`</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;tout&#125;</span>&quot;</span> -ne <span class="string">&quot;-5&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">tout=<span class="variable">$&#123;timeout&#125;</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;tout&#125;</span>&quot;</span> -ge 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tail</span> -1 <span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span> 2&gt;/dev/null | egrep -e <span class="string">&quot;Password:&quot;</span> &gt; /dev/null</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;passwd&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 1</span><br><span class="line">        tout=-5</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">tail</span> -1 <span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span> 2&gt;/dev/null | egrep -e <span class="string">&quot;<span class="variable">$&#123;prompt&#125;</span>&quot;</span> &gt; /dev/null</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">        tout=-5</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">sleep</span> 1</span><br><span class="line">        tout=`<span class="built_in">expr</span> <span class="variable">$&#123;tout&#125;</span> - 1`</span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;tout&#125;</span>&quot;</span> -ne <span class="string">&quot;-5&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="variable">$&#123;file&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;cmd&#125;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">exit</span></span><br></pre></td></tr></table></figure></div>

<p>请注意，在此版本中，输出被抓取到 <code>file1</code>，并且脚本实际上使用此文档来检查其进度。我添加了“<code>&gt; $&#123;file&#125;</code>”，以便接收到文档中的输出只是命令的输出，而不是登录过程。</p>
<h1 id="15-快速参考"><a href="#15-快速参考" class="headerlink" title="15. 快速参考"></a>15. 快速参考</h1><p>这是一个快速参考指南，介绍了一些不太容易猜到的命令和 shell 脚本代码的含义。就其性质而言，使用搜索引擎也很难找到它们。这些示例包括进程管理、shell 脚本参数和 shell 脚本测试条件。</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>Run the previous command in the background</td>
<td>ls &amp;</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>Logical AND</td>
<td>if [ “$foo” -ge “0” ] &amp;&amp; [ “$foo” -le “9”]</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>Start of line</td>
<td>grep “^foo”</td>
</tr>
<tr>
<td>$</td>
<td>End of line</td>
<td>grep “foo$”</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>String equality (cf. -eq)</td>
<td>if [ “$foo” &#x3D; “bar” ]</td>
</tr>
<tr>
<td>!</td>
<td>Logical NOT</td>
<td>if [ “$foo” !&#x3D; “bar” ]</td>
</tr>
<tr>
<td>$$</td>
<td>PID of current shell</td>
<td>echo “my PID &#x3D; $$”</td>
</tr>
<tr>
<td>$!</td>
<td>PID of last background command</td>
<td>ls &amp; echo “PID of ls &#x3D; $!”</td>
</tr>
<tr>
<td>$?</td>
<td>exit status of last command</td>
<td>ls ; echo “ls returned code $?”</td>
</tr>
<tr>
<td>$0</td>
<td>Name of current command (as called)</td>
<td>echo “I am $0”</td>
</tr>
<tr>
<td>$1</td>
<td>Name of current command’s first parameter</td>
<td>echo “My first argument is $1”</td>
</tr>
<tr>
<td>$9</td>
<td>Name of current command’s ninth parameter</td>
<td>echo “My ninth argument is $9”</td>
</tr>
<tr>
<td>$@</td>
<td>All of current command’s parameters (preserving whitespace and quoting)</td>
<td>echo “My arguments are $@”</td>
</tr>
<tr>
<td>$*</td>
<td>All of current command’s parameters (not preserving whitespace and quoting)</td>
<td>echo “My arguments are $*”</td>
</tr>
<tr>
<td>-eq</td>
<td>Numeric Equality</td>
<td>if [ “$foo” -eq “9” ]</td>
</tr>
<tr>
<td>-ne</td>
<td>Numeric Inquality</td>
<td>if [ “$foo” -ne “9” ]</td>
</tr>
<tr>
<td>-lt</td>
<td>Less Than</td>
<td>if [ “$foo” -lt “9” ]</td>
</tr>
<tr>
<td>-le</td>
<td>Less Than or Equal</td>
<td>if [ “$foo” -le “9” ]</td>
</tr>
<tr>
<td>-gt</td>
<td>Greater Than</td>
<td>if [ “$foo” -gt “9” ]</td>
</tr>
<tr>
<td>-ge</td>
<td>Greater Than or Equal</td>
<td>if [ “$foo” -ge “9” ]</td>
</tr>
<tr>
<td>-z</td>
<td>String is zero length</td>
<td>if [ -z “$foo” ]</td>
</tr>
<tr>
<td>-n</td>
<td>String is not zero length</td>
<td>if [ -n “$foo” ]</td>
</tr>
<tr>
<td>-nt</td>
<td>Newer Than</td>
<td>if [ “$file1” -nt “$file2” ]</td>
</tr>
<tr>
<td>-d</td>
<td>Is a Directory</td>
<td>if [ -d &#x2F;bin ]</td>
</tr>
<tr>
<td>-f</td>
<td>Is a File</td>
<td>if [ -f &#x2F;bin&#x2F;ls ]</td>
</tr>
<tr>
<td>-r</td>
<td>Is a readable file</td>
<td>if [ -r &#x2F;bin&#x2F;ls ]</td>
</tr>
<tr>
<td>-w</td>
<td>Is a writable file</td>
<td>if [ -w &#x2F;bin&#x2F;ls ]</td>
</tr>
<tr>
<td>-x</td>
<td>Is an executable file</td>
<td>if [ -x &#x2F;bin&#x2F;ls ]</td>
</tr>
<tr>
<td>( … )</td>
<td>Function definition</td>
<td>function myfunc() { echo hello }</td>
</tr>
</tbody></table>
<h1 id="16-interactive-Shell"><a href="#16-interactive-Shell" class="headerlink" title="16. interactive Shell"></a>16. interactive Shell</h1><p>以下是一些以交互方式使用 UNIX 或 Linux shell 的快速提示。就个人而言，我建议将 bash shell 用于大多数交互式用途;它几乎可用于每种 *nix 口味，并且用作登录Shell非常愉快。</p>
<h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>bash有一些非常方便的历史搜索jl工具;向上和向下箭头键将滚动浏览先前命令的历史记录。更有用的是，Ctrl+r 将执行反向搜索，匹配命令行的任何部分。点击 ESC，所选命令将粘贴到当前 shell 中，供您根据需要进行编辑。</p>
<p>如果要重复之前运行的命令，并且知道它以哪些字符开头，则可以执行以下操作：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash$ <span class="built_in">ls</span> /tmp</span><br><span class="line">(list of files <span class="keyword">in</span> /tmp)</span><br><span class="line">bash$ <span class="built_in">touch</span> /tmp/foo</span><br><span class="line">bash$ !l</span><br><span class="line"><span class="built_in">ls</span> /tmp</span><br><span class="line">(list of files <span class="keyword">in</span> /tmp, now including /tmp/foo)</span><br></pre></td></tr></table></figure></div>

<p>除了箭头键，您还可以使用 PageUp 和 PageDn 导航到命令行的开头和结尾。</p>
<h2 id="Ksh"><a href="#Ksh" class="headerlink" title="Ksh"></a>Ksh</h2><p>您可以通过添加历史记录命令使 ksh 更可用，不管是 <code>vi</code>模式或 <code>emacs</code>模式. 有多种方法可以做到这一点，具体取决于具体情况。</p>
<p><code>set -o vi、ksh -o vi</code> 或 <code>exec ksh -o vi</code>（如果您更喜欢 emacs 模式，可以将 “vi” 替换为 “emacs”）。</p>
<p>如果你想从另一个交互式 shell 启动一个 ksh 会话，你可以像这样调用 ksh：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">csh% <span class="comment"># oh no, it&#x27;s csh!</span></span><br><span class="line">csh% ksh</span><br><span class="line">ksh$ <span class="comment"># phew, that&#x27;s better</span></span><br><span class="line">ksh$ <span class="comment"># do some stuff under ksh</span></span><br><span class="line">ksh$ <span class="comment"># then leave it back at the csh prompt:</span></span><br><span class="line">ksh$ <span class="built_in">exit</span></span><br><span class="line">csh%</span><br></pre></td></tr></table></figure></div>

<p>这将启动一个新的 ksh 会话，您可以从该会话退出并返回到上一个 shell。或者，您可以使用 <code>exec</code> 命令将 csh（或任何 shell）替换为 ksh shell：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">csh% <span class="comment"># oh no, it&#x27;s csh!</span></span><br><span class="line">csh% <span class="built_in">exec</span> ksh</span><br><span class="line">ksh$ <span class="comment"># do some stuff under ksh</span></span><br><span class="line">ksh$ <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">login:</span><br></pre></td></tr></table></figure></div>

<p>这里的区别在于您不会恢复 csh 会话。 好东西是历史记录：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">csh% ksh</span><br><span class="line">ksh$ <span class="built_in">set</span> -o vi</span><br><span class="line">ksh$ <span class="comment"># You can now edit the history with vi-like commands, </span></span><br><span class="line">  <span class="comment"># and use ESC-k to access the history.</span></span><br></pre></td></tr></table></figure></div>

<p>如果您按 ESC 然后按 k，则通过反复按 k，您可以向后滚动命令历史记录。您可以使用 vi 命令模式和进入模式命令来编辑命令，如下所示：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ksh$ <span class="built_in">touch</span> foo</span><br><span class="line">  ESC-k (enter vi mode, brings up the previous <span class="built_in">command</span>)</span><br><span class="line">  w (skip to the next word, to go from <span class="string">&quot;touch&quot;</span> to <span class="string">&quot;foo&quot;</span></span><br><span class="line">  cw (change word) bar (change <span class="string">&quot;foo&quot;</span> to <span class="string">&quot;bar&quot;</span>)</span><br><span class="line">ksh$ <span class="built_in">touch</span> bar</span><br></pre></td></tr></table></figure></div>

<h1 id="17-练习"><a href="#17-练习" class="headerlink" title="17 练习"></a>17 练习</h1><p>我认为一个快速练习可能有助于确定您在 shell 脚本方面的表现……</p>
<ul>
<li>地址簿</li>
<li>目录遍历</li>
</ul>
<h2 id="地址簿"><a href="#地址簿" class="headerlink" title="地址簿"></a>地址簿</h2><p>好吧，这很无聊，但这是你今天的练习：使用 bourne 或 bourne-again shell 创建一个地址簿进程。</p>
<p>它应该使用函数来执行所需的任务。它应该是menu-based，允许您的选项：</p>
<ul>
<li>搜索地址簿</li>
<li>添加条目</li>
<li>删除&#x2F;编辑条目</li>
</ul>
<p>您还需要一个“显示display”函数，以便在选择时显示一个或多个记录。</p>
<h3 id="搜索search"><a href="#搜索search" class="headerlink" title="搜索search"></a>搜索search</h3><p><a class="link"   target="_blank" rel="noopener" href="https://www.notion.so/Smith-b279bfbe77fe447cb745c08faeb4bf17" >当用户搜索“Smith”时，脚本应标识并显示所有“史密斯”记录。此搜索是仅在姓氏中还是在整个记录中由您决定。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="添加-add"><a href="#添加-add" class="headerlink" title="添加 add"></a>添加 add</h3><p>输入数据（姓名、姓氏、电子邮件、电话等）。 如果它看起来是重复的，提供编辑现有记录提供额外奖励。 当用户确认时，将记录保存到数据文档中。</p>
<h3 id="移除remove"><a href="#移除remove" class="headerlink" title="移除remove"></a>移除remove</h3><p>输入搜索条件，将其缩小到一个，确认，然后删除该记录。</p>
<h3 id="编辑edit"><a href="#编辑edit" class="headerlink" title="编辑edit"></a>编辑edit</h3><p>作为删除，但对默认条目使用现有记录。 例如，如果您更改电话号码，则会话可能如下所示，如果您只想更改 John Smith 的电话号码：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name [ John Smith ]</span><br><span class="line">Phone [ 12345 ] 54321</span><br><span class="line">Email [ joe@smith.org.uk ]</span><br></pre></td></tr></table></figure></div>

<p>删除旧记录，然后添加新记录。或者，编辑现有记录，尽管这可能更困难。</p>
<h3 id="奖励积分-Bonus-Points"><a href="#奖励积分-Bonus-Points" class="headerlink" title="奖励积分 Bonus Points"></a>奖励积分 Bonus Points</h3><ul>
<li>允许取消选项（使用“特殊”条目（^d，CR，^c等））</li>
<li>添加“确认”选项。</li>
<li>提供交互&#x2F;非交互模式。（即，基于菜单的版本和基于命令行 （CLI） 的选项。</li>
<li>使用命令行界面CLI版本的getopt玩。</li>
</ul>
<h3 id="提示-x2F-需要考虑的问题"><a href="#提示-x2F-需要考虑的问题" class="headerlink" title="提示 &#x2F; 需要考虑的问题"></a>提示 &#x2F; 需要考虑的问题</h3><ul>
<li><p>建议的记录格式：使用冒号分隔字段。</p>
<p>  John Smith: 54321:<a class="link"   href="mailto:&#x6a;&#111;&#x68;&#x6e;&#64;&#115;&#x6d;&#105;&#x74;&#x68;&#46;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#x2e;&#x63;&#111;&#109;" >&#x6a;&#111;&#x68;&#x6e;&#64;&#115;&#x6d;&#105;&#x74;&#x68;&#46;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#x2e;&#x63;&#111;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>这样您就可以使用“cut -d：”来读取字段。</p>
</li>
<li><p>考虑使用 IFS 作为此方法的替代方法。</p>
</li>
<li><p>考虑使用空格 （“ ”） 分隔字段，并将输入中的任何空格转换为下划线 （“_”），然后再次将它们转换回来以显示。</p>
</li>
</ul>

        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> shellscript 教程</li>
        <li><strong>Author:</strong> peng cheng</li>
        <li><strong>Created at
                :</strong> 2023-03-02 19:47:24</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2023-04-08 09:58:53
            </li>
        
        <li>
            <strong>Link:</strong> https://wespc.github.io//[object Object]/2023/03/02/shellscript/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/shellscript/">#shellscript</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/%5Bobject%20Object%5D/2023/04/08/proc/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">linux系统进程文件procs</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/%5Bobject%20Object%5D/2023/02/19/calculus18d01-1/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">2.Part C Mean Value Theorem, Antiderivatives and Differential Equations</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://example.example.com',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          recaptchaV3Key: "wasd",
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">shellscript 教程</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%AB%99"><span class="nav-text">网站</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="nav-text">1. 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%99%E4%B8%AA%E6%95%99%E7%A8%8B%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-text">这个教程的目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%AF%BB%E8%80%85"><span class="nav-text">面向读者:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E6%95%99%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8E%92%E7%89%88%E7%BA%A6%E6%9D%9F"><span class="nav-text">本教程中使用的排版约束</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%93%B2%E5%AD%A6"><span class="nav-text">2.哲学</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC"><span class="nav-text">3.第一个脚本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%8F%98%E9%87%8F-Part-1"><span class="nav-text">4. 变量 Part 1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-text">变量的范围</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E9%80%9A%E9%85%8D%E7%AC%A6-Wildcards"><span class="nav-text">5 通配符 Wildcards</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="nav-text">6. 转义字符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%BE%AA%E7%8E%AF-Loops"><span class="nav-text">7 循环 Loops</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#For-%E5%BE%AA%E7%8E%AF"><span class="nav-text">For 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#While-%E5%BE%AA%E7%8E%AF"><span class="nav-text">While 循环.</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E6%B5%8B%E8%AF%95-Test"><span class="nav-text">8 测试 Test</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-Case"><span class="nav-text">9. Case</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E5%8F%98%E9%87%8F-Part-ii"><span class="nav-text">10.变量 -Part ii</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E5%8F%98%E9%87%8F-Part-III"><span class="nav-text">11.变量 - Part III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">12. 外部程序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-%E5%87%BD%E6%95%B0"><span class="nav-text">13. 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E8%8C%83%E5%9B%B4-1"><span class="nav-text">变量的范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92-Recursion"><span class="nav-text">递归 Recursion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E4%BB%A3%E7%A0%81-Return-Codes"><span class="nav-text">返回代码 Return Codes</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-Hints-and-Tips"><span class="nav-text">14. Hints and Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AC%BA%E9%AA%97-Cheating"><span class="nav-text">欺骗 Cheating</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8sed%E4%BD%9C%E5%BC%8A"><span class="nav-text">用sed作弊</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Telnet-%E6%8F%90%E7%A4%BA"><span class="nav-text">Telnet 提示</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-%E5%BF%AB%E9%80%9F%E5%8F%82%E8%80%83"><span class="nav-text">15. 快速参考</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-interactive-Shell"><span class="nav-text">16. interactive Shell</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#bash"><span class="nav-text">bash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ksh"><span class="nav-text">Ksh</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-%E7%BB%83%E4%B9%A0"><span class="nav-text">17 练习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%B0%BF"><span class="nav-text">地址簿</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2search"><span class="nav-text">搜索search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0-add"><span class="nav-text">添加 add</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4remove"><span class="nav-text">移除remove</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%BE%91edit"><span class="nav-text">编辑edit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%96%E5%8A%B1%E7%A7%AF%E5%88%86-Bonus-Points"><span class="nav-text">奖励积分 Bonus Points</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-x2F-%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">提示 &#x2F; 需要考虑的问题</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">peng cheng</a>
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.0</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>



    
<script src="/js/tools/localSearch.js" type="module"></script>




    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>









<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
